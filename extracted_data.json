[
  {
    "id": 1,
    "title": "Woche 1: Grundlagen",
    "subtitle": "Grundlagen",
    "description": "Die absoluten Grundlagen von Python",
    "color": "orange",
    "days": [
      {
        "id": 1,
        "weekId": 1,
        "title": "Pers√∂nlicher Taschenrechner",
        "duration": "10-15 Min",
        "task": {
          "title": "Pers√∂nlicher Taschenrechner",
          "description": "Erstelle einen interaktiven Taschenrechner, der zwei Zahlen vom Benutzer entgegennimmt und verschiedene Berechnungen durchf√ºhrt.",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Variablen verstehen und Input holen",
            "goal": "Benutzer nach zwei Zahlen fragen und diese speichern",
            "why": "Variablen sind wie beschriftete Boxen - sie speichern Informationen, die wir sp√§ter verwenden k√∂nnen. Der `input()` Befehl ist unsere Art, mit dem Benutzer zu kommunizieren.",
            "code": "# Das 'input()' zeigt Text und wartet auf Eingabe des Benutzers\n# Was der Benutzer eingibt, wird als TEXT gespeichert\nzahl1_text = input(\"Gib die erste Zahl ein: \")\n\n# 'float()' wandelt den TEXT in eine ZAHL mit Komma um\n# Warum? Weil wir mit Zahlen rechnen wollen, nicht mit Text!\nzahl1 = float(zahl1_text)\n\n# Das gleiche f√ºr die zweite Zahl\nzahl2_text = input(\"Gib die zweite Zahl ein: \")\nzahl2 = float(zahl2_text)\n\n# Zur Kontrolle: Zeige was gespeichert wurde\nprint(f\"Du hast eingegeben: {zahl1} und {zahl2}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Berechnungen durchf√ºhren",
            "goal": "Mit den Zahlen verschiedene mathematische Operationen ausf√ºhren",
            "why": "Operatoren (+, -, *, /) sind die grundlegenden Werkzeuge in Python. Jeder Operator hat eine spezifische Aufgabe.",
            "code": "# Grundrechenarten - jedes Ergebnis wird in einer neuen Variable gespeichert\nsumme = zahl1 + zahl2          # Addition: Zahlen zusammenz√§hlen\ndifferenz = zahl1 - zahl2       # Subtraktion: Erste minus zweite Zahl\nprodukt = zahl1 * zahl2         # Multiplikation: Zahlen multiplizieren\nquotient = zahl1 / zahl2        # Division: Erste durch zweite Zahl teilen\n\n# Fortgeschrittene Operationen\npotenz = zahl1 ** zahl2         # ** bedeutet \"hoch\" (z.B. 2**3 = 2√ó2√ó2 = 8)\nrest = zahl1 % zahl2            # % gibt den Rest bei Division (z.B. 7%3 = 1)\nganzzahl_division = zahl1 // zahl2  # // teilt und rundet AB (z.B. 7//2 = 3)\n\n# Ausgabe aller Ergebnisse\nprint(\"\\n--- Ergebnisse ---\")\nprint(f\"Summe: {zahl1} + {zahl2} = {summe}\")\nprint(f\"Differenz: {zahl1} - {zahl2} = {differenz}\")\nprint(f\"Produkt: {zahl1} √ó {zahl2} = {produkt}\")\nprint(f\"Quotient: {zahl1} √∑ {zahl2} = {quotient}\")\nprint(f\"Potenz: {zahl1} ^ {zahl2} = {potenz}\")\nprint(f\"Rest: {zahl1} % {zahl2} = {rest}\")\nprint(f\"Ganzzahl-Division: {zahl1} // {zahl2} = {ganzzahl_division}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Ergebnisse sch√∂n formatieren",
            "goal": "Zahlen auf 2 Nachkommastellen runden f√ºr bessere Lesbarkeit",
            "why": "`3.333333333333` sieht un√ºbersichtlich aus. In echten Programmen formatieren wir Zahlen leserlich.",
            "code": "# Das ':.2f' in den f-strings bedeutet: \"Zeige nur 2 Stellen nach dem Komma\"\n# f steht f√ºr \"float\" (Kommazahl)\nprint(\"\\n--- Ergebnisse (gerundet) ---\")\nprint(f\"Summe: {zahl1} + {zahl2} = {summe:.2f}\")\nprint(f\"Differenz: {zahl1} - {zahl2} = {differenz:.2f}\")\nprint(f\"Produkt: {zahl1} √ó {zahl2} = {produkt:.2f}\")\nprint(f\"Quotient: {zahl1} √∑ {zahl2} = {quotient:.2f}\")\nprint(f\"Potenz: {zahl1} ^ {zahl2} = {potenz:.2f}\")\nprint(f\"Rest: {zahl1} % {zahl2} = {rest:.2f}\")\nprint(f\"Ganzzahl-Division: {zahl1} // {zahl2} = {ganzzahl_division:.2f}\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 2,
        "weekId": 1,
        "title": "Namensgenerator",
        "duration": "10-15 Min",
        "task": {
          "title": "Namensgenerator",
          "description": "Erstelle ein Programm, das aus Vor- und Nachnamen kreative Kombinationen und Informationen generiert.",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "String-Basics und Input",
            "goal": "Namen vom Benutzer holen und verstehen, was Strings sind",
            "why": "Strings (Texte) sind einer der wichtigsten Datentypen. Fast jede App arbeitet mit Text - Namen, Adressen, Nachrichten usw.",
            "code": "# Strings sind einfach Text in Anf√ºhrungszeichen\n# Anders als bei Zahlen brauchen wir KEIN float() - input() gibt bereits Text zur√ºck\nvorname = input(\"Wie ist dein Vorname? \")\nnachname = input(\"Wie ist dein Nachname? \")\n\n# Strings k√∂nnen mit + verbunden werden (Konkatenation)\nvoller_name = vorname + \" \" + nachname  # Das + verbindet die Texte\nprint(f\"Hallo, {voller_name}!\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "String-Methoden anwenden",
            "goal": "Text in Gro√übuchstaben, Kleinbuchstaben und Titelformat umwandeln",
            "why": "Strings haben eingebaute Funktionen (Methoden), die uns viel Arbeit abnehmen. `.upper()`, `.lower()` usw. sind solche Helfer.",
            "code": "# String-Methoden werden mit einem Punkt aufgerufen\n# Das Original bleibt unver√§ndert - es wird eine NEUE Version erstellt\n\ngro√übuchstaben = voller_name.upper()  # ALLES GRO√ü\nkleinbuchstaben = voller_name.lower()  # alles klein\ntitel_format = voller_name.title()     # Jedes Wort Gro√ü\n\nprint(\"\\n--- Verschiedene Schreibweisen ---\")\nprint(f\"Gro√übuchstaben: {gro√übuchstaben}\")\nprint(f\"Kleinbuchstaben: {kleinbuchstaben}\")\nprint(f\"Titel-Format: {titel_format}\")\n\n# Praktisches Beispiel: Initialen extrahieren\n# [0] bedeutet: \"Nimm den ersten Buchstaben\" (Python z√§hlt ab 0!)\ninitialen = vorname[0] + nachname[0]\nprint(f\"Initialen: {initialen.upper()}\")  # Wir k√∂nnen Methoden auch direkt auf Ergebnisse anwenden",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "String-Informationen auslesen",
            "goal": "L√§nge ermitteln und einzelne Zeichen zugreifen",
            "why": "Oft m√ºssen wir wissen, wie lang ein Text ist (z.B. f√ºr Passwort-Validierung) oder bestimmte Teile extrahieren.",
            "code": "# len() = length = L√§nge: Z√§hlt alle Zeichen inklusive Leerzeichen\nanzahl_buchstaben = len(voller_name)\nanzahl_vorname = len(vorname)\nanzahl_nachname = len(nachname)\n\nprint(\"\\n--- Namens-Statistiken ---\")\nprint(f\"Dein vollst√§ndiger Name hat {anzahl_buchstaben} Zeichen\")\nprint(f\"Vorname: {anzahl_vorname} Buchstaben\")\nprint(f\"Nachname: {anzahl_nachname} Buchstaben\")\n\n# Indexierung: Mit [Zahl] greifen wir auf einzelne Zeichen zu\n# WICHTIG: Python z√§hlt ab 0!\n# [0] = erstes Zeichen, [1] = zweites, usw.\n# [-1] = letztes Zeichen, [-2] = vorletztes, usw.\n\nerster_buchstabe = vorname[0]\nletzter_buchstabe = nachname[-1]  # Minus bedeutet: von hinten z√§hlen\n\nprint(f\"\\nDein Vorname beginnt mit: {erster_buchstabe}\")\nprint(f\"Dein Nachname endet mit: {letzter_buchstabe}\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Kreativer Namensgenerator",
            "goal": "Lustige/kreative Kombinationen aus den Namen erstellen",
            "why": "Hier kombinieren wir alles Gelernte zu etwas Unterhaltsamem - genau so entstehen echte Programme!",
            "code": "# Slicing: [start:end] extrahiert einen Teil des Strings\n# [0:3] bedeutet: Von Position 0 bis (aber NICHT inklusive) 3\n# Also die ersten 3 Zeichen\n\nerste_haelfte_vor = vorname[0:len(vorname)//2]  # // teilt und rundet ab\nzweite_haelfte_nach = nachname[len(nachname)//2:]  # :] bedeutet: bis zum Ende\n\n# Kreiere einen \"Spitznamen\" aus den H√§lften\nspitzname = erste_haelfte_vor + zweite_haelfte_nach\n\nprint(\"\\n--- Kreativer Namensgenerator ---\")\nprint(f\"Dein Spitzname k√∂nnte sein: {spitzname}\")\n\n# Umgekehrter Name\numgekehrt = nachname + \" \" + vorname\nprint(f\"In anderen Kulturen: {umgekehrt}\")\n\n# Name r√ºckw√§rts (mit Slicing [::-1] = von hinten nach vorne)\nrueckwaerts = voller_name[::-1]\nprint(f\"R√ºckw√§rts: {rueckwaerts}\")\n\n# Anzahl eines bestimmten Buchstabens\nbuchstabe = input(\"\\nWelcher Buchstabe interessiert dich? \").lower()\nanzahl = voller_name.lower().count(buchstabe)  # .count() z√§hlt Vorkommen\nprint(f\"Der Buchstabe '{buchstabe}' kommt {anzahl}√ó in deinem Namen vor\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 3,
        "weekId": 1,
        "title": "Einfacher Chatbot",
        "duration": "10-15 Min",
        "task": {
          "title": "Einfacher Chatbot",
          "description": "Baue einen Chatbot, der auf verschiedene Benutzereingaben unterschiedlich reagiert.",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "If-Bedingungen verstehen",
            "goal": "Programm soll verschiedene Wege gehen k√∂nnen, abh√§ngig von der Eingabe",
            "why": "In echten Programmen muss der Code Entscheidungen treffen k√∂nnen. \"Wenn der Benutzer X sagt, dann mache Y\" - das sind If-Bedingungen.",
            "code": "print(\"ü§ñ Chatbot v1.0 - Ich kann auf deine Stimmung reagieren!\")\nprint(\"(Schreibe 'bye' um zu beenden)\\n\")\n\n# Eingabe vom Benutzer holen und in Kleinbuchstaben umwandeln\n# .lower() macht es egal, ob jemand \"GUT\", \"gut\" oder \"GuT\" schreibt\nstimmung = input(\"Wie geht es dir heute? \").lower()\n\n# IF-ELIF-ELSE ist wie eine Kaskade:\n# Python pr√ºft von oben nach unten, die ERSTE zutreffende Bedingung gewinnt\n\nif stimmung == \"gut\":  # == bedeutet: \"ist gleich\" (Vergleich, nicht Zuweisung!)\n    print(\"üòä Das freut mich! Weiter so!\")\n    \nelif stimmung == \"schlecht\":  # elif = else if = \"sonst wenn\"\n    print(\"üòü Oh nein! Vielleicht hilft eine Pause?\")\n    \nelif stimmung == \"m√ºde\":\n    print(\"üò¥ Verstehe ich! Vielleicht einen Kaffee?\")\n    \nelse:  # else = \"in allen anderen F√§llen\"\n    print(\"ü§î Interessant! Erz√§hl mir mehr...\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Mehrere Bedingungen kombinieren",
            "goal": "Mit `or` und `and` mehrere M√∂glichkeiten abfangen",
            "why": "Benutzer schreiben \"gut\", \"super\", \"toll\" - wir wollen nicht f√ºr jede Variante ein neues `elif` schreiben!",
            "code": "# OR (oder): MINDESTENS EINE Bedingung muss wahr sein\n# AND (und): ALLE Bedingungen m√ºssen wahr sein\n\nstimmung = input(\"Wie geht es dir heute? \").lower()\n\n# Mit 'or' fangen wir mehrere Varianten auf einmal ab\nif stimmung == \"gut\" or stimmung == \"super\" or stimmung == \"toll\":\n    print(\"üòä Fantastisch! Ich mag deine Energie!\")\n    \n# Alternativ: Mit 'in' pr√ºfen, ob etwas in einer Liste ist (lernen wir in Tag 4)\nelif stimmung == \"schlecht\" or stimmung == \"mies\" or stimmung == \"√ºbel\":\n    print(\"üòü Das tut mir leid. Morgen wird besser!\")\n    \n# Kombination: AND und OR zusammen (Klammern helfen bei Lesbarkeit)\nelif (stimmung == \"okay\" or stimmung == \"geht so\") and len(stimmung) < 10:\n    print(\"üòê Naja, immerhin nicht schlecht!\")\n    \nelse:\n    print(\"ü§î Hmm, das kenne ich nicht. Sag mir mehr!\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Vergleichsoperatoren nutzen",
            "goal": "Nicht nur auf Gleichheit, sondern auch gr√∂√üer/kleiner pr√ºfen",
            "why": "Oft wollen wir Bereiche pr√ºfen: \"Ist die Zahl gr√∂√üer als 10?\", \"Ist der Text l√§nger als 5 Zeichen?\"",
            "code": "# Vergleichsoperatoren:\n# == gleich\n# != ungleich (nicht gleich)\n# > gr√∂√üer\n# < kleiner\n# >= gr√∂√üer oder gleich\n# <= kleiner oder gleich\n\nalter = int(input(\"Wie alt bist du? \"))  # int() wandelt in Ganzzahl um\n\nif alter < 13:\n    print(\"üßí Du bist noch ein Kind!\")\nelif alter >= 13 and alter < 18:  # Bereich: 13 bis 17\n    print(\"üòé Teenager-Jahre!\")\nelif alter >= 18 and alter < 65:\n    print(\"üíº Erwachsene/r im besten Alter!\")\nelse:  # 65 oder √§lter\n    print(\"üë¥ Weisheit und Erfahrung!\")\n\n# Noch ein Beispiel: Namen-L√§nge pr√ºfen\nname = input(\"\\nWie hei√üt du? \")\nname_laenge = len(name)\n\nif name_laenge <= 3:\n    print(f\"Wow, {name} ist ein kurzer Name!\")\nelif name_laenge >= 10:\n    print(f\"{name} - das ist aber ein langer Name!\")\nelse:\n    print(f\"{name} ist ein sch√∂ner Name!\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Vollst√§ndiger Chatbot",
            "goal": "Alle Konzepte zu einem interaktiven Chatbot kombinieren",
            "why": "Jetzt setzen wir alles zusammen - das ist ein echtes Mini-Programm!",
            "code": "print(\"=\" * 50)  # Trick: * wiederholt Strings! \"=\" * 50 = 50√ó das = Zeichen\nprint(\"ü§ñ CHATBOT v2.0 - Dein digitaler Freund\")\nprint(\"=\" * 50)\n\n# Begr√º√üung\nname = input(\"\\nWie hei√üt du? \")\nprint(f\"Hallo {name}! Sch√∂n dich kennenzulernen! üëã\")\n\n# Alter-Check\nalter = int(input(f\"Wie alt bist du, {name}? \"))\n\nif alter < 13:\n    emoji = \"üßí\"\n    kommentar = \"Cool, dass du schon programmieren lernst!\"\nelif alter < 18:\n    emoji = \"üòé\"\n    kommentar = \"Perfektes Alter, um zu coden!\"\nelif alter < 30:\n    emoji = \"üí™\"\n    kommentar = \"In den besten Jahren!\"\nelse:\n    emoji = \"üß†\"\n    kommentar = \"Erfahrung ist Gold wert!\"\n\nprint(f\"{emoji} {kommentar}\")\n\n# Stimmungs-Check\nstimmung = input(f\"\\nWie f√ºhlst du dich heute, {name}? \").lower()\n\n# Verschachtelte Bedingungen: If INNERHALB von If\nif \"gut\" in stimmung or \"super\" in stimmung or \"toll\" in stimmung:\n    # 'in' pr√ºft ob ein Wort IM String vorkommt\n    # \"gut\" in \"sehr gut\" = True\n    print(\"üòä Das ist gro√üartig!\")\n    \n    if alter < 18:\n        print(\"Jugend + gute Laune = unschlagbar! üöÄ\")\n    else:\n        print(\"Positive Einstellung macht erfolgreich! ‚≠ê\")\n        \nelif \"schlecht\" in stimmung or \"mies\" in stimmung:\n    print(\"üòü Kopf hoch!\")\n    print(f\"Wusstest du, dass {name} ein toller Name ist? üíô\")\n    \nelse:\n    print(\"ü§î Danke f√ºrs Teilen!\")\n\n# Abschied\nprint(f\"\\nSch√∂n, dass wir geredet haben, {name}! Bis bald! üëã\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 4,
        "weekId": 1,
        "title": "To-Do Liste (Konsole)",
        "duration": "10-15 Min",
        "task": {
          "title": "To-Do Liste (Konsole)",
          "description": "Erstelle eine interaktive To-Do Liste, die Aufgaben speichern, anzeigen und l√∂schen kann.",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Listen verstehen",
            "goal": "Mehrere Werte in einer Variable speichern",
            "why": "Eine Variable kann nur EINEN Wert speichern. Aber was, wenn wir 10 Aufgaben haben? Listen sind wie Beh√§lter f√ºr mehrere Werte!",
            "code": "# Eine Liste wird mit eckigen Klammern [] erstellt\n# Sie kann mehrere Werte speichern - hier Strings (Texte)\n\naufgaben = []  # Leere Liste - wie ein leerer Einkaufskorb\n\n# Elemente zur Liste hinzuf√ºgen mit .append()\n# append = anh√§ngen (ans Ende der Liste)\naufgaben.append(\"Einkaufen gehen\")\naufgaben.append(\"Python lernen\")\naufgaben.append(\"Sport machen\")\n\nprint(\"Meine Aufgaben:\")\nprint(aufgaben)  # Zeigt die ganze Liste\n\n# Auf einzelne Elemente zugreifen - wie bei Strings mit [Index]\n# WICHTIG: Python z√§hlt ab 0!\nerste_aufgabe = aufgaben[0]  # \"Einkaufen gehen\"\nzweite_aufgabe = aufgaben[1]  # \"Python lernen\"\n\nprint(f\"\\nErste Aufgabe: {erste_aufgabe}\")\nprint(f\"Zweite Aufgabe: {zweite_aufgabe}\")\n\n# Wie viele Aufgaben haben wir?\nanzahl = len(aufgaben)  # len() funktioniert auch bei Listen!\nprint(f\"\\nInsgesamt {anzahl} Aufgaben\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Listen anzeigen und manipulieren",
            "goal": "Listen-Methoden kennenlernen (hinzuf√ºgen, l√∂schen, pr√ºfen)",
            "why": "Listen sind dynamisch - wir k√∂nnen jederzeit Elemente hinzuf√ºgen oder entfernen. Das ist perfekt f√ºr To-Do Listen!",
            "code": "aufgaben = []  # Starte mit leerer Liste\n\n# Methode 1: .append() - f√ºgt am Ende hinzu\naufgaben.append(\"Email checken\")\naufgaben.append(\"Kaffee trinken\")\n\nprint(\"Nach append:\")\nprint(aufgaben)  # ['Email checken', 'Kaffee trinken']\n\n# Methode 2: .insert(position, wert) - f√ºgt an bestimmter Stelle ein\naufgaben.insert(0, \"Aufwachen\")  # An Position 0 (also ganz vorne)\n\nprint(\"\\nNach insert:\")\nprint(aufgaben)  # ['Aufwachen', 'Email checken', 'Kaffee trinken']\n\n# Methode 3: .remove(wert) - l√∂scht ein bestimmtes Element\naufgaben.remove(\"Email checken\")\n\nprint(\"\\nNach remove:\")\nprint(aufgaben)  # ['Aufwachen', 'Kaffee trinken']\n\n# Methode 4: .pop() - entfernt das LETZTE Element (und gibt es zur√ºck)\nletzte = aufgaben.pop()  # Entfernt \"Kaffee trinken\" und speichert es\n\nprint(f\"\\nEntfernt: {letzte}\")\nprint(f\"√úbrig: {aufgaben}\")  # ['Aufwachen']\n\n# Methode 5: Pr√ºfen ob etwas in der Liste ist\nif \"Aufwachen\" in aufgaben:\n    print(\"\\n'Aufwachen' ist noch auf der Liste!\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Benutzerinteraktion einbauen",
            "goal": "Der Benutzer kann interaktiv Aufgaben hinzuf√ºgen",
            "why": "Jetzt wird's praktisch! Der Benutzer bestimmt, was auf die Liste kommt.",
            "code": "# Liste f√ºr unsere Aufgaben\ntodo_liste = []\n\nprint(\"üìù TO-DO LISTE\")\nprint(\"=\" * 40)\n\n# Der Benutzer kann mehrere Aufgaben hinzuf√ºgen\n# Wir fragen einfach 3 Mal\nprint(\"\\nGib 3 Aufgaben ein:\")\n\n# Aufgabe 1\naufgabe1 = input(\"Aufgabe 1: \")\ntodo_liste.append(aufgabe1)  # Direkt zur Liste hinzuf√ºgen\n\n# Aufgabe 2\naufgabe2 = input(\"Aufgabe 2: \")\ntodo_liste.append(aufgabe2)\n\n# Aufgabe 3\naufgabe3 = input(\"Aufgabe 3: \")\ntodo_liste.append(aufgabe3)\n\n# Liste anzeigen\nprint(\"\\n--- Deine Aufgaben ---\")\n# Mit Nummern anzeigen - manuell\nprint(f\"1. {todo_liste[0]}\")\nprint(f\"2. {todo_liste[1]}\")\nprint(f\"3. {todo_liste[2]}\")\n\nprint(f\"\\nInsgesamt: {len(todo_liste)} Aufgaben\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Listen mit Bedingungen",
            "goal": "Aufgaben l√∂schen basierend auf Benutzerentscheidung",
            "why": "Kombination aus Listen und If-Bedingungen - so werden Programme m√§chtig!",
            "code": "todo_liste = []\n\nprint(\"üìù TO-DO LISTE v2.0\")\nprint(\"=\" * 40)\n\n# Aufgaben hinzuf√ºgen\nprint(\"\\nF√ºge Aufgaben hinzu (oder 'fertig' zum Beenden):\")\n\n# Erste Aufgabe\naufgabe = input(\"Aufgabe: \")\nif aufgabe != \"fertig\":  # Nur hinzuf√ºgen, wenn nicht \"fertig\"\n    todo_liste.append(aufgabe)\n\n# Zweite Aufgabe\naufgabe = input(\"Aufgabe: \")\nif aufgabe != \"fertig\":\n    todo_liste.append(aufgabe)\n\n# Dritte Aufgabe\naufgabe = input(\"Aufgabe: \")\nif aufgabe != \"fertig\":\n    todo_liste.append(aufgabe)\n\n# Liste anzeigen\nif len(todo_liste) == 0:  # Pr√ºfe ob Liste leer ist\n    print(\"\\n‚ùå Keine Aufgaben vorhanden!\")\nelse:\n    print(f\"\\n‚úÖ Du hast {len(todo_liste)} Aufgaben:\")\n    \n    # Zeige nur so viele, wie tats√§chlich vorhanden sind\n    for i in range(len(todo_liste)):  # range() erstellt Zahlen von 0 bis len-1\n        print(f\"{i+1}. {todo_liste[i]}\")  # i+1 damit wir bei 1 starten, nicht 0\n    \n    # Aufgabe als erledigt markieren (= l√∂schen)\n    if len(todo_liste) > 0:\n        erledigt = input(\"\\nWelche Aufgabe hast du erledigt? (Nummer): \")\n        \n        # String in Zahl umwandeln und -1 (weil Python bei 0 z√§hlt)\n        if erledigt.isdigit():  # Pr√ºfe ob es eine Zahl ist\n            index = int(erledigt) - 1\n            \n            # Pr√ºfe ob die Nummer g√ºltig ist\n            if index >= 0 and index < len(todo_liste):\n                entfernt = todo_liste.pop(index)  # .pop(index) entfernt an Position\n                print(f\"‚úÖ '{entfernt}' wurde entfernt!\")\n                \n                # Zeige verbleibende Aufgaben\n                if len(todo_liste) > 0:\n                    print(f\"\\nVerbleibende Aufgaben: {len(todo_liste)}\")\n                    for i in range(len(todo_liste)):\n                        print(f\"{i+1}. {todo_liste[i]}\")\n                else:\n                    print(\"\\nüéâ Alle Aufgaben erledigt!\")\n            else:\n                print(\"‚ùå Ung√ºltige Nummer!\")\n        else:\n            print(\"‚ùå Bitte eine Zahl eingeben!\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 5,
        "weekId": 1,
        "title": "Multiplikationstabelle Generator",
        "duration": "10-15 Min",
        "task": {
          "title": "Multiplikationstabelle Generator",
          "description": "Erstelle ein Programm, das Multiplikationstabellen generiert - mit For-Schleifen!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "For-Schleife Grundlagen",
            "goal": "Verstehen wie for-Schleifen funktionieren",
            "why": "Stell dir vor, du willst 100 Zahlen ausgeben. W√ºrdest du 100√ó `print()` schreiben? NEIN! Schleifen wiederholen Code automatisch.",
            "code": "# For-Schleife = \"F√úR jedes Element MACHE etwas\"\n# range(5) erstellt die Zahlen 0, 1, 2, 3, 4\n\nprint(\"Z√§hlen von 0 bis 4:\")\nfor zahl in range(5):  # 'zahl' ist eine Variable, die jede Zahl nacheinander annimmt\n    print(zahl)  # Wird 5√ó ausgef√ºhrt\n    \n# Das ist das gleiche wie:\n# print(0)\n# print(1)\n# print(2)\n# print(3)\n# print(4)\n\n# range() mit Start und Ende\nprint(\"\\nZ√§hlen von 1 bis 5:\")\nfor zahl in range(1, 6):  # Von 1 bis (aber NICHT inklusive) 6\n    print(zahl)\n\n# range() mit Schrittweite\nprint(\"\\nNur gerade Zahlen von 0 bis 10:\")\nfor zahl in range(0, 11, 2):  # Start bei 0, bis 11, in 2er-Schritten\n    print(zahl)  # 0, 2, 4, 6, 8, 10",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Listen durchlaufen",
            "goal": "For-Schleifen mit Listen kombinieren",
            "why": "Listen und Schleifen sind beste Freunde! Schleifen k√∂nnen jedes Element einer Liste durchgehen.",
            "code": "# Liste erstellen\nfr√ºchte = [\"Apfel\", \"Banane\", \"Orange\", \"Erdbeere\"]\n\n# Methode 1: Direkt √ºber die Elemente iterieren\nprint(\"Meine Lieblings-Fr√ºchte:\")\nfor frucht in fr√ºchte:  # 'frucht' nimmt nacheinander jeden Wert an\n    print(f\"- {frucht}\")\n\n# Methode 2: Mit Index (Position) arbeiten\nprint(\"\\nMit Nummern:\")\nfor i in range(len(fr√ºchte)):  # len(fr√ºchte) = 4, also range(4) = 0,1,2,3\n    print(f\"{i+1}. {fr√ºchte[i]}\")  # i+1 damit wir bei 1 starten\n    \n# Methode 3: Beides gleichzeitig (Index UND Element)\nprint(\"\\nMit enumerate():\")\nfor index, frucht in enumerate(fr√ºchte, start=1):  # enumerate gibt (Index, Wert) zur√ºck\n    print(f\"{index}. {frucht}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Multiplikationstabelle bauen",
            "goal": "Eine einfache Tabelle f√ºr eine Zahl erstellen",
            "why": "Jetzt wird's praktisch - wir nutzen Schleifen f√ºr echte Berechnungen!",
            "code": "print(\"üî¢ MULTIPLIKATIONSTABELLE\")\nprint(\"=\" * 40)\n\n# Benutzer w√§hlt eine Zahl\nbasis = int(input(\"F√ºr welche Zahl m√∂chtest du die Tabelle? \"))\n\nprint(f\"\\nMultiplikationstabelle f√ºr {basis}:\")\nprint(\"-\" * 30)\n\n# Schleife von 1 bis 10\nfor i in range(1, 11):  # 1, 2, 3, ..., 10\n    ergebnis = basis * i  # Berechnung\n    print(f\"{basis} √ó {i:2} = {ergebnis:3}\")  # :2 und :3 = rechtsb√ºndig ausrichten\n    \n# Erkl√§rung der Formatierung:\n# {i:2} bedeutet: Nutze mindestens 2 Stellen (rechtsb√ºndig)\n# So dass  1 als \" 1\" erscheint und alles sch√∂n untereinander steht",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Verschachtelte Schleifen",
            "goal": "Eine komplette Multiplikationstabelle (1√ó1 bis 10√ó10) erstellen",
            "why": "Schleifen IN Schleifen sind m√§chtig! Die √§u√üere Schleife l√§uft einmal durch, f√ºr JEDEN Durchlauf der √§u√üeren l√§uft die innere komplett durch.",
            "code": "print(\"üî¢ KOMPLETTE MULTIPLIKATIONSTABELLE (1-10)\")\nprint(\"=\" * 60)\n\n# √úberschrift erstellen\nprint(\"     \", end=\"\")  # Leerraum am Anfang, 'end=\"\"' verhindert Zeilenumbruch\nfor i in range(1, 11):\n    print(f\"{i:4}\", end=\"\")  # Zahlen 1-10 als Spalten-√úberschrift\nprint()  # Zeilenumbruch\nprint(\"-\" * 60)\n\n# √Ñu√üere Schleife: Zeilen (1 bis 10)\nfor zeile in range(1, 11):\n    # Zeilen-Nummer ausgeben\n    print(f\"{zeile:2} | \", end=\"\")  # z.B. \" 1 | \"\n    \n    # Innere Schleife: Spalten (1 bis 10)\n    for spalte in range(1, 11):\n        ergebnis = zeile * spalte  # Die eigentliche Multiplikation\n        print(f\"{ergebnis:4}\", end=\"\")  # Rechtsb√ºndig mit 4 Zeichen\n    \n    print()  # Zeilenumbruch nach jeder Zeile\n\n# Wie es funktioniert:\n# zeile=1: 1√ó1, 1√ó2, 1√ó3, ..., 1√ó10  (innere Schleife l√§uft 10√ó durch)\n# zeile=2: 2√ó1, 2√ó2, 2√ó3, ..., 2√ó10  (innere Schleife l√§uft 10√ó durch)\n# ...\n# zeile=10: 10√ó1, 10√ó2, ..., 10√ó10",
            "checkpoint": ""
          },
          {
            "number": 5,
            "title": "Interaktiver Generator",
            "goal": "Der Benutzer kann Start, Ende und Schrittweite w√§hlen",
            "why": "Jetzt kombinieren wir alles: Input, Bedingungen, Schleifen!",
            "code": "print(\"üéØ MULTIPLIKATIONSTABELLE GENERATOR\")\nprint(\"=\" * 50)\n\n# Benutzer-Einstellungen\nstart = int(input(\"Start-Zahl: \"))\nende = int(input(\"End-Zahl: \"))\nschritte = int(input(\"Schrittweite (z.B. 2 f√ºr gerade Zahlen): \"))\n\n# Validierung (Fehlerpr√ºfung)\nif start > ende:\n    print(\"‚ùå Start muss kleiner als Ende sein!\")\nelif schritte <= 0:\n    print(\"‚ùå Schrittweite muss positiv sein!\")\nelse:\n    print(f\"\\nüìä Tabelle von {start} bis {ende} in {schritte}er-Schritten:\")\n    print(\"=\" * 50)\n    \n    # F√ºr jede Basis-Zahl\n    for basis in range(start, ende + 1, schritte):  # +1 weil Ende inklusiv sein soll\n        print(f\"\\nTabelle f√ºr {basis}:\")\n        print(\"-\" * 30)\n        \n        # F√ºr jeden Multiplikator\n        for multi in range(1, 11):\n            ergebnis = basis * multi\n            print(f\"{basis} √ó {multi:2} = {ergebnis:4}\")\n        \n        # Kurze Pause zwischen Tabellen (optisch)\n        if basis != ende:  # Nicht nach der letzten Tabelle\n            print()\n\nprint(\"\\n‚úÖ Generator beendet!\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 6,
        "weekId": 1,
        "title": "Zahlenratespiel",
        "duration": "10-15 Min",
        "task": {
          "title": "Zahlenratespiel",
          "description": "Baue ein Spiel, bei dem der Computer eine Zufallszahl w√§hlt und der Spieler sie erraten muss - mit While-Schleife!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "While-Schleife verstehen",
            "goal": "Verstehen, wie while-Schleifen funktionieren (anders als for!)",
            "why": "For-Schleifen laufen eine FESTE Anzahl durch. While-Schleifen laufen, SOLANGE eine Bedingung wahr ist. Perfekt f√ºr \"bis der Benutzer richtig r√§t\"!",
            "code": "# WHILE = SOLANGE (eine Bedingung wahr ist)\n\n# Beispiel 1: Von 1 bis 5 z√§hlen\nzahl = 1  # Startwert\n\nwhile zahl <= 5:  # Solange zahl kleiner-gleich 5 ist\n    print(zahl)\n    zahl = zahl + 1  # WICHTIG: Wert erh√∂hen, sonst endlos!\n\n# Was passiert:\n# zahl=1: 1<=5? JA ‚Üí print(1), zahl wird 2\n# zahl=2: 2<=5? JA ‚Üí print(2), zahl wird 3\n# ...\n# zahl=6: 6<=5? NEIN ‚Üí Schleife stoppt\n\nprint(\"Schleife beendet!\")\n\n# Beispiel 2: Benutzer-Input in Schleife\nprint(\"\\n--- Passwort-Check ---\")\npasswort = \"\"  # Leerer String\n\nwhile passwort != \"geheim\":  # Solange Passwort NICHT \"geheim\" ist\n    passwort = input(\"Passwort eingeben: \")\n    \n    if passwort != \"geheim\":\n        print(\"‚ùå Falsch! Versuch's nochmal.\")\n\nprint(\"‚úÖ Richtig! Zugang gew√§hrt!\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "While mit Z√§hler",
            "goal": "Anzahl der Versuche mitz√§hlen",
            "why": "In Spielen wollen wir oft wissen \"Wie viele Versuche hat der Spieler gebraucht?\"",
            "code": "import random  # Modul f√ºr Zufallszahlen - kommt mit Python mit!\n\nprint(\"üé≤ ZUFALLSZAHL-DEMO\")\n\n# random.randint(a, b) gibt eine zuf√§llige Ganzzahl zwischen a und b zur√ºck\nzufallszahl = random.randint(1, 10)  # Zahl zwischen 1 und 10\n\nprint(f\"Ich habe eine Zahl zwischen 1 und 10 gew√§hlt.\")\nprint(\"Versuche sie zu erraten!\")\n\nversuch_nummer = 0  # Z√§hler starten bei 0\ngeraten = False  # Boolean (Wahrheitswert): False oder True\n\nwhile not geraten:  # Solange NICHT geraten (= False)\n    versuch_nummer = versuch_nummer + 1  # Z√§hler erh√∂hen (auch: versuch_nummer += 1)\n    \n    print(f\"\\nVersuch #{versuch_nummer}:\")\n    tipp = int(input(\"Deine Zahl: \"))\n    \n    if tipp == zufallszahl:\n        print(f\"üéâ RICHTIG! Die Zahl war {zufallszahl}!\")\n        print(f\"Du hast {versuch_nummer} Versuche gebraucht.\")\n        geraten = True  # Bedingung wird False ‚Üí Schleife stoppt\n    else:\n        print(\"‚ùå Falsch!\")\n\n# Alternative Schreibweise: while True mit break\n# while True:  # Endlos-Schleife\n#     ...\n#     if bedingung:\n#         break  # Bricht die Schleife ab",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Hinweise einbauen (hei√ü/kalt)",
            "goal": "Dem Spieler helfen durch \"zu hoch\" / \"zu niedrig\"",
            "why": "Das macht das Spiel interessanter und nutzt if-Bedingungen INNERHALB der Schleife!",
            "code": "import random\n\nprint(\"üéÆ ZAHLENRATESPIEL v2.0\")\nprint(\"=\" * 40)\n\n# Zufallszahl zwischen 1 und 100\ngeheimzahl = random.randint(1, 100)\n\nprint(\"Ich habe mir eine Zahl zwischen 1 und 100 ausgedacht.\")\nprint(\"Kannst du sie erraten?\\n\")\n\nversuche = 0\nmax_versuche = 7  # Limit f√ºr Spannung\n\nwhile versuche < max_versuche:\n    versuche += 1  # Kurzform f√ºr: versuche = versuche + 1\n    \n    verbleibend = max_versuche - versuche + 1\n    print(f\"--- Versuch {versuche}/{max_versuche} ---\")\n    \n    # Input mit Fehlerbehandlung (einfach)\n    eingabe = input(\"Dein Tipp: \")\n    \n    if not eingabe.isdigit():  # Pr√ºfe ob es eine Zahl ist\n        print(\"‚ùå Bitte eine Zahl eingeben!\")\n        versuche -= 1  # Dieser Versuch z√§hlt nicht\n        continue  # Springe zum n√§chsten Schleifendurchlauf\n    \n    tipp = int(eingabe)\n    \n    # Pr√ºfung\n    if tipp < 1 or tipp > 100:\n        print(\"‚ùå Zahl muss zwischen 1 und 100 sein!\")\n        versuche -= 1\n        \n    elif tipp == geheimzahl:\n        print(f\"\\nüéâüéâüéâ GEWONNEN! üéâüéâüéâ\")\n        print(f\"Die Zahl war {geheimzahl}!\")\n        print(f\"Du hast {versuche} Versuche gebraucht.\")\n        break  # Schleife sofort beenden\n        \n    elif tipp < geheimzahl:\n        unterschied = geheimzahl - tipp\n        \n        if unterschied > 20:\n            print(\"‚ùÑÔ∏è EISKALT! Viel zu niedrig!\")\n        elif unterschied > 10:\n            print(\"üßä Kalt! Zu niedrig.\")\n        else:\n            print(\"üî• Warm! Noch etwas h√∂her!\")\n            \n    else:  # tipp > geheimzahl\n        unterschied = tipp - geheimzahl\n        \n        if unterschied > 20:\n            print(\"üî• BR√úTEND HEI·∫û! Viel zu hoch!\")\n        elif unterschied > 10:\n            print(\"‚ô®Ô∏è Hei√ü! Zu hoch.\")\n        else:\n            print(\"‚ùÑÔ∏è K√ºhl! Etwas niedriger!\")\n    \n    # Wenn es der letzte Versuch war\n    if versuche == max_versuche and tipp != geheimzahl:\n        print(f\"\\nüòû VERLOREN! Die Zahl war {geheimzahl}.\")\n\nprint(\"\\n--- Spiel beendet ---\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Nochmal spielen?",
            "goal": "√Ñu√üere Schleife f√ºr mehrere Runden",
            "why": "While-Schleifen INNERHALB von While-Schleifen - f√ºr wiederholte Spiele!",
            "code": "import random\n\ndef spiele_runde():\n    \"\"\"Eine Spielrunde - als Funktion f√ºr bessere Struktur\"\"\"\n    geheimzahl = random.randint(1, 100)\n    versuche = 0\n    max_versuche = 7\n    \n    while versuche < max_versuche:\n        versuche += 1\n        \n        print(f\"\\n--- Versuch {versuche}/{max_versuche} ---\")\n        eingabe = input(\"Dein Tipp (1-100): \")\n        \n        if not eingabe.isdigit():\n            print(\"‚ùå Nur Zahlen!\")\n            versuche -= 1\n            continue\n        \n        tipp = int(eingabe)\n        \n        if tipp == geheimzahl:\n            print(f\"\\nüéâ RICHTIG! Zahl war {geheimzahl}! ({versuche} Versuche)\")\n            return True  # Gewonnen\n        elif tipp < geheimzahl:\n            print(\"‚¨ÜÔ∏è Zu niedrig!\")\n        else:\n            print(\"‚¨áÔ∏è Zu hoch!\")\n    \n    print(f\"\\nüòû Verloren! Zahl war {geheimzahl}.\")\n    return False  # Verloren\n\n# HAUPTPROGRAMM mit √§u√üerer Schleife\nprint(\"üéÆ ZAHLENRATESPIEL v3.0\")\nprint(\"=\" * 40)\n\nweiter_spielen = True\nrunden = 0\ngewonnen_gesamt = 0\n\nwhile weiter_spielen:\n    runden += 1\n    print(f\"\\n{'='*40}\")\n    print(f\"RUNDE {runden}\")\n    print(f\"{'='*40}\")\n    \n    # Spiele eine Runde\n    gewonnen = spiele_runde()\n    \n    if gewonnen:\n        gewonnen_gesamt += 1\n    \n    # Statistik\n    print(f\"\\nDeine Statistik: {gewonnen_gesamt}/{runden} gewonnen\")\n    \n    # Nochmal?\n    antwort = input(\"\\nNochmal spielen? (j/n): \").lower()\n    \n    if antwort != \"j\" and antwort != \"ja\":\n        weiter_spielen = False  # √Ñu√üere Schleife beenden\n\nprint(\"\\nüëã Danke f√ºrs Spielen!\")\nprint(f\"Endergebnis: {gewonnen_gesamt}/{runden} Runden gewonnen!\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 7,
        "weekId": 1,
        "title": "BMI-Rechner mit Funktionen",
        "duration": "10-15 Min",
        "task": {
          "title": "BMI-Rechner mit Funktionen",
          "description": "Erstelle einen BMI-Rechner (Body Mass Index) mit wiederverwendbaren Funktionen.",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Funktionen definieren",
            "goal": "Verstehen, was Funktionen sind und warum wir sie brauchen",
            "why": "Stell dir vor, du musst die gleiche Berechnung 10√ó machen. W√ºrdest du den Code 10√ó kopieren? NEIN! Funktionen sind wie Rezepte - einmal schreiben, beliebig oft verwenden!",
            "code": "# Funktion DEFINIEREN mit 'def' (define = definieren)\n# Eine Funktion ist ein wiederverwendbarer Code-Block\n\ndef begruessung():  # Funktionsname mit ()\n    \"\"\"Das ist ein Docstring - erkl√§rt was die Funktion macht\"\"\"\n    print(\"Hallo!\")\n    print(\"Willkommen zum BMI-Rechner!\")\n\n# Funktion AUFRUFEN (sonst passiert nichts!)\nbegruessung()  # F√ºhrt den Code in der Funktion aus\n\nprint(\"\\n--- Nochmal ---\\n\")\n\nbegruessung()  # Kann beliebig oft aufgerufen werden!\n\n# Funktion mit PARAMETER (Eingabe-Werte)\ndef begruessung_mit_name(name):  # 'name' ist ein Parameter\n    \"\"\"Begr√º√üt eine Person mit ihrem Namen\"\"\"\n    print(f\"Hallo {name}!\")\n    print(\"Willkommen zum BMI-Rechner!\")\n\n# Beim Aufrufen m√ºssen wir den Parameter √ºbergeben\nbegruessung_mit_name(\"Anna\")  # name = \"Anna\"\nbegruessung_mit_name(\"Max\")   # name = \"Max\"",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Funktionen mit Return",
            "goal": "Werte aus Funktionen zur√ºckgeben",
            "why": "Manchmal wollen wir nicht nur etwas AUSGEBEN (print), sondern ein ERGEBNIS zur√ºckbekommen, um damit weiterzuarbeiten!",
            "code": "# Funktion die etwas BERECHNET und zur√ºckgibt\n\ndef addiere(a, b):  # Zwei Parameter\n    \"\"\"Addiert zwei Zahlen und gibt das Ergebnis zur√ºck\"\"\"\n    summe = a + b\n    return summe  # RETURN schickt den Wert zur√ºck an den Aufrufer\n    # Code nach 'return' wird NICHT mehr ausgef√ºhrt!\n\n# Das Ergebnis k√∂nnen wir speichern\nergebnis = addiere(5, 3)\nprint(f\"5 + 3 = {ergebnis}\")\n\n# Oder direkt verwenden\nprint(f\"10 + 20 = {addiere(10, 20)}\")\n\n# BMI-Berechnung als Funktion\ndef berechne_bmi(gewicht_kg, groesse_m):\n    \"\"\"\n    Berechnet den BMI (Body Mass Index)\n    \n    Formel: BMI = Gewicht / (Gr√∂√üe¬≤)\n    \n    Parameter:\n        gewicht_kg: Gewicht in Kilogramm\n        groesse_m: Gr√∂√üe in Metern\n    \n    R√ºckgabe:\n        BMI als Float (Kommazahl)\n    \"\"\"\n    bmi = gewicht_kg / (groesse_m ** 2)  # ** 2 bedeutet \"hoch 2\" (Quadrat)\n    return bmi\n\n# Testen\nmein_bmi = berechne_bmi(70, 1.75)\nprint(f\"\\nBMI bei 70kg und 1.75m: {mein_bmi:.2f}\")\n\n# Mehrere Werte auf einmal zur√ºckgeben (als Tupel)\ndef berechne_statistiken(gewicht, groesse):\n    \"\"\"Berechnet BMI und kategorisiert\"\"\"\n    bmi = gewicht / (groesse ** 2)\n    \n    if bmi < 18.5:\n        kategorie = \"Untergewicht\"\n    elif bmi < 25:\n        kategorie = \"Normalgewicht\"\n    elif bmi < 30:\n        kategorie = \"√úbergewicht\"\n    else:\n        kategorie = \"Adipositas\"\n    \n    return bmi, kategorie  # Gibt ZWEI Werte zur√ºck!\n\n# Empfangen von mehreren Werten\nbmi_wert, kate = berechne_statistiken(70, 1.75)\nprint(f\"BMI: {bmi_wert:.2f}, Kategorie: {kate}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Vollst√§ndiger BMI-Rechner",
            "goal": "Mehrere Funktionen zu einem Programm kombinieren",
            "why": "Echte Programme bestehen aus VIELEN kleinen Funktionen, die zusammenarbeiten. Jede Funktion hat EINE klare Aufgabe.",
            "code": "def hole_positive_zahl(prompt):\n    \"\"\"\n    Fragt nach einer positiven Zahl und validiert die Eingabe\n    \n    Parameter:\n        prompt: Der Text, der dem Benutzer angezeigt wird\n        \n    R√ºckgabe:\n        Eine positive Zahl (float)\n    \"\"\"\n    while True:  # Endlosschleife bis g√ºltige Eingabe\n        eingabe = input(prompt)\n        \n        # Pr√ºfe ob es eine Zahl ist\n        try:  # Versuche\n            zahl = float(eingabe)\n            \n            if zahl <= 0:\n                print(\"‚ùå Bitte eine positive Zahl eingeben!\")\n            else:\n                return zahl  # G√ºltige Zahl ‚Üí zur√ºckgeben und Funktion beenden\n                \n        except ValueError:  # Wenn float() fehlschl√§gt\n            print(\"‚ùå Bitte eine g√ºltige Zahl eingeben!\")\n\ndef berechne_bmi(gewicht, groesse):\n    \"\"\"Berechnet BMI\"\"\"\n    return gewicht / (groesse ** 2)\n\ndef bestimme_kategorie(bmi):\n    \"\"\"Bestimmt die BMI-Kategorie nach WHO-Standard\"\"\"\n    if bmi < 16:\n        return \"Starkes Untergewicht\", \"üö®\"\n    elif bmi < 18.5:\n        return \"Untergewicht\", \"‚ö†Ô∏è\"\n    elif bmi < 25:\n        return \"Normalgewicht\", \"‚úÖ\"\n    elif bmi < 30:\n        return \"√úbergewicht\", \"‚ö†Ô∏è\"\n    elif bmi < 35:\n        return \"Adipositas Grad I\", \"üö®\"\n    elif bmi < 40:\n        return \"Adipositas Grad II\", \"üö®\"\n    else:\n        return \"Adipositas Grad III\", \"üö®\"\n\ndef zeige_bmi_tabelle():\n    \"\"\"Zeigt eine √úbersicht der BMI-Kategorien\"\"\"\n    print(\"\\nüìä BMI-Kategorien (WHO):\")\n    print(\"-\" * 40)\n    print(\"< 16.0    Starkes Untergewicht\")\n    print(\"16.0-18.4 Untergewicht\")\n    print(\"18.5-24.9 Normalgewicht ‚úÖ\")\n    print(\"25.0-29.9 √úbergewicht\")\n    print(\"30.0-34.9 Adipositas Grad I\")\n    print(\"35.0-39.9 Adipositas Grad II\")\n    print(\"‚â• 40.0    Adipositas Grad III\")\n    print(\"-\" * 40)\n\n# HAUPTPROGRAMM\ndef main():\n    \"\"\"Hauptfunktion - startet das Programm\"\"\"\n    print(\"=\" * 50)\n    print(\"üí™ BMI-RECHNER (Body Mass Index)\")\n    print(\"=\" * 50)\n    \n    # Tabelle zeigen\n    zeige_bmi_tabelle()\n    \n    # Daten abfragen\n    print(\"\\nüìù Bitte gib deine Daten ein:\")\n    gewicht = hole_positive_zahl(\"Gewicht in kg: \")\n    groesse = hole_positive_zahl(\"Gr√∂√üe in Metern (z.B. 1.75): \")\n    \n    # Berechnung\n    bmi = berechne_bmi(gewicht, groesse)\n    kategorie, emoji = bestimme_kategorie(bmi)\n    \n    # Ausgabe\n    print(\"\\n\" + \"=\" * 50)\n    print(\"üìä DEIN ERGEBNIS\")\n    print(\"=\" * 50)\n    print(f\"Gewicht: {gewicht} kg\")\n    print(f\"Gr√∂√üe: {groesse} m\")\n    print(f\"\\nBMI: {bmi:.2f}\")\n    print(f\"Kategorie: {kategorie} {emoji}\")\n    print(\"=\" * 50)\n    \n    # Tipps\n    if bmi < 18.5:\n        print(\"\\nüí° Tipp: Achte auf ausreichende Kalorienzufuhr!\")\n    elif bmi >= 25:\n        print(\"\\nüí° Tipp: Mehr Bewegung und gesunde Ern√§hrung helfen!\")\n    else:\n        print(\"\\nüí° Weiter so! Dein BMI ist im gesunden Bereich.\")\n\n# Programm starten\nif __name__ == \"__main__\":  # Dieser Check ist Python-Konvention\n    main()  # Rufe die Hauptfunktion auf",
            "checkpoint": ""
          }
        ]
      }
    ]
  },
  {
    "id": 2,
    "title": "Woche 2: Datenstrukturen",
    "subtitle": "Datenstrukturen",
    "description": "Listen, Dictionaries & Dateien",
    "color": "purple",
    "days": [
      {
        "id": 1,
        "weekId": 2,
        "title": "Kontaktverwaltung mit Dictionaries",
        "duration": "10-15 Min",
        "task": {
          "title": "Kontaktverwaltung mit Dictionaries",
          "description": "Erstelle ein Programm zur Verwaltung von Kontakten mit Namen, Telefonnummern und E-Mails - mit Dictionaries!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Dictionary-Grundlagen",
            "goal": "Verstehen, was Dictionaries sind und wie sie sich von Listen unterscheiden",
            "why": "Listen speichern Werte mit Zahlen (Index 0, 1, 2...). Dictionaries speichern Werte mit NAMEN (Keys). Perfekt f√ºr strukturierte Daten wie Kontakte!",
            "code": "# LISTE: Zugriff √ºber Index (Zahl)\nfarben = [\"rot\", \"gr√ºn\", \"blau\"]\nprint(farben[0])  # \"rot\"\n\n# DICTIONARY: Zugriff √ºber Key (Name)\n# Syntax: {key: value, key: value, ...}\nperson = {\n    \"name\": \"Anna Schmidt\",\n    \"alter\": 28,\n    \"stadt\": \"Berlin\",\n    \"beruf\": \"Entwicklerin\"\n}\n\n# Zugriff √ºber Key\nprint(person[\"name\"])  # \"Anna Schmidt\"\nprint(person[\"alter\"])  # 28\n\n# Keys m√ºssen eindeutig sein, Values k√∂nnen doppelt vorkommen\n# Keys sind meist Strings, k√∂nnen aber auch Zahlen oder Tupel sein\n\n# Neuen Key hinzuf√ºgen\nperson[\"email\"] = \"anna@example.com\"\nprint(person)\n\n# Wert √§ndern\nperson[\"alter\"] = 29\nprint(f\"Anna ist jetzt {person['alter']}\")\n\n# Pr√ºfen ob Key existiert\nif \"telefon\" in person:\n    print(person[\"telefon\"])\nelse:\n    print(\"Telefonnummer nicht vorhanden\")\n\n# Alle Keys, Values, oder beides anzeigen\nprint(\"\\nAlle Keys:\", person.keys())\nprint(\"Alle Values:\", person.values())\nprint(\"Alle Paare:\", person.items())",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Dictionary-Methoden",
            "goal": "Mit Dictionary-Methoden arbeiten (get, pop, update...)",
            "why": "Dictionaries haben eingebaute Funktionen, die das Arbeiten einfacher und sicherer machen!",
            "code": "kontakt = {\n    \"name\": \"Max M√ºller\",\n    \"tel\": \"0123-456789\",\n    \"email\": \"max@example.com\"\n}\n\n# .get(key, default) - Sicherer Zugriff (kein Fehler wenn Key fehlt)\n# Statt: kontakt[\"adresse\"] ‚Üí Fehler!\n# Besser:\nadresse = kontakt.get(\"adresse\", \"Nicht angegeben\")\nprint(f\"Adresse: {adresse}\")  # \"Nicht angegeben\"\n\n# .pop(key) - Entfernt einen Key und gibt den Wert zur√ºck\nemail = kontakt.pop(\"email\")\nprint(f\"Entfernte Email: {email}\")\nprint(f\"Kontakt jetzt: {kontakt}\")  # email ist weg\n\n# .update() - Mehrere Keys auf einmal hinzuf√ºgen/√§ndern\nkontakt.update({\n    \"email\": \"max.mueller@example.com\",  # Wieder hinzuf√ºgen (besser)\n    \"firma\": \"TechCorp\",\n    \"position\": \"Manager\"\n})\nprint(f\"\\nAktualisiert: {kontakt}\")\n\n# .setdefault(key, default) - F√ºgt Key nur hinzu wenn nicht vorhanden\nkontakt.setdefault(\"stadt\", \"M√ºnchen\")  # Wird hinzugef√ºgt\nkontakt.setdefault(\"name\", \"Anderer Name\")  # Wird NICHT √ºberschrieben!\nprint(f\"\\nMit setdefault: {kontakt}\")\n\n# .clear() - Alle Eintr√§ge l√∂schen\n# kontakt.clear()  # Macht Dictionary leer!\n\n# .copy() - Kopie erstellen\nbackup = kontakt.copy()\nbackup[\"name\"] = \"BACKUP\"\nprint(f\"\\nOriginal: {kontakt['name']}\")  # \"Max M√ºller\" - unver√§ndert!\nprint(f\"Kopie: {backup['name']}\")  # \"BACKUP\"",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Liste von Dictionaries (Kontaktliste)",
            "goal": "Mehrere Kontakte in einer Liste speichern",
            "why": "Real-World-Anwendung! Eine Liste von Dictionaries ist wie eine einfache Datenbank.",
            "code": "# Liste von Dictionaries - jedes Dict ist ein Kontakt\nkontakte = [\n    {\n        \"name\": \"Anna Schmidt\",\n        \"tel\": \"0123-111111\",\n        \"email\": \"anna@test.de\",\n        \"kategorie\": \"Freunde\"\n    },\n    {\n        \"name\": \"Ben M√ºller\",\n        \"tel\": \"0123-222222\",\n        \"email\": \"ben@test.de\",\n        \"kategorie\": \"Familie\"\n    },\n    {\n        \"name\": \"Clara Neubert\",\n        \"tel\": \"0123-333333\",\n        \"email\": \"clara@test.de\",\n        \"kategorie\": \"Arbeit\"\n    }\n]\n\n# Alle Kontakte durchgehen\nprint(\"üìá ALLE KONTAKTE:\")\nprint(\"=\" * 50)\n\nfor kontakt in kontakte:  # Jedes Element ist ein Dictionary\n    print(f\"\\nüë§ {kontakt['name']}\")\n    print(f\"   üìû {kontakt['tel']}\")\n    print(f\"   üìß {kontakt['email']}\")\n    print(f\"   üè∑Ô∏è  {kontakt['kategorie']}\")\n\n# Spezifischen Kontakt suchen\nsuchname = \"Ben M√ºller\"\ngefunden = False\n\nfor kontakt in kontakte:\n    if kontakt[\"name\"] == suchname:\n        print(f\"\\n‚úÖ Kontakt gefunden:\")\n        print(f\"   Telefon: {kontakt['tel']}\")\n        gefunden = True\n        break  # Stoppt die Schleife, wenn gefunden\n\nif not gefunden:\n    print(f\"‚ùå {suchname} nicht gefunden\")\n\n# Filtern nach Kategorie\nprint(\"\\n\\nüè∑Ô∏è  ARBEITSKONTAKTE:\")\nfor kontakt in kontakte:\n    if kontakt[\"kategorie\"] == \"Arbeit\":\n        print(f\"- {kontakt['name']}\")\n\n# Statistiken\nanzahl_gesamt = len(kontakte)\nkategorien = {}  # Dict f√ºr Z√§hlung\n\nfor kontakt in kontakte:\n    kat = kontakt[\"kategorie\"]\n    if kat in kategorien:\n        kategorien[kat] += 1\n    else:\n        kategorien[kat] = 1\n\nprint(f\"\\nüìä Statistik: {anzahl_gesamt} Kontakte gesamt\")\nfor kat, anzahl in kategorien.items():\n    print(f\"   {kat}: {anzahl}\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Interaktive Kontaktverwaltung",
            "goal": "Vollst√§ndige App zum Hinzuf√ºgen, Anzeigen, Suchen und L√∂schen von Kontakten",
            "why": "Hier kombinieren wir ALLES bisher Gelernte!",
            "code": "def zeige_kontakte(kontakte):\n    \"\"\"Zeigt alle Kontakte √ºbersichtlich an\"\"\"\n    if len(kontakte) == 0:\n        print(\"\\nüì≠ Keine Kontakte vorhanden\")\n        return\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"üìá ALLE KONTAKTE\")\n    print(\"=\" * 60)\n    \n    for i, kontakt in enumerate(kontakte, start=1):\n        print(f\"\\n{i}. {kontakt['name']}\")\n        print(f\"   üìû {kontakt.get('tel', 'Keine Nummer')}\")\n        print(f\"   üìß {kontakt.get('email', 'Keine Email')}\")\n        print(f\"   üè∑Ô∏è  {kontakt.get('kategorie', 'Keine Kategorie')}\")\n\ndef neuer_kontakt():\n    \"\"\"Erstellt einen neuen Kontakt durch Benutzereingabe\"\"\"\n    print(\"\\n‚ûï NEUER KONTAKT\")\n    print(\"-\" * 30)\n    \n    name = input(\"Name: \").strip()\n    if not name:\n        print(\"‚ùå Name darf nicht leer sein!\")\n        return None\n    \n    tel = input(\"Telefon: \").strip()\n    email = input(\"Email: \").strip()\n    kategorie = input(\"Kategorie (Freunde/Familie/Arbeit): \").strip()\n    \n    # Dictionary erstellen und zur√ºckgeben\n    return {\n        \"name\": name,\n        \"tel\": tel,\n        \"email\": email,\n        \"kategorie\": kategorie or \"Sonstige\"\n    }\n\ndef suche_kontakt(kontakte, suchbegriff):\n    \"\"\"Sucht nach Name oder Telefonnummer\"\"\"\n    gefundene = []\n    suchbegriff = suchbegriff.lower()\n    \n    for kontakt in kontakte:\n        # Suche in Name oder Telefon (case-insensitive)\n        if (suchbegriff in kontakt[\"name\"].lower() or\n            suchbegriff in kontakt.get(\"tel\", \"\")):\n            gefundene.append(kontakt)\n    \n    return gefundene\n\ndef loesche_kontakt(kontakte, index):\n    \"\"\"L√∂scht einen Kontakt an Position index\"\"\"\n    if 0 <= index < len(kontakte):\n        geloeschter = kontakte.pop(index)\n        print(f\"\\n‚úÖ '{geloeschter['name']}' wurde gel√∂scht\")\n        return True\n    else:\n        print(\"\\n‚ùå Ung√ºltige Nummer!\")\n        return False\n\n# HAUPTPROGRAMM\ndef main():\n    # Startwerte\n    kontakte = [\n        {\"name\": \"Demo User\", \"tel\": \"0000-000000\", \"email\": \"demo@test.de\", \"kategorie\": \"Test\"}\n    ]\n    \n    while True:\n        print(\"\\n\" + \"=\" * 60)\n        print(\"üì± KONTAKTVERWALTUNG\")\n        print(\"=\" * 60)\n        print(\"1. Alle Kontakte anzeigen\")\n        print(\"2. Neuen Kontakt hinzuf√ºgen\")\n        print(\"3. Kontakt suchen\")\n        print(\"4. Kontakt l√∂schen\")\n        print(\"5. Beenden\")\n        \n        wahl = input(\"\\nW√§hle eine Option (1-5): \").strip()\n        \n        if wahl == \"1\":\n            zeige_kontakte(kontakte)\n            \n        elif wahl == \"2\":\n            neuer = neuer_kontakt()\n            if neuer:\n                kontakte.append(neuer)\n                print(f\"‚úÖ '{neuer['name']}' wurde hinzugef√ºgt!\")\n                \n        elif wahl == \"3\":\n            begriff = input(\"\\nSuchbegriff (Name oder Telefon): \").strip()\n            if begriff:\n                ergebnisse = suche_kontakt(kontakte, begriff)\n                if ergebnisse:\n                    print(f\"\\nüîç {len(ergebnisse)} Ergebnis(se) gefunden:\")\n                    for k in ergebnisse:\n                        print(f\"\\nüë§ {k['name']}\")\n                        print(f\"   üìû {k.get('tel', 'N/A')}\")\n                        print(f\"   üìß {k.get('email', 'N/A')}\")\n                else:\n                    print(\"\\n‚ùå Keine Kontakte gefunden\")\n                    \n        elif wahl == \"4\":\n            zeige_kontakte(kontakte)\n            if len(kontakte) > 0:\n                try:\n                    nummer = int(input(\"\\nKontakt-Nummer zum L√∂schen: \"))\n                    loesche_kontakt(kontakte, nummer - 1)\n                except ValueError:\n                    print(\"‚ùå Bitte eine g√ºltige Nummer eingeben!\")\n                    \n        elif wahl == \"5\":\n            print(\"\\nüëã Auf Wiedersehen!\")\n            break\n            \n        else:\n            print(\"\\n‚ùå Ung√ºltige Wahl! Bitte 1-5 w√§hlen.\")\n\nif __name__ == \"__main__\":\n    main()",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 2,
        "weekId": 2,
        "title": "Lotto-Zahlen Generator (Tupel & Sets)",
        "duration": "10-15 Min",
        "task": {
          "title": "Lotto-Zahlen Generator (Tupel & Sets)",
          "description": "Erstelle einen Lotto-Zahlen Generator und lerne dabei Tupel und Sets kennen!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Tupel verstehen",
            "goal": "Verstehen was Tupel sind und wann man sie nutzt",
            "why": "Tupel sind wie Listen, aber UNVER√ÑNDERLICH. Perfekt f√ºr Daten, die nicht ge√§ndert werden sollen (z.B. Koordinaten, Datum, Farben).",
            "code": "# LISTE: Ver√§nderbar (mutable)\nliste = [1, 2, 3]\nliste[0] = 99  # Funktioniert\nprint(liste)  # [99, 2, 3]\n\n# TUPEL: Unver√§nderlich (immutable)\n# Erstellt mit runden Klammern ()\ntupel = (1, 2, 3)\n# tupel[0] = 99  # FEHLER! Tupel kann nicht ge√§ndert werden\n\nprint(tupel)  # (1, 2, 3)\n\n# Warum Tupel?\n# 1. Sicherheit: Daten k√∂nnen nicht versehentlich ge√§ndert werden\n# 2. Performance: Tupel sind schneller als Listen\n# 3. Als Dict-Keys: Tupel k√∂nnen Keys sein, Listen nicht\n\n# Tupel erstellen\nkoordinaten = (52.52, 13.40)  # Latitude, Longitude\nrgb_farbe = (255, 128, 0)     # Rot, Gr√ºn, Blau\ndatum = (2024, 2, 12)         # Jahr, Monat, Tag\n\n# Tupel unpacking - super praktisch!\nlat, lon = koordinaten\nprint(f\"Breitengrad: {lat}, L√§ngengrad: {lon}\")\n\njahr, monat, tag = datum\nprint(f\"Datum: {tag}.{monat}.{jahr}\")\n\n# Tupel mit einem Element (braucht Komma!)\neinzeln = (42,)  # Mit Komma = Tupel\n# nicht_tupel = (42)  # Ohne Komma = nur die Zahl in Klammern\n\n# Tupel-Methoden (nur 2!)\nzahlen = (1, 2, 3, 2, 2, 4)\nprint(f\"Die 2 kommt {zahlen.count(2)}√ó vor\")  # count() z√§hlt\nprint(f\"Die 3 ist an Position {zahlen.index(3)}\")  # index() findet Position\n\n# Tupel in Funktionen (h√§ufig f√ºr mehrere R√ºckgabewerte)\ndef min_max(zahlen_liste):\n    \"\"\"Gibt kleinste und gr√∂√üte Zahl als Tupel zur√ºck\"\"\"\n    return (min(zahlen_liste), max(zahlen_liste))\n\nminimum, maximum = min_max([5, 2, 9, 1, 7])\nprint(f\"Min: {minimum}, Max: {maximum}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Sets verstehen",
            "goal": "Sets kennenlernen - ungeordnete Sammlungen EINZIGARTIGER Werte",
            "why": "Sets sind perfekt wenn du:",
            "code": "# SET: Ungeordnete Sammlung von EINZIGARTIGEN Werten\n# Erstellt mit geschweiften Klammern {} (wie Dict, aber ohne Keys)\n\n# Liste mit Duplikaten\nliste = [1, 2, 2, 3, 3, 3, 4, 5, 5]\nprint(f\"Liste: {liste}\")\n\n# In Set umwandeln ‚Üí Duplikate verschwinden!\nunique_set = set(liste)\nprint(f\"Set: {unique_set}\")  # {1, 2, 3, 4, 5}\n\n# Zur√ºck in Liste\nunique_liste = list(unique_set)\nprint(f\"Eindeutige Liste: {unique_liste}\")\n\n# Set direkt erstellen\nfarben = {\"rot\", \"gr√ºn\", \"blau\", \"rot\"}  # \"rot\" doppelt wird ignoriert\nprint(f\"Farben: {farben}\")  # Nur einmal \"rot\"\n\n# Leeres Set (ACHTUNG: {} ist ein leeres Dict!)\nleeres_set = set()  # Richtig\n# nicht_set = {}  # Das ist ein Dict!\n\n# Set-Operationen\nset1 = {1, 2, 3, 4, 5}\nset2 = {4, 5, 6, 7, 8}\n\n# Vereinigung (union): Alle Elemente aus beiden Sets\nvereinigung = set1 | set2  # oder: set1.union(set2)\nprint(f\"Vereinigung: {vereinigung}\")  # {1,2,3,4,5,6,7,8}\n\n# Schnittmenge (intersection): Nur gemeinsame Elemente\nschnittmenge = set1 & set2  # oder: set1.intersection(set2)\nprint(f\"Schnittmenge: {schnittmenge}\")  # {4, 5}\n\n# Differenz: In set1 aber nicht in set2\ndifferenz = set1 - set2  # oder: set1.difference(set2)\nprint(f\"Differenz: {differenz}\")  # {1, 2, 3}\n\n# Symmetrische Differenz: In einem der Sets, aber nicht in beiden\nsym_diff = set1 ^ set2  # oder: set1.symmetric_difference(set2)\nprint(f\"Sym. Differenz: {sym_diff}\")  # {1,2,3,6,7,8}\n\n# Set-Methoden\nfarben = {\"rot\", \"gr√ºn\", \"blau\"}\n\nfarben.add(\"gelb\")  # Einzelnes Element hinzuf√ºgen\nprint(farben)\n\nfarben.remove(\"rot\")  # Element entfernen (Fehler wenn nicht vorhanden)\nprint(farben)\n\nfarben.discard(\"pink\")  # Entfernen (KEIN Fehler wenn nicht vorhanden)\n\n# Membership-Test (sehr schnell!)\nif \"gr√ºn\" in farben:\n    print(\"Gr√ºn ist dabei!\")\n\n# Sets sind ungeordnet! Keine Indexierung m√∂glich\n# farben[0]  # FEHLER! Sets haben keine Indizes",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Lotto-Zahlen Generator (Sets in Aktion)",
            "goal": "Einen echten Lotto-Generator bauen",
            "why": "Lotto = eindeutige Zufallszahlen ‚Üí perfekt f√ºr Sets!",
            "code": "import random\n\ndef generiere_lotto_zahlen(anzahl=6, minimum=1, maximum=49):\n    \"\"\"\n    Generiert eindeutige Lotto-Zahlen\n    \n    Parameter:\n        anzahl: Wie viele Zahlen (Standard: 6)\n        minimum: Kleinste Zahl (Standard: 1)\n        maximum: Gr√∂√üte Zahl (Standard: 49)\n    \n    R√ºckgabe:\n        Sortierte Liste von eindeutigen Zahlen\n    \"\"\"\n    # Methode 1: Mit Set\n    zahlen = set()\n    \n    while len(zahlen) < anzahl:\n        neue_zahl = random.randint(minimum, maximum)\n        zahlen.add(neue_zahl)  # Set verhindert automatisch Duplikate\n    \n    # In sortierte Liste umwandeln\n    return sorted(list(zahlen))\n\n# Methode 2: Mit random.sample (einfacher!)\ndef generiere_lotto_zahlen_v2(anzahl=6, minimum=1, maximum=49):\n    \"\"\"Elegantere Variante mit random.sample\"\"\"\n    pool = range(minimum, maximum + 1)  # Alle m√∂glichen Zahlen\n    zahlen = random.sample(pool, anzahl)  # W√§hlt anzahl Zahlen ohne Duplikate\n    return sorted(zahlen)\n\n# Testen\nprint(\"üé∞ LOTTO-GENERATOR\")\nprint(\"=\" * 50)\n\nfor i in range(3):\n    zahlen = generiere_lotto_zahlen_v2()\n    print(f\"Ziehung {i+1}: {zahlen}\")\n\n# Verschiedene Lotto-Varianten\nprint(\"\\nüìä Internationale Lotto-Varianten:\")\nprint(f\"6 aus 49 (Deutschland): {generiere_lotto_zahlen_v2(6, 1, 49)}\")\nprint(f\"5 aus 50 (EuroJackpot): {generiere_lotto_zahlen_v2(5, 1, 50)}\")\nprint(f\"6 aus 45 (√ñsterreich): {generiere_lotto_zahlen_v2(6, 1, 45)}\")\n\n# Statistik √ºber viele Ziehungen\nprint(\"\\nüìà STATISTIK (1000 Ziehungen)\")\nhaeufigkeit = {}  # Dict zum Z√§hlen\n\nfor _ in range(1000):\n    zahlen = generiere_lotto_zahlen_v2()\n    for zahl in zahlen:\n        haeufigkeit[zahl] = haeufigkeit.get(zahl, 0) + 1\n\n# Top 10 h√§ufigste Zahlen\nsortiert = sorted(haeufigkeit.items(), key=lambda x: x[1], reverse=True)\nprint(\"Top 10 h√§ufigste Zahlen:\")\nfor i, (zahl, anzahl) in enumerate(sortiert[:10], 1):\n    print(f\"{i}. Zahl {zahl}: {anzahl}√ó gezogen\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Interaktiver Lotto-Simulator",
            "goal": "Vollst√§ndiger Lotto-Simulator mit Tipp-Abgabe und Gewinnpr√ºfung",
            "why": "Kombiniert Sets, Tupel und alles Gelernte!",
            "code": "import random\n\ndef hole_benutzer_tipp(anzahl=6, minimum=1, maximum=49):\n    \"\"\"L√§sst Benutzer Lotto-Zahlen eingeben\"\"\"\n    print(f\"\\nüìù Gib {anzahl} Zahlen zwischen {minimum} und {maximum} ein:\")\n    \n    tipp = set()  # Set verhindert Duplikate\n    \n    while len(tipp) < anzahl:\n        verbleibend = anzahl - len(tipp)\n        try:\n            eingabe = input(f\"Zahl {len(tipp)+1}/{anzahl}: \")\n            zahl = int(eingabe)\n            \n            if zahl < minimum or zahl > maximum:\n                print(f\"‚ùå Zahl muss zwischen {minimum} und {maximum} sein!\")\n            elif zahl in tipp:\n                print(f\"‚ùå {zahl} hast du schon gew√§hlt!\")\n            else:\n                tipp.add(zahl)\n                print(f\"‚úÖ {zahl} gespeichert\")\n                \n        except ValueError:\n            print(\"‚ùå Bitte eine g√ºltige Zahl eingeben!\")\n    \n    return tipp\n\ndef pruefe_gewinn(tipp, ziehung):\n    \"\"\"\n    Pr√ºft wie viele Richtige der Spieler hat\n    \n    Returns:\n        Tupel (anzahl_richtige, richtige_zahlen)\n    \"\"\"\n    # Schnittmenge = gemeinsame Zahlen\n    richtige = tipp & ziehung  # oder: tipp.intersection(ziehung)\n    return (len(richtige), richtige)\n\ndef bestimme_gewinnklasse(anzahl_richtige, total=6):\n    \"\"\"Bestimmt Gewinnklasse basierend auf Richtigen\"\"\"\n    gewinnklassen = {\n        6: (\"üéâ JACKPOT! 6 Richtige!\", \"üí∞üí∞üí∞üí∞üí∞\"),\n        5: (\"üéä 5 Richtige!\", \"üí∞üí∞üí∞üí∞\"),\n        4: (\"üéÅ 4 Richtige!\", \"üí∞üí∞üí∞\"),\n        3: (\"‚ú® 3 Richtige!\", \"üí∞üí∞\"),\n        2: (\"üëç 2 Richtige!\", \"üí∞\"),\n        1: (\"üòï 1 Richtige\", \"\"),\n        0: (\"üòû 0 Richtige\", \"\")\n    }\n    return gewinnklassen.get(anzahl_richtige, (\"\", \"\"))\n\n# HAUPTPROGRAMM\ndef main():\n    print(\"=\" * 60)\n    print(\"üé∞ LOTTO-SIMULATOR 6 aus 49\")\n    print(\"=\" * 60)\n    \n    # Spielmodus w√§hlen\n    print(\"\\nW√§hle Modus:\")\n    print(\"1. Ich gebe meine Zahlen ein\")\n    print(\"2. Zufallstipp generieren\")\n    \n    wahl = input(\"\\nModus (1/2): \").strip()\n    \n    if wahl == \"1\":\n        mein_tipp = hole_benutzer_tipp()\n    else:\n        mein_tipp = set(random.sample(range(1, 50), 6))\n        print(f\"\\nüé≤ Dein Zufallstipp: {sorted(mein_tipp)}\")\n    \n    input(\"\\n‚è≥ Dr√ºcke Enter f√ºr die Ziehung...\")\n    \n    # Ziehung durchf√ºhren\n    ziehung = set(random.sample(range(1, 50), 6))\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"üé± ZIEHUNG\")\n    print(\"=\" * 60)\n    print(f\"Gezogene Zahlen: {sorted(ziehung)}\")\n    print(f\"Dein Tipp:       {sorted(mein_tipp)}\")\n    \n    # Gewinn pr√ºfen\n    anzahl, richtige = pruefe_gewinn(mein_tipp, ziehung)\n    titel, emoji = bestimme_gewinnklasse(anzahl)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"üìä ERGEBNIS\")\n    print(\"=\" * 60)\n    \n    if anzahl > 0:\n        print(f\"Richtige Zahlen: {sorted(richtige)}\")\n    \n    print(f\"\\n{titel} {emoji}\")\n    print(f\"Du hattest {anzahl} von 6 Zahlen richtig!\")\n    \n    # Statistik\n    if anzahl >= 3:\n        print(\"\\nüéÅ Gl√ºckwunsch, du hast gewonnen!\")\n    else:\n        print(\"\\nüí™ Viel Gl√ºck beim n√§chsten Mal!\")\n    \n    # Verpasste Zahlen\n    verpasst = mein_tipp - ziehung  # Differenz\n    if verpasst:\n        print(f\"\\n‚ùå Diese deiner Zahlen wurden nicht gezogen: {sorted(verpasst)}\")\n    \n    falsche_gezogene = ziehung - mein_tipp\n    if falsche_gezogene:\n        print(f\"‚ûï Diese gezogenen Zahlen hattest du nicht: {sorted(falsche_gezogene)}\")\n\nif __name__ == \"__main__\":\n    main()\n    \n    # Nochmal spielen?\n    while input(\"\\nüîÑ Nochmal spielen? (j/n): \").lower() == \"j\":\n        print(\"\\n\" * 2)\n        main()",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 3,
        "weekId": 2,
        "title": "Datenfilter mit List Comprehensions",
        "duration": "10-15 Min",
        "task": {
          "title": "Datenfilter mit List Comprehensions",
          "description": "Lerne List Comprehensions - eine elegante Python-Syntax f√ºr Listen-Transformationen!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "List Comprehension Basics",
            "goal": "Verstehen wie List Comprehensions funktionieren",
            "why": "List Comprehensions sind:",
            "code": "# ALTE METHODE: For-Schleife\nzahlen = [1, 2, 3, 4, 5]\nquadrate = []\n\nfor zahl in zahlen:\n    quadrate.append(zahl ** 2)\n\nprint(f\"Mit For-Schleife: {quadrate}\")\n\n# NEUE METHODE: List Comprehension\n# Syntax: [ausdruck for element in liste]\nquadrate_lc = [zahl ** 2 for zahl in zahlen]\n\nprint(f\"Mit List Comprehension: {quadrate_lc}\")\n\n# Beide machen das Gleiche, aber List Comprehension ist:\n# - Eine Zeile statt 4\n# - Schneller\n# - Eleganter\n\n# Mehr Beispiele\n# Strings in Gro√übuchstaben\nnamen = [\"anna\", \"ben\", \"clara\"]\ngro√ü = [name.upper() for name in namen]\nprint(gro√ü)  # ['ANNA', 'BEN', 'CLARA']\n\n# L√§ngen von Strings\nlaengen = [len(name) for name in namen]\nprint(laengen)  # [4, 3, 5]\n\n# Erste Buchstaben\ninitialen = [name[0].upper() for name in namen]\nprint(initialen)  # ['A', 'B', 'C']\n\n# Mit range()\n# Gerade Zahlen von 0 bis 20\ngerade = [x for x in range(21) if x % 2 == 0]\nprint(gerade)  # [0, 2, 4, 6, ..., 20]\n\n# Zahlen verdoppeln\noriginal = [1, 2, 3, 4, 5]\nverdoppelt = [x * 2 for x in original]\nprint(verdoppelt)  # [2, 4, 6, 8, 10]",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Conditional List Comprehensions",
            "goal": "If-Bedingungen in List Comprehensions einbauen",
            "why": "Oft wollen wir nur bestimmte Elemente filtern!",
            "code": "zahlen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# FILTERN mit if (am Ende)\n# Syntax: [ausdruck for element in liste if bedingung]\n\n# Nur gerade Zahlen\ngerade = [x for x in zahlen if x % 2 == 0]\nprint(f\"Gerade: {gerade}\")  # [2, 4, 6, 8, 10]\n\n# Nur ungerade\nungerade = [x for x in zahlen if x % 2 != 0]\nprint(f\"Ungerade: {ungerade}\")  # [1, 3, 5, 7, 9]\n\n# Zahlen gr√∂√üer als 5\ngro√ü = [x for x in zahlen if x > 5]\nprint(f\"Gr√∂√üer als 5: {gro√ü}\")  # [6, 7, 8, 9, 10]\n\n# Mit Transformation UND Filter\n# Quadrate der geraden Zahlen\ngerade_quadrate = [x ** 2 for x in zahlen if x % 2 == 0]\nprint(f\"Quadrate gerader Zahlen: {gerade_quadrate}\")  # [4, 16, 36, 64, 100]\n\n# IF-ELSE in List Comprehension (anderes Muster!)\n# Syntax: [ausdruck_wenn_wahr if bedingung else ausdruck_wenn_falsch for element in liste]\n\n# Gerade ‚Üí \"gerade\", Ungerade ‚Üí \"ungerade\"\nlabels = [\"gerade\" if x % 2 == 0 else \"ungerade\" for x in zahlen]\nprint(labels)\n\n# Positive ‚Üí Zahl, Negative ‚Üí 0\nzahlen_mit_negativen = [-2, -1, 0, 1, 2, 3]\nnur_positive = [x if x > 0 else 0 for x in zahlen_mit_negativen]\nprint(nur_positive)  # [0, 0, 0, 1, 2, 3]\n\n# Strings filtern\nworte = [\"Python\", \"Java\", \"C++\", \"JavaScript\", \"Ruby\"]\n\n# Nur Worte mit mehr als 4 Buchstaben\nlang = [wort for wort in worte if len(wort) > 4]\nprint(lang)  # ['Python', 'JavaScript']\n\n# Worte die 'a' enthalten\nmit_a = [wort for wort in worte if 'a' in wort.lower()]\nprint(mit_a)  # ['Java', 'JavaScript']\n\n# Praxisbeispiel: Zahlen aus gemischter Liste extrahieren\ngemischt = [1, \"Text\", 3.14, \"Hallo\", 42, None, 7]\nnur_zahlen = [x for x in gemischt if isinstance(x, (int, float))]\nprint(f\"Nur Zahlen: {nur_zahlen}\")  # [1, 3.14, 42, 7]",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Verschachtelte List Comprehensions",
            "goal": "Mit 2D-Listen (Listen von Listen) arbeiten",
            "why": "Matrix-Operationen, verschachtelte Daten verarbeiten",
            "code": "# 2D-Liste (Matrix)\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# ALTE METHODE: Alle Zahlen in eine flache Liste\nflach = []\nfor zeile in matrix:\n    for zahl in zeile:\n        flach.append(zahl)\n\nprint(f\"Flach (for): {flach}\")\n\n# MIT LIST COMPREHENSION (Flatten)\n# Syntax: [element for zeile in matrix for element in zeile]\nflach_lc = [zahl for zeile in matrix for zahl in zeile]\nprint(f\"Flach (LC): {flach_lc}\")  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Matrix transponieren (Zeilen <-> Spalten)\n# Original:     Transponiert:\n# 1 2 3         1 4 7\n# 4 5 6    ‚Üí    2 5 8\n# 7 8 9         3 6 9\n\ntransponiert = [[zeile[i] for zeile in matrix] for i in range(3)]\nprint(\"Transponiert:\")\nfor zeile in transponiert:\n    print(zeile)\n\n# Alle Zahlen verdoppeln\nverdoppelt = [[zahl * 2 for zahl in zeile] for zeile in matrix]\nprint(\"Verdoppelt:\")\nfor zeile in verdoppelt:\n    print(zeile)\n\n# Nur gerade Zahlen aus 2D-Liste\ngerade_2d = [[zahl for zahl in zeile if zahl % 2 == 0] for zeile in matrix]\nprint(\"Nur gerade:\")\nfor zeile in gerade_2d:\n    print(zeile)  # [[2], [4, 6], [8]]\n\n# Koordinaten generieren\n# Alle (x, y) Paare von (0,0) bis (2,2)\nkoordinaten = [(x, y) for x in range(3) for y in range(3)]\nprint(f\"Koordinaten: {koordinaten}\")\n# [(0,0), (0,1), (0,2), (1,0), (1,1), ...]\n\n# Multiplikationstabelle mit List Comprehension!\ntabelle = [[x * y for y in range(1, 11)] for x in range(1, 11)]\nprint(\"\\n1√ó1 Tabelle (erste 5√ó5):\")\nfor i in range(5):\n    print(tabelle[i][:5])  # Erste 5 Spalten",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Dict & Set Comprehensions",
            "goal": "Comprehensions f√ºr Dictionaries und Sets",
            "why": "Nicht nur Listen - auch Dicts und Sets haben Comprehensions!",
            "code": "# DICT COMPREHENSION\n# Syntax: {key: value for element in liste}\n\nzahlen = [1, 2, 3, 4, 5]\n\n# Zahl ‚Üí Quadrat\nquadrate_dict = {zahl: zahl ** 2 for zahl in zahlen}\nprint(f\"Quadrate Dict: {quadrate_dict}\")\n# {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n# Strings zu L√§ngen\nworte = [\"Python\", \"Java\", \"C++\"]\nlaengen_dict = {wort: len(wort) for wort in worte}\nprint(f\"L√§ngen: {laengen_dict}\")\n# {'Python': 6, 'Java': 4, 'C++': 3}\n\n# Mit Filter\n# Nur Worte l√§nger als 3 Zeichen\nlang_dict = {wort: len(wort) for wort in worte if len(wort) > 3}\nprint(f\"Lange Worte: {lang_dict}\")\n\n# Dict umkehren (Keys <-> Values)\noriginal_dict = {'a': 1, 'b': 2, 'c': 3}\numgekehrt = {value: key for key, value in original_dict.items()}\nprint(f\"Umgekehrt: {umgekehrt}\")  # {1: 'a', 2: 'b', 3: 'c'}\n\n# SET COMPREHENSION\n# Syntax: {ausdruck for element in liste}\n\nzahlen = [1, 2, 2, 3, 3, 3, 4, 4, 5]\n\n# Duplikate entfernen und transformieren\nquadrate_set = {x ** 2 for x in zahlen}\nprint(f\"Quadrate Set: {quadrate_set}\")  # {1, 4, 9, 16, 25}\n\n# Erste Buchstaben (eindeutig)\nnamen = [\"Anna\", \"Anton\", \"Ben\", \"Berta\", \"Clara\"]\ninitialen_set = {name[0] for name in namen}\nprint(f\"Initialen: {initialen_set}\")  # {'A', 'B', 'C'}\n\n# Praxisbeispiel: Dateierweiterungen aus Dateinamen\ndateien = [\"foto.jpg\", \"dokument.pdf\", \"bild.jpg\", \"text.txt\", \"musik.mp3\", \"video.mp4\"]\n\n# Alle Erweiterungen (eindeutig)\nerweiterungen = {datei.split('.')[-1] for datei in dateien}\nprint(f\"Erweiterungen: {erweiterungen}\")  # {'jpg', 'pdf', 'txt', 'mp3', 'mp4'}\n\n# Gruppierung: Dict mit Listen als Values\n# Dateien nach Erweiterung gruppieren\nfrom collections import defaultdict\n\ngruppiert = defaultdict(list)\nfor datei in dateien:\n    ext = datei.split('.')[-1]\n    gruppiert[ext].append(datei)\n\nprint(\"\\nDateien nach Typ:\")\nfor ext, files in gruppiert.items():\n    print(f\"{ext}: {files}\")\n\n# Das Gleiche mit Dict Comprehension + List Comprehension\nerweiterungen_unique = {datei.split('.')[-1] for datei in dateien}\ngruppiert_lc = {\n    ext: [datei for datei in dateien if datei.endswith(ext)]\n    for ext in erweiterungen_unique\n}\nprint(\"\\nGruppiert (LC):\", gruppiert_lc)",
            "checkpoint": ""
          },
          {
            "number": 5,
            "title": "Praxisprojekt - Dateianalyse Tool",
            "goal": "Alle Comprehensions in einem echten Projekt kombinieren",
            "why": "Zeigt wie man Comprehensions in der Praxis einsetzt!",
            "code": "def analysiere_text(text):\n    \"\"\"\n    Analysiert einen Text mit List/Dict/Set Comprehensions\n    \n    Returns: Dict mit verschiedenen Statistiken\n    \"\"\"\n    # Worte extrahieren und normalisieren\n    import string\n    \n    # Alle Worte in Kleinbuchstaben, ohne Satzzeichen\n    worte = [\n        wort.strip(string.punctuation).lower()\n        for wort in text.split()\n        if wort.strip(string.punctuation)  # Leere Worte ignorieren\n    ]\n    \n    # Statistiken mit Comprehensions\n    stats = {\n        # Anzahl Worte\n        'gesamt': len(worte),\n        \n        # Eindeutige Worte (Set)\n        'eindeutig': len(set(worte)),\n        \n        # Durchschnittliche Wortl√§nge\n        'durchschnitt_laenge': sum(len(w) for w in worte) / len(worte) if worte else 0,\n        \n        # L√§ngste Worte (Top 5)\n        'laengste': sorted(set(worte), key=len, reverse=True)[:5],\n        \n        # Wort-H√§ufigkeiten (Dict Comprehension)\n        'haeufigkeiten': {\n            wort: worte.count(wort)\n            for wort in set(worte)\n        },\n        \n        # Worte nach L√§nge gruppiert (Dict mit List Comprehension)\n        'nach_laenge': {\n            laenge: [w for w in set(worte) if len(w) == laenge]\n            for laenge in sorted(set(len(w) for w in worte))\n        },\n        \n        # Worte die mit Vokal beginnen\n        'mit_vokal': [w for w in set(worte) if w[0] in 'aeiou'],\n        \n        # Alle verwendeten Buchstaben (Set Comprehension)\n        'buchstaben': {char for wort in worte for char in wort}\n    }\n    \n    # Top 10 h√§ufigste Worte\n    sortiert = sorted(\n        stats['haeufigkeiten'].items(),\n        key=lambda x: x[1],\n        reverse=True\n    )\n    stats['top10'] = sortiert[:10]\n    \n    return stats\n\n# Testen\nbeispiel_text = \"\"\"\nPython ist eine interpretierte, objektorientierte Programmiersprache.\nPython wurde entwickelt um Code lesbar zu machen. Python ist einfach\nzu lernen und sehr m√§chtig. Python wird f√ºr Web-Entwicklung, Data Science,\nAutomatisierung und vieles mehr verwendet. Python ist toll!\n\"\"\"\n\nprint(\"üìä TEXT-ANALYSE mit List Comprehensions\")\nprint(\"=\" * 60)\n\nstats = analysiere_text(beispiel_text)\n\nprint(f\"\\nüìù Gesamt: {stats['gesamt']} Worte\")\nprint(f\"üî§ Eindeutig: {stats['eindeutig']} verschiedene Worte\")\nprint(f\"üìè Durchschnittliche L√§nge: {stats['durchschnitt_laenge']:.1f} Zeichen\")\n\nprint(f\"\\nüìà Top 10 h√§ufigste Worte:\")\nfor i, (wort, anzahl) in enumerate(stats['top10'], 1):\n    print(f\"   {i}. '{wort}': {anzahl}√ó\")\n\nprint(f\"\\nüìè L√§ngste Worte:\")\nfor wort in stats['laengste']:\n    print(f\"   - {wort} ({len(wort)} Zeichen)\")\n\nprint(f\"\\nüî§ Verwendete Buchstaben ({len(stats['buchstaben'])}):\")\nprint(f\"   {sorted(stats['buchstaben'])}\")\n\nprint(f\"\\nüéØ Worte nach L√§nge:\")\nfor laenge, worte_liste in sorted(stats['nach_laenge'].items())[:5]:  # Erste 5\n    print(f\"   {laenge} Zeichen: {', '.join(worte_liste[:5])}\")  # Max 5 Beispiele\n\n# Filterfunktion\ndef filtere_worte(text, min_laenge=4, mit_buchstabe=None):\n    \"\"\"Filtert Worte nach Kriterien\"\"\"\n    import string\n    \n    worte = [\n        wort.strip(string.punctuation).lower()\n        for wort in text.split()\n        if wort.strip(string.punctuation)\n    ]\n    \n    # Mehrere Filter kombinieren\n    gefiltert = [\n        wort for wort in set(worte)\n        if len(wort) >= min_laenge\n        and (mit_buchstabe is None or mit_buchstabe.lower() in wort)\n    ]\n    \n    return sorted(gefiltert)\n\nprint(\"\\n\\nüîç FILTER-BEISPIELE:\")\nprint(f\"Worte mit min. 6 Buchstaben: {filtere_worte(beispiel_text, min_laenge=6)}\")\nprint(f\"Worte mit 'y': {filtere_worte(beispiel_text, mit_buchstabe='y')}\")\nprint(f\"Lange Worte mit 't': {filtere_worte(beispiel_text, min_laenge=5, mit_buchstabe='t')}\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 4,
        "weekId": 2,
        "title": "Textdatei-Analyzer (Dateien Lesen)",
        "duration": "10-15 Min",
        "task": {
          "title": "Textdatei-Analyzer (Dateien Lesen)",
          "description": "Lerne wie man Dateien √∂ffnet, liest und analysiert!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Dateien √∂ffnen und lesen",
            "goal": "Grundlagen des Datei-Handlings verstehen",
            "why": "Fast jedes Programm arbeitet mit Dateien - Configs, Logs, Daten. Das ist essentiell!",
            "code": "# METHODE 1: open() und close() (alte Methode)\n# ‚ö†Ô∏è Nicht empfohlen - wir m√ºssen manuell close() aufrufen\n\ndatei = open(\"test.txt\", \"r\")  # \"r\" = read (lesen)\ninhalt = datei.read()  # Liest ALLES\ndatei.close()  # WICHTIG: Datei schlie√üen!\n\n# METHODE 2: with-Statement (EMPFOHLEN!)\n# Schlie√üt die Datei automatisch, auch bei Fehlern\n\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as datei:\n    inhalt = datei.read()\n    print(inhalt)\n# Hier ist die Datei automatisch geschlossen!\n\n# encoding=\"utf-8\" ist wichtig f√ºr Umlaute (√§, √∂, √º, √ü)\n\n# VERSCHIEDENE LESE-METHODEN\n\n# 1. .read() - Liest ALLES als einen String\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    alles = f.read()\n    print(\"Gesamter Inhalt:\", alles)\n\n# 2. .readline() - Liest EINE Zeile\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    zeile1 = f.readline()  # Erste Zeile\n    zeile2 = f.readline()  # Zweite Zeile\n    print(\"Erste Zeile:\", zeile1)\n    print(\"Zweite Zeile:\", zeile2)\n\n# 3. .readlines() - Liest ALLE Zeilen in eine Liste\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    alle_zeilen = f.readlines()  # Liste von Strings\n    print(\"Alle Zeilen als Liste:\", alle_zeilen)\n\n# 4. √úber Datei iterieren (BESTE Methode f√ºr gro√üe Dateien!)\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    for zeile in f:  # Zeile f√ºr Zeile\n        print(f\"Zeile: {zeile.strip()}\")  # .strip() entfernt \\n am Ende\n\n# Erstmal eine Test-Datei erstellen\ntestinhalt = \"\"\"Python ist toll!\nDies ist Zeile 2.\nUnd hier ist Zeile 3.\nUmlaute: √§√∂√º√ü\nZahlen: 12345\"\"\"\n\nwith open(\"test.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(testinhalt)\n\nprint(\"‚úÖ test.txt wurde erstellt!\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Dateien analysieren",
            "goal": "Informationen aus Dateien extrahieren",
            "why": "Daten in Dateien verstehen und verarbeiten",
            "code": "def analysiere_datei(dateiname):\n    \"\"\"\n    Analysiert eine Textdatei\n    \n    Returns: Dict mit Statistiken\n    \"\"\"\n    try:\n        with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n            zeilen = f.readlines()\n        \n        # Statistiken sammeln\n        stats = {\n            'zeilen': len(zeilen),\n            'zeichen': sum(len(zeile) for zeile in zeilen),\n            'worte': sum(len(zeile.split()) for zeile in zeilen),\n            'leere_zeilen': sum(1 for zeile in zeilen if zeile.strip() == \"\"),\n            'laengste_zeile': max(zeilen, key=len) if zeilen else \"\",\n            'kuerzeste_zeile': min([z for z in zeilen if z.strip()], key=len) if zeilen else \"\",\n        }\n        \n        # Durchschnitte\n        nicht_leere_zeilen = [z for z in zeilen if z.strip()]\n        if nicht_leere_zeilen:\n            stats['durchschnitt_zeichen'] = stats['zeichen'] / len(nicht_leere_zeilen)\n            stats['durchschnitt_worte'] = stats['worte'] / len(nicht_leere_zeilen)\n        \n        return stats\n        \n    except FileNotFoundError:\n        print(f\"‚ùå Datei '{dateiname}' nicht gefunden!\")\n        return None\n    except Exception as e:\n        print(f\"‚ùå Fehler beim Lesen: {e}\")\n        return None\n\n# Testen\nprint(\"üìä DATEI-ANALYSE\")\nprint(\"=\" * 50)\n\nstats = analysiere_datei(\"test.txt\")\n\nif stats:\n    print(f\"üìÑ Zeilen: {stats['zeilen']}\")\n    print(f\"üìù Worte: {stats['worte']}\")\n    print(f\"üî§ Zeichen: {stats['zeichen']}\")\n    print(f\"‚¨ú Leere Zeilen: {stats['leere_zeilen']}\")\n    \n    if 'durchschnitt_worte' in stats:\n        print(f\"üìä √ò Worte/Zeile: {stats['durchschnitt_worte']:.1f}\")\n        print(f\"üìä √ò Zeichen/Zeile: {stats['durchschnitt_zeichen']:.1f}\")\n    \n    print(f\"\\nüìè L√§ngste Zeile ({len(stats['laengste_zeile'])} Zeichen):\")\n    print(f\"   {stats['laengste_zeile'].strip()}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Spezifische Daten extrahieren",
            "goal": "Bestimmte Informationen aus Dateien filtern",
            "why": "Oft brauchen wir nur Teile einer Datei",
            "code": "def finde_zeilen_mit(dateiname, suchbegriff, case_sensitive=False):\n    \"\"\"\n    Findet alle Zeilen die einen Suchbegriff enthalten\n    \n    Parameters:\n        dateiname: Pfad zur Datei\n        suchbegriff: Was gesucht wird\n        case_sensitive: Gro√ü-/Kleinschreibung beachten?\n    \n    Returns:\n        Liste von (zeilennummer, zeile) Tupeln\n    \"\"\"\n    ergebnisse = []\n    \n    try:\n        with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n            for nummer, zeile in enumerate(f, start=1):\n                # Case-insensitive suche if gew√ºnscht\n                zeile_check = zeile if case_sensitive else zeile.lower()\n                begriff_check = suchbegriff if case_sensitive else suchbegriff.lower()\n                \n                if begriff_check in zeile_check:\n                    ergebnisse.append((nummer, zeile.strip()))\n        \n        return ergebnisse\n        \n    except FileNotFoundError:\n        print(f\"‚ùå Datei '{dateiname}' nicht gefunden!\")\n        return []\n\n# Test-Datei mit mehr Inhalt\nlog_inhalt = \"\"\"2024-01-15 10:23:45 INFO: Server gestartet\n2024-01-15 10:24:01 ERROR: Verbindung fehlgeschlagen\n2024-01-15 10:24:15 INFO: Neuversuch...\n2024-01-15 10:24:20 INFO: Verbindung hergestellt\n2024-01-15 10:25:00 WARNING: Hohe Auslastung\n2024-01-15 10:26:30 ERROR: Timeout\n2024-01-15 10:27:00 INFO: Server l√§uft normal\"\"\"\n\nwith open(\"logfile.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(log_inhalt)\n\n# Alle ERROR-Eintr√§ge finden\nprint(\"üîç Suche nach ERROR:\")\nerrors = finde_zeilen_mit(\"logfile.txt\", \"ERROR\")\nfor nummer, zeile in errors:\n    print(f\"  Zeile {nummer}: {zeile}\")\n\n# Alle INFO-Eintr√§ge\nprint(\"\\nüîç Suche nach INFO:\")\ninfos = finde_zeilen_mit(\"logfile.txt\", \"INFO\")\nprint(f\"  Gefunden: {len(infos)} INFO-Eintr√§ge\")\n\n# Filterfunktion f√ºr Logdateien\ndef analysiere_log(dateiname):\n    \"\"\"Z√§hlt verschiedene Log-Level\"\"\"\n    level_count = {}\n    \n    with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n        for zeile in f:\n            # Extrahiere Log-Level (nach Datum/Zeit)\n            parts = zeile.split()\n            if len(parts) >= 3:\n                level = parts[2].rstrip(':')  # Entferne ':' am Ende\n                level_count[level] = level_count.get(level, 0) + 1\n    \n    return level_count\n\nprint(\"\\nüìä Log-Level Statistik:\")\nstats = analysiere_log(\"logfile.txt\")\nfor level, count in sorted(stats.items()):\n    print(f\"  {level}: {count}√ó\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "CSV-√Ñhnliche Daten parsen",
            "goal": "Strukturierte Daten aus Textdateien lesen",
            "why": "Viele Daten kommen als CSV/TSV (Komma/Tab-getrennt)",
            "code": "# CSV-Daten (Comma Separated Values)\ncsv_daten = \"\"\"Name,Alter,Stadt,Beruf\nAnna Schmidt,28,Berlin,Entwicklerin\nMax M√ºller,35,M√ºnchen,Designer\nLisa Weber,42,Hamburg,Managerin\nTom Klein,31,K√∂ln,Analyst\"\"\"\n\nwith open(\"personen.csv\", \"w\", encoding=\"utf-8\") as f:\n    f.write(csv_daten)\n\ndef parse_csv(dateiname, delimiter=','):\n    \"\"\"\n    Parst eine CSV-Datei (einfache Version)\n    \n    Returns:\n        Liste von Dicts (ein Dict pro Zeile)\n    \"\"\"\n    daten = []\n    \n    with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n        zeilen = f.readlines()\n        \n        if not zeilen:\n            return daten\n        \n        # Erste Zeile = Spalten-Namen\n        header = zeilen[0].strip().split(delimiter)\n        \n        # Rest = Daten\n        for zeile in zeilen[1:]:\n            if zeile.strip():  # Ignoriere leere Zeilen\n                werte = zeile.strip().split(delimiter)\n                \n                # Dict erstellen: {spaltenname: wert}\n                eintrag = {\n                    header[i]: werte[i]\n                    for i in range(len(header))\n                    if i < len(werte)\n                }\n                \n                daten.append(eintrag)\n    \n    return daten\n\n# CSV einlesen\nprint(\"üìã CSV-DATEN\")\nprint(\"=\" * 50)\n\npersonen = parse_csv(\"personen.csv\")\n\nfor person in personen:\n    print(f\"\\nüë§ {person['Name']}\")\n    print(f\"   Alter: {person['Alter']}\")\n    print(f\"   Stadt: {person['Stadt']}\")\n    print(f\"   Beruf: {person['Beruf']}\")\n\n# Daten filtern und analysieren\nprint(\"\\nüìä AUSWERTUNGEN:\")\n\n# Durchschnittsalter\nalter_liste = [int(p['Alter']) for p in personen]\ndurchschnitt = sum(alter_liste) / len(alter_liste)\nprint(f\"Durchschnittsalter: {durchschnitt:.1f} Jahre\")\n\n# Personen aus Berlin\nberliner = [p for p in personen if p['Stadt'] == 'Berlin']\nprint(f\"Personen aus Berlin: {len(berliner)}\")\n\n# St√§dte-Verteilung\nstaedte = {}\nfor person in personen:\n    stadt = person['Stadt']\n    staedte[stadt] = staedte.get(stadt, 0) + 1\n\nprint(\"\\nPersonen pro Stadt:\")\nfor stadt, anzahl in sorted(staedte.items()):\n    print(f\"  {stadt}: {anzahl}\")",
            "checkpoint": ""
          },
          {
            "number": 5,
            "title": "Gro√ües Projekt - Logfile-Analyzer",
            "goal": "Vollst√§ndiger Datei-Analyzer mit allen Features",
            "why": "Real-World Anwendung aller gelernten Konzepte!",
            "code": "import re\nfrom datetime import datetime\nfrom collections import Counter\n\nclass LogAnalyzer:\n    \"\"\"Analysiert Logdateien\"\"\"\n    \n    def __init__(self, dateiname):\n        self.dateiname = dateiname\n        self.zeilen = []\n        self.lade_datei()\n    \n    def lade_datei(self):\n        \"\"\"L√§dt die Logdatei\"\"\"\n        try:\n            with open(self.dateiname, \"r\", encoding=\"utf-8\") as f:\n                self.zeilen = f.readlines()\n            print(f\"‚úÖ {len(self.zeilen)} Zeilen geladen\")\n        except FileNotFoundError:\n            print(f\"‚ùå Datei '{self.dateiname}' nicht gefunden!\")\n            self.zeilen = []\n    \n    def zaehle_level(self):\n        \"\"\"Z√§hlt verschiedene Log-Levels\"\"\"\n        levels = []\n        \n        for zeile in self.zeilen:\n            # Suche nach ERROR, WARNING, INFO, etc.\n            match = re.search(r'(ERROR|WARNING|INFO|DEBUG)', zeile)\n            if match:\n                levels.append(match.group(1))\n        \n        return Counter(levels)\n    \n    def finde_errors(self):\n        \"\"\"Findet alle ERROR-Zeilen\"\"\"\n        errors = []\n        \n        for nummer, zeile in enumerate(self.zeilen, start=1):\n            if 'ERROR' in zeile:\n                errors.append((nummer, zeile.strip()))\n        \n        return errors\n    \n    def zeitanalyse(self):\n        \"\"\"Analysiert Zeitstempel\"\"\"\n        zeiten = []\n        \n        for zeile in self.zeilen:\n            # Suche nach Datum/Zeit Pattern: YYYY-MM-DD HH:MM:SS\n            match = re.search(r'(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})', zeile)\n            if match:\n                try:\n                    zeit = datetime.strptime(match.group(1), '%Y-%m-%d %H:%M:%S')\n                    zeiten.append(zeit)\n                except ValueError:\n                    pass\n        \n        if not zeiten:\n            return None\n        \n        return {\n            'erste': min(zeiten),\n            'letzte': max(zeiten),\n            'dauer': max(zeiten) - min(zeiten),\n            'anzahl': len(zeiten)\n        }\n    \n    def statistiken(self):\n        \"\"\"Erstellt umfassende Statistiken\"\"\"\n        return {\n            'zeilen_gesamt': len(self.zeilen),\n            'zeichen_gesamt': sum(len(z) for z in self.zeilen),\n            'durchschnitt_zeichen': sum(len(z) for z in self.zeilen) / len(self.zeilen) if self.zeilen else 0,\n            'level_counts': self.zaehle_level(),\n            'errors': len(self.finde_errors()),\n            'zeit_info': self.zeitanalyse()\n        }\n    \n    def report(self):\n        \"\"\"Erstellt einen ausf√ºhrlichen Report\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"üìä LOG-ANALYSE: {self.dateiname}\")\n        print(\"=\" * 60)\n        \n        stats = self.statistiken()\n        \n        print(f\"\\nüìÑ Allgemein:\")\n        print(f\"   Zeilen: {stats['zeilen_gesamt']}\")\n        print(f\"   Zeichen: {stats['zeichen_gesamt']}\")\n        print(f\"   √ò Zeichen/Zeile: {stats['durchschnitt_zeichen']:.1f}\")\n        \n        print(f\"\\nüìä Log-Levels:\")\n        for level, count in stats['level_counts'].most_common():\n            prozent = (count / stats['zeilen_gesamt']) * 100\n            print(f\"   {level}: {count}√ó ({prozent:.1f}%)\")\n        \n        if stats['errors'] > 0:\n            print(f\"\\n‚ùå Errors: {stats['errors']}\")\n            print(\"   Erste 3 Errors:\")\n            for nummer, zeile in self.finde_errors()[:3]:\n                print(f\"   Zeile {nummer}: {zeile[:60]}...\")\n        \n        if stats['zeit_info']:\n            zi = stats['zeit_info']\n            print(f\"\\n‚è∞ Zeitraum:\")\n            print(f\"   Von: {zi['erste']}\")\n            print(f\"   Bis: {zi['letzte']}\")\n            print(f\"   Dauer: {zi['dauer']}\")\n\n# Testen\nanalyzer = LogAnalyzer(\"logfile.txt\")\nanalyzer.report()\n\n# Suche nach spezifischen Patterns\ndef suche_pattern(dateiname, pattern):\n    \"\"\"Sucht nach Regex-Pattern in Datei\"\"\"\n    treffer = []\n    \n    with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n        for nummer, zeile in enumerate(f, start=1):\n            if re.search(pattern, zeile):\n                treffer.append((nummer, zeile.strip()))\n    \n    return treffer\n\nprint(\"\\n\\nüîç Pattern-Suche:\")\n# Suche nach Zeitangaben\nzeitangaben = suche_pattern(\"logfile.txt\", r'\\d{2}:\\d{2}:\\d{2}')\nprint(f\"Zeilen mit Zeitangaben: {len(zeitangaben)}\")\n\n# Suche nach IP-Adressen (falls vorhanden)\nips = suche_pattern(\"logfile.txt\", r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}')\nprint(f\"Zeilen mit IP-Adressen: {len(ips)}\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 5,
        "weekId": 2,
        "title": "Notiz-App (Dateien Schreiben)",
        "duration": "10-15 Min",
        "task": {
          "title": "Notiz-App (Dateien Schreiben)",
          "description": "Erstelle eine Notiz-App die Notizen in Dateien speichert und verwaltet!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "In Dateien schreiben - Grundlagen",
            "goal": "Verstehen wie man Daten in Dateien schreibt",
            "why": "Daten persistent speichern ist essentiell - sonst sind sie nach Programmende weg!",
            "code": "# SCHREIB-MODI:\n# \"w\" = write (schreiben) - √úBERSCHREIBT existierende Datei!\n# \"a\" = append (anh√§ngen) - F√ºgt am Ende hinzu\n# \"x\" = exclusive create - Erstellt neue Datei, Fehler wenn existiert\n\n# Methode 1: write() - Schreibt einen String\nwith open(\"notiz.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Das ist meine erste Notiz.\\n\")\n    f.write(\"Und hier ist die zweite Zeile.\\n\")\n    # \\n am Ende f√ºr Zeilenumbruch!\n\nprint(\"‚úÖ notiz.txt erstellt!\")\n\n# Methode 2: writelines() - Schreibt eine Liste von Strings\nzeilen = [\n    \"Zeile 1\\n\",\n    \"Zeile 2\\n\",\n    \"Zeile 3\\n\"\n]\n\nwith open(\"liste.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.writelines(zeilen)\n\n# Methode 3: Append-Modus (a) - F√ºgt hinzu ohne zu √ºberschreiben\nwith open(\"notiz.txt\", \"a\", encoding=\"utf-8\") as f:\n    f.write(\"Diese Zeile wurde sp√§ter hinzugef√ºgt.\\n\")\n\n# Datei lesen um zu pr√ºfen\nwith open(\"notiz.txt\", \"r\", encoding=\"utf-8\") as f:\n    print(\"Inhalt von notiz.txt:\")\n    print(f.read())\n\n# ACHTUNG: \"w\" √úBERSCHREIBT!\nwith open(\"notiz.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Der alte Inhalt ist weg!\\n\")\n\nwith open(\"notiz.txt\", \"r\", encoding=\"utf-8\") as f:\n    print(\"\\nNach √úberschreiben:\")\n    print(f.read())\n\n# Sicherer: Pr√ºfen ob Datei existiert\nimport os\n\nif os.path.exists(\"wichtig.txt\"):\n    print(\"‚ö†Ô∏è Datei existiert bereits!\")\n    antwort = input(\"√úberschreiben? (j/n): \")\n    if antwort.lower() == \"j\":\n        with open(\"wichtig.txt\", \"w\", encoding=\"utf-8\") as f:\n            f.write(\"Neuer Inhalt\\n\")\nelse:\n    with open(\"wichtig.txt\", \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Erste Version\\n\")\n\n# x-Modus: Fehler wenn Datei existiert (extra sicher!)\ntry:\n    with open(\"neu.txt\", \"x\", encoding=\"utf-8\") as f:\n        f.write(\"Diese Datei ist garantiert neu!\\n\")\n    print(\"‚úÖ neu.txt erstellt\")\nexcept FileExistsError:\n    print(\"‚ùå neu.txt existiert bereits!\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Formatierte Daten schreiben",
            "goal": "Strukturierte Daten in Dateien speichern",
            "why": "Oft wollen wir Daten formatiert abspeichern (Listen, Dicts, etc.)",
            "code": "from datetime import datetime\n\ndef schreibe_log_eintrag(nachricht, level=\"INFO\"):\n    \"\"\"Schreibt einen formatierten Log-Eintrag\"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    log_zeile = f\"[{timestamp}] {level}: {nachricht}\\n\"\n    \n    with open(\"app.log\", \"a\", encoding=\"utf-8\") as f:\n        f.write(log_zeile)\n\n# Testen\nschreibe_log_eintrag(\"Programm gestartet\")\nschreibe_log_eintrag(\"Verbindung fehlgeschlagen\", \"ERROR\")\nschreibe_log_eintrag(\"Neuversuch...\", \"WARNING\")\nschreibe_log_eintrag(\"Erfolgreich verbunden\")\n\n# Log anzeigen\nprint(\"üìã app.log:\")\nwith open(\"app.log\", \"r\", encoding=\"utf-8\") as f:\n    print(f.read())\n\n# Daten als CSV schreiben\ndef schreibe_personen_csv(personen, dateiname=\"personen.csv\"):\n    \"\"\"\n    Schreibt Personen-Daten als CSV\n    \n    personen: Liste von Dicts mit name, alter, stadt\n    \"\"\"\n    with open(dateiname, \"w\", encoding=\"utf-8\") as f:\n        # Header\n        f.write(\"Name,Alter,Stadt\\n\")\n        \n        # Daten\n        for person in personen:\n            zeile = f\"{person['name']},{person['alter']},{person['stadt']}\\n\"\n            f.write(zeile)\n\n# Test-Daten\npersonen_liste = [\n    {\"name\": \"Anna\", \"alter\": 28, \"stadt\": \"Berlin\"},\n    {\"name\": \"Ben\", \"alter\": 35, \"stadt\": \"M√ºnchen\"},\n    {\"name\": \"Clara\", \"alter\": 42, \"stadt\": \"Hamburg\"}\n]\n\nschreibe_personen_csv(personen_liste)\nprint(\"\\n‚úÖ personen.csv erstellt!\")\n\n# CSV wieder lesen zur Kontrolle\nwith open(\"personen.csv\", \"r\", encoding=\"utf-8\") as f:\n    print(f.read())\n\n# Tabellen-Format schreiben\ndef schreibe_tabelle(daten, spalten, dateiname=\"tabelle.txt\"):\n    \"\"\"\n    Schreibt Daten als formatierte Tabelle\n    \n    daten: Liste von Dicts\n    spalten: Liste von Spalten-Namen\n    \"\"\"\n    with open(dateiname, \"w\", encoding=\"utf-8\") as f:\n        # Spalten-Breiten berechnen\n        breiten = {}\n        for spalte in spalten:\n            max_breite = len(spalte)\n            for zeile in daten:\n                wert_laenge = len(str(zeile.get(spalte, \"\")))\n                max_breite = max(max_breite, wert_laenge)\n            breiten[spalte] = max_breite + 2  # +2 f√ºr Padding\n        \n        # Header\n        header = \" | \".join(spalte.ljust(breiten[spalte]) for spalte in spalten)\n        f.write(header + \"\\n\")\n        f.write(\"-\" * len(header) + \"\\n\")\n        \n        # Daten\n        for zeile in daten:\n            zeile_str = \" | \".join(\n                str(zeile.get(spalte, \"\")).ljust(breiten[spalte])\n                for spalte in spalten\n            )\n            f.write(zeile_str + \"\\n\")\n\n# Testen\nschreibe_tabelle(personen_liste, [\"name\", \"alter\", \"stadt\"], \"personen_tabelle.txt\")\nprint(\"\\nüìä personen_tabelle.txt:\")\nwith open(\"personen_tabelle.txt\", \"r\", encoding=\"utf-8\") as f:\n    print(f.read())",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Notiz-App Kernfunktionen",
            "goal": "CRUD-Operationen (Create, Read, Update, Delete) f√ºr Notizen",
            "why": "Das sind die Basis-Operationen jeder Daten-App!",
            "code": "import os\nfrom datetime import datetime\n\nclass NotizManager:\n    \"\"\"Verwaltet Notizen in Dateien\"\"\"\n    \n    def __init__(self, verzeichnis=\"notizen\"):\n        self.verzeichnis = verzeichnis\n        \n        # Verzeichnis erstellen falls nicht vorhanden\n        if not os.path.exists(verzeichnis):\n            os.makedirs(verzeichnis)\n            print(f\"‚úÖ Verzeichnis '{verzeichnis}' erstellt\")\n    \n    def erstelle_notiz(self, titel, inhalt):\n        \"\"\"Erstellt eine neue Notiz\"\"\"\n        # Dateiname aus Titel erstellen (sicher)\n        # Ersetze unsichere Zeichen\n        sicherer_titel = \"\".join(\n            c if c.isalnum() or c in (' ', '-', '_') else '_'\n            for c in titel\n        ).strip().replace(' ', '_')\n        \n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        dateiname = f\"{timestamp}_{sicherer_titel}.txt\"\n        dateipfad = os.path.join(self.verzeichnis, dateiname)\n        \n        with open(dateipfad, \"w\", encoding=\"utf-8\") as f:\n            f.write(f\"Titel: {titel}\\n\")\n            f.write(f\"Erstellt: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n            f.write(\"-\" * 50 + \"\\n\")\n            f.write(inhalt + \"\\n\")\n        \n        print(f\"‚úÖ Notiz '{titel}' gespeichert als {dateiname}\")\n        return dateipfad\n    \n    def liste_notizen(self):\n        \"\"\"Listet alle Notizen auf\"\"\"\n        dateien = [f for f in os.listdir(self.verzeichnis) if f.endswith('.txt')]\n        \n        if not dateien:\n            print(\"üì≠ Keine Notizen vorhanden\")\n            return []\n        \n        notizen = []\n        for datei in sorted(dateien):\n            pfad = os.path.join(self.verzeichnis, datei)\n            with open(pfad, \"r\", encoding=\"utf-8\") as f:\n                erste_zeile = f.readline()\n                # Titel extrahieren\n                if erste_zeile.startswith(\"Titel: \"):\n                    titel = erste_zeile[7:].strip()\n                else:\n                    titel = datei\n                \n                notizen.append({\n                    'datei': datei,\n                    'pfad': pfad,\n                    'titel': titel\n                })\n        \n        return notizen\n    \n    def lese_notiz(self, dateiname):\n        \"\"\"Liest eine Notiz\"\"\"\n        pfad = os.path.join(self.verzeichnis, dateiname)\n        \n        try:\n            with open(pfad, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except FileNotFoundError:\n            print(f\"‚ùå Notiz '{dateiname}' nicht gefunden!\")\n            return None\n    \n    def loesche_notiz(self, dateiname):\n        \"\"\"L√∂scht eine Notiz\"\"\"\n        pfad = os.path.join(self.verzeichnis, dateiname)\n        \n        try:\n            os.remove(pfad)\n            print(f\"üóëÔ∏è Notiz '{dateiname}' gel√∂scht\")\n            return True\n        except FileNotFoundError:\n            print(f\"‚ùå Notiz '{dateiname}' nicht gefunden!\")\n            return False\n    \n    def suche_in_notizen(self, suchbegriff):\n        \"\"\"Sucht in allen Notizen\"\"\"\n        ergebnisse = []\n        \n        for notiz_info in self.liste_notizen():\n            inhalt = self.lese_notiz(notiz_info['datei'])\n            if inhalt and suchbegriff.lower() in inhalt.lower():\n                ergebnisse.append(notiz_info)\n        \n        return ergebnisse\n\n# Testen\nprint(\"üìù NOTIZ-MANAGER TEST\")\nprint(\"=\" * 60)\n\nmanager = NotizManager()\n\n# Notizen erstellen\nmanager.erstelle_notiz(\n    \"Einkaufsliste\",\n    \"- Milch\\n- Brot\\n- Eier\\n- K√§se\"\n)\n\nmanager.erstelle_notiz(\n    \"Meeting Notizen\",\n    \"Teilnehmer: Anna, Ben, Clara\\nThema: Projekt-Update\\nN√§chste Schritte: ...\"\n)\n\nmanager.erstelle_notiz(\n    \"Python Lernen\",\n    \"Heute gelernt:\\n- Dateien schreiben\\n- Notiz-App erstellen\"\n)\n\n# Alle Notizen auflisten\nprint(\"\\nüìö Alle Notizen:\")\nfor i, notiz in enumerate(manager.liste_notizen(), 1):\n    print(f\"{i}. {notiz['titel']}\")\n\n# Notiz lesen\nprint(\"\\nüìñ Lese 'Einkaufsliste':\")\nnotizen = manager.liste_notizen()\nif notizen:\n    inhalt = manager.lese_notiz(notizen[0]['datei'])\n    print(inhalt)\n\n# Suchen\nprint(\"\\nüîç Suche nach 'Python':\")\nergebnisse = manager.suche_in_notizen(\"Python\")\nfor notiz in ergebnisse:\n    print(f\"  Gefunden in: {notiz['titel']}\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Interaktive Notiz-App",
            "goal": "Vollst√§ndige CLI-App mit Menu",
            "why": "Kombiniert alles Gelernte zu einer nutzbaren Anwendung!",
            "code": "def zeige_menu():\n    \"\"\"Zeigt das Hauptmen√º\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"üìù NOTIZ-APP\")\n    print(\"=\" * 60)\n    print(\"1. Neue Notiz erstellen\")\n    print(\"2. Alle Notizen anzeigen\")\n    print(\"3. Notiz lesen\")\n    print(\"4. Notiz l√∂schen\")\n    print(\"5. In Notizen suchen\")\n    print(\"6. Notiz bearbeiten\")\n    print(\"7. Statistiken\")\n    print(\"8. Beenden\")\n    print(\"=\" * 60)\n\ndef erstelle_notiz_interaktiv(manager):\n    \"\"\"Interaktive Notiz-Erstellung\"\"\"\n    print(\"\\n‚ûï NEUE NOTIZ\")\n    print(\"-\" * 40)\n    \n    titel = input(\"Titel: \").strip()\n    if not titel:\n        print(\"‚ùå Titel darf nicht leer sein!\")\n        return\n    \n    print(\"Inhalt (Leerzeile + Enter zum Beenden):\")\n    zeilen = []\n    while True:\n        zeile = input()\n        if zeile == \"\":\n            break\n        zeilen.append(zeile)\n    \n    inhalt = \"\\n\".join(zeilen)\n    \n    if inhalt:\n        manager.erstelle_notiz(titel, inhalt)\n    else:\n        print(\"‚ùå Notiz ohne Inhalt nicht gespeichert\")\n\ndef zeige_notizen(manager):\n    \"\"\"Zeigt alle Notizen mit Nummern\"\"\"\n    notizen = manager.liste_notizen()\n    \n    if not notizen:\n        return []\n    \n    print(\"\\nüìö ALLE NOTIZEN:\")\n    print(\"-\" * 60)\n    for i, notiz in enumerate(notizen, 1):\n        print(f\"{i}. {notiz['titel']}\")\n    \n    return notizen\n\ndef lese_notiz_interaktiv(manager):\n    \"\"\"Liest eine ausgew√§hlte Notiz\"\"\"\n    notizen = zeige_notizen(manager)\n    \n    if not notizen:\n        return\n    \n    try:\n        auswahl = int(input(\"\\nNotiz-Nummer: \"))\n        if 1 <= auswahl <= len(notizen):\n            notiz = notizen[auswahl - 1]\n            print(\"\\n\" + \"=\" * 60)\n            print(f\"üìñ {notiz['titel']}\")\n            print(\"=\" * 60)\n            inhalt = manager.lese_notiz(notiz['datei'])\n            print(inhalt)\n        else:\n            print(\"‚ùå Ung√ºltige Nummer!\")\n    except ValueError:\n        print(\"‚ùå Bitte eine Zahl eingeben!\")\n\ndef loesche_notiz_interaktiv(manager):\n    \"\"\"L√∂scht eine ausgew√§hlte Notiz\"\"\"\n    notizen = zeige_notizen(manager)\n    \n    if not notizen:\n        return\n    \n    try:\n        auswahl = int(input(\"\\nZu l√∂schende Notiz-Nummer: \"))\n        if 1 <= auswahl <= len(notizen):\n            notiz = notizen[auswahl - 1]\n            \n            bestaetigung = input(f\"'{notiz['titel']}' wirklich l√∂schen? (j/n): \")\n            if bestaetigung.lower() == 'j':\n                manager.loesche_notiz(notiz['datei'])\n        else:\n            print(\"‚ùå Ung√ºltige Nummer!\")\n    except ValueError:\n        print(\"‚ùå Bitte eine Zahl eingeben!\")\n\ndef suche_interaktiv(manager):\n    \"\"\"Sucht in Notizen\"\"\"\n    begriff = input(\"\\nüîç Suchbegriff: \").strip()\n    \n    if not begriff:\n        print(\"‚ùå Suchbegriff darf nicht leer sein!\")\n        return\n    \n    ergebnisse = manager.suche_in_notizen(begriff)\n    \n    if ergebnisse:\n        print(f\"\\n‚úÖ {len(ergebnisse)} Ergebnis(se) gefunden:\")\n        for notiz in ergebnisse:\n            print(f\"  üìÑ {notiz['titel']}\")\n    else:\n        print(\"‚ùå Keine Ergebnisse gefunden\")\n\ndef bearbeite_notiz(manager):\n    \"\"\"Bearbeitet eine existierende Notiz\"\"\"\n    notizen = zeige_notizen(manager)\n    \n    if not notizen:\n        return\n    \n    try:\n        auswahl = int(input(\"\\nZu bearbeitende Notiz-Nummer: \"))\n        if 1 <= auswahl <= len(notizen):\n            notiz = notizen[auswahl - 1]\n            \n            # Aktuellen Inhalt zeigen\n            print(\"\\n\" + \"=\" * 60)\n            print(\"AKTUELLER INHALT:\")\n            print(\"=\" * 60)\n            alter_inhalt = manager.lese_notiz(notiz['datei'])\n            print(alter_inhalt)\n            \n            # Neuen Inhalt eingeben\n            print(\"\\n\" + \"=\" * 60)\n            print(\"NEUER INHALT (Leerzeile + Enter zum Beenden):\")\n            zeilen = []\n            while True:\n                zeile = input()\n                if zeile == \"\":\n                    break\n                zeilen.append(zeile)\n            \n            neuer_inhalt = \"\\n\".join(zeilen)\n            \n            if neuer_inhalt:\n                # √úberschreiben\n                pfad = notiz['pfad']\n                with open(pfad, \"w\", encoding=\"utf-8\") as f:\n                    f.write(f\"Titel: {notiz['titel']}\\n\")\n                    f.write(f\"Bearbeitet: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n                    f.write(\"-\" * 50 + \"\\n\")\n                    f.write(neuer_inhalt + \"\\n\")\n                \n                print(\"‚úÖ Notiz aktualisiert!\")\n            else:\n                print(\"‚ùå Kein neuer Inhalt - Notiz nicht ge√§ndert\")\n        else:\n            print(\"‚ùå Ung√ºltige Nummer!\")\n    except ValueError:\n        print(\"‚ùå Bitte eine Zahl eingeben!\")\n\ndef zeige_statistiken(manager):\n    \"\"\"Zeigt Statistiken √ºber alle Notizen\"\"\"\n    notizen = manager.liste_notizen()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"üìä STATISTIKEN\")\n    print(\"=\" * 60)\n    \n    if not notizen:\n        print(\"Keine Notizen vorhanden\")\n        return\n    \n    # Anzahl\n    print(f\"Gesamt Notizen: {len(notizen)}\")\n    \n    # Gesamtgr√∂√üe\n    gesamt_zeichen = 0\n    gesamt_zeilen = 0\n    \n    for notiz in notizen:\n        inhalt = manager.lese_notiz(notiz['datei'])\n        if inhalt:\n            gesamt_zeichen += len(inhalt)\n            gesamt_zeilen += len(inhalt.splitlines())\n    \n    print(f\"Gesamt Zeichen: {gesamt_zeichen}\")\n    print(f\"Gesamt Zeilen: {gesamt_zeilen}\")\n    print(f\"Durchschnitt Zeichen/Notiz: {gesamt_zeichen // len(notizen)}\")\n    print(f\"Durchschnitt Zeilen/Notiz: {gesamt_zeilen // len(notizen)}\")\n\n# HAUPTPROGRAMM\ndef main():\n    manager = NotizManager()\n    \n    while True:\n        zeige_menu()\n        wahl = input(\"\\nW√§hle eine Option (1-8): \").strip()\n        \n        if wahl == \"1\":\n            erstelle_notiz_interaktiv(manager)\n        \n        elif wahl == \"2\":\n            zeige_notizen(manager)\n            input(\"\\nDr√ºcke Enter zum Fortfahren...\")\n        \n        elif wahl == \"3\":\n            lese_notiz_interaktiv(manager)\n            input(\"\\nDr√ºcke Enter zum Fortfahren...\")\n        \n        elif wahl == \"4\":\n            loesche_notiz_interaktiv(manager)\n        \n        elif wahl == \"5\":\n            suche_interaktiv(manager)\n            input(\"\\nDr√ºcke Enter zum Fortfahren...\")\n        \n        elif wahl == \"6\":\n            bearbeite_notiz(manager)\n        \n        elif wahl == \"7\":\n            zeige_statistiken(manager)\n            input(\"\\nDr√ºcke Enter zum Fortfahren...\")\n        \n        elif wahl == \"8\":\n            print(\"\\nüëã Auf Wiedersehen!\")\n            break\n        \n        else:\n            print(\"‚ùå Ung√ºltige Wahl! Bitte 1-8 w√§hlen.\")\n\nif __name__ == \"__main__\":\n    main()",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 6,
        "weekId": 2,
        "title": "Robuster Datei-Reader (Error Handling)",
        "duration": "10-15 Min",
        "task": {
          "title": "Robuster Datei-Reader (Error Handling)",
          "description": "Lerne professionelles Error Handling - damit deine Programme nicht abst√ºrzen!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Try-Except Basics",
            "goal": "Fehler abfangen statt abst√ºrzen",
            "why": "Fehler passieren! Datei nicht gefunden, ung√ºltige Eingabe, Netzwerk-Timeout... Gute Programme crashen nicht, sondern reagieren elegant.",
            "code": "# OHNE ERROR HANDLING - Programm st√ºrzt ab!\nprint(\"Beispiel OHNE Error Handling:\")\ntry:\n    # Das w√ºrde das Programm crashen lassen:\n    # zahl = int(\"abc\")  # ValueError!\n    # datei = open(\"existiert_nicht.txt\")  # FileNotFoundError!\n    pass\nexcept:\n    pass\n\n# MIT TRY-EXCEPT - Programm l√§uft weiter\nprint(\"\\n‚úÖ Beispiel MIT Error Handling:\")\n\ntry:\n    zahl = int(\"abc\")  # Wird Fehler verursachen\n    print(\"Das wird nie ausgef√ºhrt\")\nexcept:\n    print(\"‚ùå Fehler beim Konvertieren!\")\n    print(\"Aber das Programm l√§uft weiter!\")\n\nprint(\"Programm l√§uft normal weiter...\\n\")\n\n# SPEZIFISCHE EXCEPTIONS - Besser!\n# Verschiedene Fehler unterschiedlich behandeln\n\ndef sichere_division(a, b):\n    \"\"\"Division mit Error Handling\"\"\"\n    try:\n        ergebnis = a / b\n        return ergebnis\n    except ZeroDivisionError:\n        print(\"‚ùå Division durch 0 ist nicht erlaubt!\")\n        return None\n    except TypeError:\n        print(\"‚ùå Nur Zahlen erlaubt!\")\n        return None\n\n# Testen\nprint(\"Division-Tests:\")\nprint(f\"10 / 2 = {sichere_division(10, 2)}\")\nprint(f\"10 / 0 = {sichere_division(10, 0)}\")\nprint(f\"10 / 'x' = {sichere_division(10, 'x')}\")\n\n# MEHRERE EXCEPTIONS GLEICHZEITIG\ndef lese_zahl_aus_datei(dateiname, zeile=0):\n    \"\"\"Liest eine Zahl aus einer Datei\"\"\"\n    try:\n        with open(dateiname, \"r\") as f:\n            zeilen = f.readlines()\n            zahl_str = zeilen[zeile].strip()\n            zahl = int(zahl_str)\n            return zahl\n    \n    except FileNotFoundError:\n        print(f\"‚ùå Datei '{dateiname}' nicht gefunden!\")\n        return None\n    \n    except IndexError:\n        print(f\"‚ùå Zeile {zeile} existiert nicht!\")\n        return None\n    \n    except ValueError:\n        print(f\"‚ùå Keine g√ºltige Zahl in Zeile {zeile}!\")\n        return None\n    \n    except Exception as e:  # F√§ngt ALLE anderen Fehler\n        print(f\"‚ùå Unerwarteter Fehler: {e}\")\n        return None\n\n# Test-Datei erstellen\nwith open(\"zahlen.txt\", \"w\") as f:\n    f.write(\"42\\n\")\n    f.write(\"123\\n\")\n    f.write(\"kein Zahl\\n\")\n\n# Testen\nprint(\"\\nDatei-Lese-Tests:\")\nprint(f\"Zeile 0: {lese_zahl_aus_datei('zahlen.txt', 0)}\")  # OK\nprint(f\"Zeile 2: {lese_zahl_aus_datei('zahlen.txt', 2)}\")  # ValueError\nprint(f\"Zeile 10: {lese_zahl_aus_datei('zahlen.txt', 10)}\")  # IndexError\nprint(f\"Falsche Datei: {lese_zahl_aus_datei('gibts_nicht.txt', 0)}\")  # FileNotFoundError\n\n# EXCEPTION-INFO SPEICHERN mit 'as'\ntry:\n    x = 10 / 0\nexcept ZeroDivisionError as fehler:\n    print(f\"\\n‚ùå Fehler aufgetreten: {fehler}\")\n    print(f\"Fehlertyp: {type(fehler).__name__}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Else und Finally",
            "goal": "Komplettes Try-Except-Else-Finally verstehen",
            "why": "",
            "code": "# KOMPLETTE STRUKTUR: try-except-else-finally\n\ndef verarbeite_datei(dateiname):\n    \"\"\"Zeigt alle 4 Bl√∂cke\"\"\"\n    print(f\"\\nüîß Verarbeite '{dateiname}':\")\n    \n    try:\n        print(\"  1. TRY: √ñffne Datei...\")\n        with open(dateiname, \"r\") as f:\n            inhalt = f.read()\n        \n        print(\"  2. TRY: Datei erfolgreich gelesen!\")\n        \n        # Simulation: Verarbeitung k√∂nnte fehlschlagen\n        if len(inhalt) == 0:\n            raise ValueError(\"Datei ist leer!\")\n    \n    except FileNotFoundError:\n        print(\"  ‚ùå EXCEPT: Datei nicht gefunden!\")\n        return None\n    \n    except ValueError as e:\n        print(f\"  ‚ùå EXCEPT: {e}\")\n        return None\n    \n    else:\n        # L√§uft nur wenn KEIN Exception in try!\n        print(\"  ‚úÖ ELSE: Keine Fehler - verarbeite weiter...\")\n        zeilen_anzahl = len(inhalt.splitlines())\n        print(f\"  ‚úÖ ELSE: {zeilen_anzahl} Zeilen gefunden\")\n        return inhalt\n    \n    finally:\n        # L√§uft IMMER - egal ob Fehler oder nicht!\n        print(\"  üèÅ FINALLY: Aufr√§umen (l√§uft immer!)\")\n\n# Test-Dateien\nwith open(\"vorhanden.txt\", \"w\") as f:\n    f.write(\"Zeile 1\\nZeile 2\\nZeile 3\\n\")\n\nwith open(\"leer.txt\", \"w\") as f:\n    pass  # Leere Datei\n\n# Tests\nverarbeite_datei(\"vorhanden.txt\")  # Erfolg ‚Üí else l√§uft\nverarbeite_datei(\"leer.txt\")  # ValueError ‚Üí except l√§uft  \nverarbeite_datei(\"gibts_nicht.txt\")  # FileNotFoundError ‚Üí except l√§uft\n\n# PRAKTISCHES BEISPIEL: Datenbank-√§hnlich\nclass DatenVerbindung:\n    \"\"\"Simuliert eine Datenbank-Verbindung\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.verbunden = False\n    \n    def verbinde(self):\n        print(f\"  üîå Verbinde mit '{self.name}'...\")\n        self.verbunden = True\n    \n    def trenne(self):\n        if self.verbunden:\n            print(f\"  üîå Trenne Verbindung zu '{self.name}'...\")\n            self.verbunden = False\n\ndef daten_abfragen(db_name, abfrage):\n    \"\"\"Fragt Daten ab - mit garantiertem Cleanup\"\"\"\n    db = DatenVerbindung(db_name)\n    \n    try:\n        db.verbinde()\n        \n        # Simulation: Abfrage k√∂nnte fehlschlagen\n        if \"fehler\" in abfrage.lower():\n            raise ValueError(\"Ung√ºltige Abfrage!\")\n        \n        print(f\"  ‚úÖ Abfrage erfolgreich: '{abfrage}'\")\n        return f\"Ergebnis von '{abfrage}'\"\n    \n    except ValueError as e:\n        print(f\"  ‚ùå Abfrage-Fehler: {e}\")\n        return None\n    \n    finally:\n        # WICHTIG: Verbindung IMMER trennen!\n        db.trenne()\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"DATENBANK-BEISPIEL:\")\nprint(\"=\" * 60)\n\ndaten_abfragen(\"MeineDB\", \"SELECT * FROM users\")\ndaten_abfragen(\"MeineDB\", \"FEHLER-Abfrage\")  # Verursacht Fehler, aber trennt trotzdem!",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Eigene Exceptions",
            "goal": "Custom Exceptions f√ºr spezielle F√§lle",
            "why": "Manchmal brauchen wir eigene Fehler-Typen f√ºr unsere App-Logik",
            "code": "# EIGENE EXCEPTION-KLASSE\nclass AlterZuNiedrigError(Exception):\n    \"\"\"Fehler wenn Alter unter Minimum\"\"\"\n    pass\n\nclass AlterZuHochError(Exception):\n    \"\"\"Fehler wenn Alter √ºber Maximum\"\"\"\n    pass\n\nclass UngueltigerNameError(Exception):\n    \"\"\"Fehler bei ung√ºltigem Namen\"\"\"\n    pass\n\ndef registriere_benutzer(name, alter):\n    \"\"\"\n    Registriert Benutzer mit Validierung\n    \n    Raises:\n        UngueltigerNameError: Name zu kurz oder leer\n        AlterZuNiedrigError: Unter 13 Jahre\n        AlterZuHochError: √úber 120 Jahre\n    \"\"\"\n    # Name validieren\n    if not name or len(name) < 2:\n        raise UngueltigerNameError(\"Name muss mindestens 2 Zeichen haben!\")\n    \n    # Alter validieren\n    if alter < 13:\n        raise AlterZuNiedrigError(f\"Mindestalter ist 13 (angegeben: {alter})\")\n    \n    if alter > 120:\n        raise AlterZuHochError(f\"Maximalalter ist 120 (angegeben: {alter})\")\n    \n    # Alles OK\n    print(f\"‚úÖ Benutzer '{name}' ({alter}) registriert!\")\n    return {\"name\": name, \"alter\": alter}\n\n# Testen mit verschiedenen F√§llen\ntest_faelle = [\n    (\"Anna\", 25),      # OK\n    (\"\", 30),          # UngueltigerNameError\n    (\"Ben\", 10),       # AlterZuNiedrigError\n    (\"Clara\", 150),    # AlterZuHochError\n    (\"Max\", 50),       # OK\n]\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"BENUTZER-REGISTRIERUNG:\")\nprint(\"=\" * 60)\n\nfor name, alter in test_faelle:\n    try:\n        registriere_benutzer(name, alter)\n    \n    except UngueltigerNameError as e:\n        print(f\"‚ùå Ung√ºltiger Name: {e}\")\n    \n    except AlterZuNiedrigError as e:\n        print(f\"‚ùå Zu jung: {e}\")\n    \n    except AlterZuHochError as e:\n        print(f\"‚ùå Zu alt: {e}\")\n    \n    print()\n\n# EXCEPTION MIT ZUS√ÑTZLICHEN DATEN\nclass DateiZuGro√üError(Exception):\n    \"\"\"Fehler wenn Datei Gr√∂√üenlimit √ºberschreitet\"\"\"\n    \n    def __init__(self, dateiname, gr√∂√üe, limit):\n        self.dateiname = dateiname\n        self.gr√∂√üe = gr√∂√üe\n        self.limit = limit\n        \n        message = f\"Datei '{dateiname}' ({gr√∂√üe} MB) √ºberschreitet Limit von {limit} MB\"\n        super().__init__(message)\n\ndef lade_datei(dateiname, gr√∂√üe_mb, limit_mb=10):\n    \"\"\"L√§dt Datei mit Gr√∂√üen-Check\"\"\"\n    if gr√∂√üe_mb > limit_mb:\n        raise DateiZuGro√üError(dateiname, gr√∂√üe_mb, limit_mb)\n    \n    print(f\"‚úÖ Datei '{dateiname}' ({gr√∂√üe_mb} MB) geladen\")\n\n# Testen\ntry:\n    lade_datei(\"klein.jpg\", 5)  # OK\n    lade_datei(\"gro√ü.mp4\", 50)  # Fehler!\nexcept DateiZuGro√üError as e:\n    print(f\"‚ùå {e}\")\n    print(f\"   Details: Datei={e.dateiname}, Gr√∂√üe={e.gr√∂√üe}, Limit={e.limit}\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Robuster Datei-Reader",
            "goal": "Alle Error-Handling-Techniken in einer App kombinieren",
            "why": "Real-World Beispiel mit umfassendem Error Handling",
            "code": "import os\nfrom typing import Optional, List, Dict\n\nclass DateiLeseError(Exception):\n    \"\"\"Basis-Fehler f√ºr Datei-Lese-Probleme\"\"\"\n    pass\n\nclass DateiZuGro√üError(DateiLeseError):\n    \"\"\"Datei √ºberschreitet Gr√∂√üenlimit\"\"\"\n    pass\n\nclass UngueltigesFormatError(DateiLeseError):\n    \"\"\"Datei hat falsches Format\"\"\"\n    pass\n\nclass RobusterDateiReader:\n    \"\"\"Datei-Reader mit umfassendem Error Handling\"\"\"\n    \n    def __init__(self, max_gr√∂√üe_mb=10):\n        self.max_gr√∂√üe_mb = max_gr√∂√üe_mb\n        self.max_gr√∂√üe_bytes = max_gr√∂√üe_mb * 1024 * 1024\n    \n    def lese_datei(self, dateipfad: str, encoding='utf-8') -> Optional[str]:\n        \"\"\"\n        Liest Datei mit vollst√§ndigem Error Handling\n        \n        Returns:\n            Datei-Inhalt oder None bei Fehler\n        \n        Raises:\n            Verschiedene DateiLeseError Varianten\n        \"\"\"\n        # 1. Existenz pr√ºfen\n        if not os.path.exists(dateipfad):\n            raise FileNotFoundError(f\"Datei '{dateipfad}' existiert nicht!\")\n        \n        # 2. Pr√ºfen ob es eine Datei ist (nicht Verzeichnis)\n        if not os.path.isfile(dateipfad):\n            raise IsADirectoryError(f\"'{dateipfad}' ist ein Verzeichnis, keine Datei!\")\n        \n        # 3. Gr√∂√üe pr√ºfen\n        gr√∂√üe = os.path.getsize(dateipfad)\n        if gr√∂√üe > self.max_gr√∂√üe_bytes:\n            raise DateiZuGro√üError(\n                f\"Datei ist {gr√∂√üe / 1024 / 1024:.1f} MB, \"\n                f\"Maximum ist {self.max_gr√∂√üe_mb} MB\"\n            )\n        \n        # 4. Lesbar pr√ºfen\n        if not os.access(dateipfad, os.R_OK):\n            raise PermissionError(f\"Keine Leseberechtigung f√ºr '{dateipfad}'!\")\n        \n        # 5. Lesen mit Error Handling\n        try:\n            with open(dateipfad, 'r', encoding=encoding) as f:\n                inhalt = f.read()\n            \n            return inhalt\n        \n        except UnicodeDecodeError as e:\n            raise UngueltigesFormatError(\n                f\"Datei kann nicht mit {encoding} gelesen werden. \"\n                f\"Versuche anderes Encoding?\"\n            )\n        \n        except Exception as e:\n            raise DateiLeseError(f\"Unerwarteter Fehler beim Lesen: {e}\")\n    \n    def lese_zeilen(self, dateipfad: str, max_zeilen: Optional[int] = None) -> List[str]:\n        \"\"\"Liest Datei zeilenweise\"\"\"\n        try:\n            inhalt = self.lese_datei(dateipfad)\n            zeilen = inhalt.splitlines()\n            \n            if max_zeilen:\n                zeilen = zeilen[:max_zeilen]\n            \n            return zeilen\n        \n        except DateiLeseError:\n            # Fehler weitergeben\n            raise\n        except Exception as e:\n            raise DateiLeseError(f\"Fehler beim Zeilen-Lesen: {e}\")\n    \n    def lese_json(self, dateipfad: str) -> Dict:\n        \"\"\"Liest JSON-Datei\"\"\"\n        import json\n        \n        try:\n            inhalt = self.lese_datei(dateipfad)\n            daten = json.loads(inhalt)\n            return daten\n        \n        except json.JSONDecodeError as e:\n            raise UngueltigesFormatError(f\"Ung√ºltiges JSON-Format: {e}\")\n        \n        except DateiLeseError:\n            raise\n    \n    def sichere_lesen_mit_fallback(\n        self,\n        dateipfad: str,\n        fallback_pfad: Optional[str] = None\n    ) -> str:\n        \"\"\"\n        Versucht Datei zu lesen, nutzt Fallback bei Fehler\n        \n        Returns:\n            Inhalt oder leerer String\n        \"\"\"\n        try:\n            return self.lese_datei(dateipfad)\n        \n        except FileNotFoundError:\n            if fallback_pfad:\n                print(f\"‚ö†Ô∏è Nutze Fallback: '{fallback_pfad}'\")\n                try:\n                    return self.lese_datei(fallback_pfad)\n                except Exception as e:\n                    print(f\"‚ùå Fallback fehlgeschlagen: {e}\")\n            \n            return \"\"\n        \n        except Exception as e:\n            print(f\"‚ùå Fehler: {e}\")\n            return \"\"\n\n# TESTEN\nprint(\"=\" * 60)\nprint(\"üîß ROBUSTER DATEI-READER TEST\")\nprint(\"=\" * 60)\n\nreader = RobusterDateiReader(max_gr√∂√üe_mb=1)  # 1 MB Limit\n\n# Test-Dateien erstellen\nwith open(\"klein.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Das ist eine kleine Test-Datei.\\n\" * 10)\n\nwith open(\"gro√ü.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"X\" * 2 * 1024 * 1024)  # 2 MB\n\nwith open(\"daten.json\", \"w\", encoding=\"utf-8\") as f:\n    f.write('{\"name\": \"Test\", \"wert\": 123}')\n\nwith open(\"kaputt.json\", \"w\", encoding=\"utf-8\") as f:\n    f.write('{name: kaputt}')  # Ung√ºltiges JSON\n\n# Test 1: Normales Lesen\nprint(\"\\n1Ô∏è‚É£ Test: Normale Datei lesen\")\ntry:\n    inhalt = reader.lese_datei(\"klein.txt\")\n    print(f\"‚úÖ Gelesen: {len(inhalt)} Zeichen\")\nexcept Exception as e:\n    print(f\"‚ùå {type(e).__name__}: {e}\")\n\n# Test 2: Datei zu gro√ü\nprint(\"\\n2Ô∏è‚É£ Test: Zu gro√üe Datei\")\ntry:\n    inhalt = reader.lese_datei(\"gro√ü.txt\")\nexcept DateiZuGro√üError as e:\n    print(f\"‚ùå {type(e).__name__}: {e}\")\n\n# Test 3: Datei existiert nicht\nprint(\"\\n3Ô∏è‚É£ Test: Nicht-existierende Datei\")\ntry:\n    inhalt = reader.lese_datei(\"gibts_nicht.txt\")\nexcept FileNotFoundError as e:\n    print(f\"‚ùå {type(e).__name__}: {e}\")\n\n# Test 4: JSON lesen (OK)\nprint(\"\\n4Ô∏è‚É£ Test: JSON lesen (g√ºltig)\")\ntry:\n    daten = reader.lese_json(\"daten.json\")\n    print(f\"‚úÖ JSON geladen: {daten}\")\nexcept Exception as e:\n    print(f\"‚ùå {type(e).__name__}: {e}\")\n\n# Test 5: JSON lesen (kaputt)\nprint(\"\\n5Ô∏è‚É£ Test: JSON lesen (ung√ºltig)\")\ntry:\n    daten = reader.lese_json(\"kaputt.json\")\nexcept UngueltigesFormatError as e:\n    print(f\"‚ùå {type(e).__name__}: {e}\")\n\n# Test 6: Fallback\nprint(\"\\n6Ô∏è‚É£ Test: Lesen mit Fallback\")\ninhalt = reader.sichere_lesen_mit_fallback(\n    \"nicht_da.txt\",\n    fallback_pfad=\"klein.txt\"\n)\nprint(f\"Resultat: {len(inhalt)} Zeichen geladen\")\n\n# Test 7: Zeilen lesen mit Limit\nprint(\"\\n7Ô∏è‚É£ Test: Erste 5 Zeilen\")\ntry:\n    zeilen = reader.lese_zeilen(\"klein.txt\", max_zeilen=5)\n    print(f\"‚úÖ {len(zeilen)} Zeilen gelesen\")\n    for i, zeile in enumerate(zeilen, 1):\n        print(f\"   {i}. {zeile[:40]}...\")\nexcept Exception as e:\n    print(f\"‚ùå {type(e).__name__}: {e}\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 7,
        "weekId": 2,
        "title": "Eigenes Tool-Modul (Module & Imports)",
        "duration": "10-15 Min",
        "task": {
          "title": "Eigenes Tool-Modul (Module & Imports)",
          "description": "Lerne wie man eigene Module erstellt und Code organisiert!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Module verstehen",
            "goal": "Was sind Module und wie funktionieren Imports",
            "why": "Module sind die Basis f√ºr Code-Organisation. Jedes `.py` File ist ein Modul!",
            "code": "# Python hat 3 Arten von Modulen:\n\n# 1. BUILT-IN MODULE (kommen mit Python)\nimport math\nimport random\nimport datetime\n\nprint(\"Built-in Module:\")\nprint(f\"Pi = {math.pi}\")\nprint(f\"Zufallszahl: {random.randint(1, 10)}\")\nprint(f\"Heute: {datetime.date.today()}\")\n\n# 2. THIRD-PARTY MODULE (installiert mit pip)\n# Beispiele: requests, numpy, pandas\n# Installation: pip install requests\n\n# 3. EIGENE MODULE (deine .py Dateien!)\n\n# VERSCHIEDENE IMPORT-ARTEN:\n\n# Import 1: Ganzes Modul\nimport math\nergebnis = math.sqrt(16)\n\n# Import 2: Spezifische Funktionen\nfrom math import sqrt, pi\nergebnis = sqrt(16)  # Kein math. n√∂tig!\nprint(f\"Pi direkt: {pi}\")\n\n# Import 3: Alles importieren (‚ö†Ô∏è nicht empfohlen!)\nfrom math import *  # Importiert ALLES\n# Warum schlecht? Name-Konflikte m√∂glich!\n\n# Import 4: Mit Alias (Umbenennen)\nimport math as m\nergebnis = m.sqrt(16)\n\nfrom datetime import datetime as dt\njetzt = dt.now()\n\n# Import 5: Mehrere auf einmal\nfrom math import sqrt, ceil, floor, pi\n\n# MODULE PFAD\nimport sys\nprint(\"\\nModule werden gesucht in:\")\nfor pfad in sys.path:\n    print(f\"  - {pfad}\")\n\n# Aktuelles Verzeichnis ist immer dabei!",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Eigenes Modul erstellen",
            "goal": "Erstes eigenes Modul bauen",
            "why": "Code wiederverwenden ohne Copy-Paste!",
            "code": "# Haupt-Programm: main.py\n\n# Methode 1: Ganzes Modul\nimport rechner_utils\n\nprint(\"Mit import rechner_utils:\")\nprint(f\"5 + 3 = {rechner_utils.addiere(5, 3)}\")\nprint(f\"Version: {rechner_utils.VERSION}\")\n\n# Methode 2: Spezifische Funktionen\nfrom rechner_utils import addiere, multipliziere\n\nprint(\"\\nMit from rechner_utils import:\")\nprint(f\"5 + 3 = {addiere(5, 3)}\")\nprint(f\"5 * 3 = {multipliziere(5, 3)}\")\n\n# Methode 3: Mit Alias\nimport rechner_utils as ru\n\nprint(\"\\nMit Alias:\")\nprint(f\"10 ^ 2 = {ru.potenz(10, 2)}\")\n\n# Modul-Info\nprint(f\"\\nModul-Dokumentation:\")\nprint(rechner_utils.__doc__)\n\nprint(f\"\\nVerf√ºgbare Funktionen:\")\nfor name in dir(rechner_utils):\n    if not name.startswith('_'):  # Ignoriere private\n        print(f\"  - {name}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Modul-Package erstellen",
            "goal": "Mehrere Module in einem Package organisieren",
            "why": "Gr√∂√üere Projekte brauchen Struktur!",
            "code": "# Variante 1: Einzelne Module\nfrom mein_projekt import rechner\nfrom mein_projekt import text_utils\n\nprint(rechner.addiere(5, 3))\nprint(text_utils.in_gro√übuchstaben(\"hallo\"))\n\n# Variante 2: Spezifische Funktionen\nfrom mein_projekt.rechner import addiere\nfrom mein_projekt.text_utils import umkehren\n\nprint(addiere(10, 20))\nprint(umkehren(\"Python\"))\n\n# Variante 3: Ganzes Package\nimport mein_projekt\n\n# Dann: mein_projekt.rechner.addiere()",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Praktisches Tool-Modul",
            "goal": "Vollst√§ndiges, n√ºtzliches Utility-Modul",
            "why": "Real-World Beispiel das du wiederverwenden kannst!",
            "code": "# Hauptprogramm\nimport string_tools as st\n\nprint(\"üõ†Ô∏è STRING TOOLS IN AKTION\")\nprint(\"=\" * 60)\n\n# Beispiel 1: E-Mail Validierung\nemails = [\"valid@test.com\", \"invalid\", \"another@example.org\"]\nprint(\"\\nE-Mail Validierung:\")\nfor email in emails:\n    status = \"‚úÖ\" if st.ist_email(email) else \"‚ùå\"\n    print(f\"{status} {email}\")\n\n# Beispiel 2: URL-Slug erstellen\ntitel = \"Mein erster Blog-Post √ºber Python!\"\nslug = st.zu_slug(titel)\nprint(f\"\\nTitel: {titel}\")\nprint(f\"Slug: {slug}\")\n\n# Beispiel 3: Text analysieren\ntext = \"\"\"\nPython ist eine moderne Programmiersprache. Python ist einfach zu lernen.\nViele Entwickler lieben Python. Python wird f√ºr AI, Web, und mehr genutzt.\n\"\"\"\n\nprint(\"\\nüìä Text-Analyse:\")\nstats = st.statistiken(text)\nfor key, value in stats.items():\n    print(f\"  {key}: {value if not isinstance(value, float) else f'{value:.2f}'}\")\n\n# Beispiel 4: Daten extrahieren\nkontakt_text = \"\"\"\nKontakt:\nE-Mail: info@firma.de\nAlternative: support@firma.com\nWebsite: https://firma.de\nFollow us #Python #Coding\n\"\"\"\n\nprint(\"\\nüîç Extrahierte Daten:\")\nprint(f\"E-Mails: {st.extrahiere_emails(kontakt_text)}\")\nprint(f\"URLs: {st.extrahiere_urls(kontakt_text)}\")\nprint(f\"Hashtags: {st.extrahiere_hashtags(kontakt_text)}\")",
            "checkpoint": ""
          }
        ]
      }
    ]
  },
  {
    "id": 3,
    "title": "Woche 3: OOP & Module",
    "subtitle": "OOP & Module",
    "description": "Objektorientierte Programmierung",
    "color": "yellow",
    "days": [
      {
        "id": 1,
        "weekId": 3,
        "title": "Bankkonto-Simulator (Classes Basics)",
        "duration": "10-15 Min",
        "task": {
          "title": "Bankkonto-Simulator (Classes Basics)",
          "description": "Lerne Objektorientierte Programmierung (OOP) indem du ein Bankkonto-System erstellst!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Was sind Classes?",
            "goal": "Verstehen was Classes sind und warum wir sie brauchen",
            "why": "",
            "code": "# OHNE CLASSES (alte Methode):\n# Daten und Funktionen sind getrennt\n\nkonto_name = \"Max M√ºller\"\nkonto_kontostand = 1000.0\nkonto_nummer = \"DE123456\"\n\ndef einzahlen_alt(betrag):\n    global konto_kontostand\n    konto_kontostand += betrag\n\ndef abheben_alt(betrag):\n    global konto_kontostand\n    if konto_kontostand >= betrag:\n        konto_kontostand -= betrag\n        return True\n    return False\n\n# Was wenn wir 100 Konten haben? ü§Ø\n# konto1_name, konto1_kontostand, ...\n# konto2_name, konto2_kontostand, ...\n# Das wird schnell un√ºbersichtlich!\n\n# MIT CLASSES (neue, bessere Methode):\nclass Bankkonto:\n    \"\"\"Ein Bankkonto mit Name, Nummer und Kontostand\"\"\"\n    \n    # __init__ ist der CONSTRUCTOR - wird beim Erstellen aufgerufen\n    def __init__(self, inhaber, kontonummer):\n        \"\"\"Initialisiert ein neues Bankkonto\"\"\"\n        # self = das Objekt selbst\n        # self.variable = Attribut (Eigenschaft) des Objekts\n        self.inhaber = inhaber\n        self.kontonummer = kontonummer\n        self.kontostand = 0.0  # Startwert\n    \n    # Methoden (Funktionen die zum Objekt geh√∂ren)\n    def einzahlen(self, betrag):\n        \"\"\"Zahlt Geld ein\"\"\"\n        if betrag > 0:\n            self.kontostand += betrag\n            print(f\"‚úÖ {betrag}‚Ç¨ eingezahlt. Neuer Stand: {self.kontostand}‚Ç¨\")\n        else:\n            print(\"‚ùå Betrag muss positiv sein!\")\n    \n    def abheben(self, betrag):\n        \"\"\"Hebt Geld ab\"\"\"\n        if betrag > 0:\n            if self.kontostand >= betrag:\n                self.kontostand -= betrag\n                print(f\"‚úÖ {betrag}‚Ç¨ abgehoben. Neuer Stand: {self.kontostand}‚Ç¨\")\n                return True\n            else:\n                print(f\"‚ùå Nicht genug Geld! (Kontostand: {self.kontostand}‚Ç¨)\")\n                return False\n        else:\n            print(\"‚ùå Betrag muss positiv sein!\")\n            return False\n    \n    def kontostand_anzeigen(self):\n        \"\"\"Zeigt den aktuellen Kontostand\"\"\"\n        print(f\"üí∞ Kontostand von {self.inhaber}: {self.kontostand}‚Ç¨\")\n\n# OBJEKTE ERSTELLEN (Instanzen der Klasse)\nprint(\"=\" * 60)\nprint(\"üè¶ BANKKONTO-SYSTEM\")\nprint(\"=\" * 60)\n\n# Erstelle zwei verschiedene Konten\nkonto1 = Bankkonto(\"Anna Schmidt\", \"DE111111\")\nkonto2 = Bankkonto(\"Max M√ºller\", \"DE222222\")\n\n# Jedes Konto hat eigene Daten!\nprint(\"\\nüìù Konten erstellt:\")\nkonto1.kontostand_anzeigen()\nkonto2.kontostand_anzeigen()\n\n# Operationen auf konto1\nprint(\"\\nüí≥ Operationen auf Konto 1 (Anna):\")\nkonto1.einzahlen(500)\nkonto1.einzahlen(300)\nkonto1.abheben(200)\n\n# Operationen auf konto2\nprint(\"\\nüí≥ Operationen auf Konto 2 (Max):\")\nkonto2.einzahlen(1000)\nkonto2.abheben(1500)  # Zu viel!\nkonto2.abheben(500)\n\n# Finale Kontost√§nde\nprint(\"\\nüìä Finale Kontost√§nde:\")\nkonto1.kontostand_anzeigen()\nkonto2.kontostand_anzeigen()",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Attribute und Methoden",
            "goal": "Unterschied zwischen Attributen und Methoden verstehen",
            "why": "",
            "code": "class Auto:\n    \"\"\"Repr√§sentiert ein Auto\"\"\"\n    \n    def __init__(self, marke, modell, baujahr):\n        # ATTRIBUTE (Daten/Eigenschaften)\n        self.marke = marke\n        self.modell = modell\n        self.baujahr = baujahr\n        self.kilometerstand = 0\n        self.tank_inhalt = 50  # Liter\n        self.tank_kapazit√§t = 50\n    \n    # METHODEN (Verhalten/Funktionen)\n    \n    def fahren(self, kilometer):\n        \"\"\"F√§hrt eine bestimmte Strecke\"\"\"\n        verbrauch_pro_km = 0.07  # 7 Liter/100km\n        ben√∂tigt = kilometer * verbrauch_pro_km\n        \n        if ben√∂tigt <= self.tank_inhalt:\n            self.kilometerstand += kilometer\n            self.tank_inhalt -= ben√∂tigt\n            print(f\"üöó {kilometer} km gefahren. Tank: {self.tank_inhalt:.1f}L\")\n        else:\n            print(f\"‚ùå Nicht genug Sprit! Nur {self.tank_inhalt:.1f}L im Tank.\")\n    \n    def tanken(self, liter):\n        \"\"\"Tankt das Auto\"\"\"\n        platz = self.tank_kapazit√§t - self.tank_inhalt\n        \n        if liter <= platz:\n            self.tank_inhalt += liter\n            print(f\"‚õΩ {liter}L getankt. Tank: {self.tank_inhalt:.1f}L\")\n        else:\n            self.tank_inhalt = self.tank_kapazit√§t\n            print(f\"‚õΩ Tank voll! ({self.tank_kapazit√§t}L)\")\n    \n    def info(self):\n        \"\"\"Zeigt Auto-Informationen\"\"\"\n        print(f\"\\nüöó {self.marke} {self.modell} ({self.baujahr})\")\n        print(f\"   Kilometerstand: {self.kilometerstand} km\")\n        print(f\"   Tank: {self.tank_inhalt:.1f}L / {self.tank_kapazit√§t}L\")\n\n# Testen\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üöó AUTO-SIMULATOR\")\nprint(\"=\" * 60)\n\nmein_auto = Auto(\"VW\", \"Golf\", 2020)\nmein_auto.info()\n\nprint(\"\\nüìç Fahre zur Arbeit (30km):\")\nmein_auto.fahren(30)\n\nprint(\"\\nüìç Fahre nach Hause (30km):\")\nmein_auto.fahren(30)\n\nprint(\"\\n‚õΩ Tanken:\")\nmein_auto.tanken(20)\n\nprint(\"\\nüìç Langer Trip (500km):\")\nmein_auto.fahren(500)\n\nmein_auto.info()\n\n# Attribut direkt √§ndern (geht, aber nicht empfohlen!)\nprint(\"\\n‚ö†Ô∏è Direkte Attribut-√Ñnderung (nicht empfohlen):\")\nmein_auto.kilometerstand = 999999  # Betrug! üòà\nmein_auto.info()",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Erweitertes Bankkonto mit Transaktionshistorie",
            "goal": "Komplexere Class mit Listen als Attributen",
            "why": "Attribute k√∂nnen auch Listen, Dicts, andere Objekte sein!",
            "code": "from datetime import datetime\n\nclass Bankkonto:\n    \"\"\"Erweitertes Bankkonto mit Transaktionshistorie\"\"\"\n    \n    def __init__(self, inhaber, kontonummer, startguthaben=0):\n        self.inhaber = inhaber\n        self.kontonummer = kontonummer\n        self.kontostand = startguthaben\n        self.transaktionen = []  # Liste von Transaktionen\n        \n        # Erste Transaktion: Kontoer√∂ffnung\n        if startguthaben > 0:\n            self._transaktion_speichern(\"Kontoer√∂ffnung\", startguthaben)\n    \n    def _transaktion_speichern(self, typ, betrag):\n        \"\"\"\n        Private Methode (beginnt mit _) - sollte nicht von au√üen aufgerufen werden\n        Speichert eine Transaktion\n        \"\"\"\n        transaktion = {\n            'zeitpunkt': datetime.now(),\n            'typ': typ,\n            'betrag': betrag,\n            'kontostand_nach': self.kontostand\n        }\n        self.transaktionen.append(transaktion)\n    \n    def einzahlen(self, betrag, beschreibung=\"Einzahlung\"):\n        \"\"\"Zahlt Geld ein\"\"\"\n        if betrag <= 0:\n            print(\"‚ùå Betrag muss positiv sein!\")\n            return False\n        \n        self.kontostand += betrag\n        self._transaktion_speichern(beschreibung, betrag)\n        print(f\"‚úÖ {betrag:.2f}‚Ç¨ eingezahlt ({beschreibung})\")\n        return True\n    \n    def abheben(self, betrag, beschreibung=\"Abhebung\"):\n        \"\"\"Hebt Geld ab\"\"\"\n        if betrag <= 0:\n            print(\"‚ùå Betrag muss positiv sein!\")\n            return False\n        \n        if self.kontostand >= betrag:\n            self.kontostand -= betrag\n            self._transaktion_speichern(beschreibung, -betrag)  # Negativ!\n            print(f\"‚úÖ {betrag:.2f}‚Ç¨ abgehoben ({beschreibung})\")\n            return True\n        else:\n            print(f\"‚ùå Nicht genug Geld! (Haben: {self.kontostand:.2f}‚Ç¨)\")\n            return False\n    \n    def √ºberweisen(self, empf√§nger, betrag, verwendungszweck=\"√úberweisung\"):\n        \"\"\"√úberweist Geld an anderes Konto\"\"\"\n        if self.abheben(betrag, f\"√úberweisung an {empf√§nger.inhaber}\"):\n            empf√§nger.einzahlen(betrag, f\"√úberweisung von {self.inhaber}\")\n            return True\n        return False\n    \n    def kontoauszug(self, anzahl=10):\n        \"\"\"Zeigt letzte N Transaktionen\"\"\"\n        print(f\"\\n{'=' * 70}\")\n        print(f\"üìÑ KONTOAUSZUG - {self.inhaber}\")\n        print(f\"   Kontonummer: {self.kontonummer}\")\n        print(f\"   Aktueller Stand: {self.kontostand:.2f}‚Ç¨\")\n        print(f\"{'=' * 70}\")\n        \n        if not self.transaktionen:\n            print(\"Keine Transaktionen vorhanden\")\n            return\n        \n        # Letzte N Transaktionen (neueste zuerst)\n        letzte = self.transaktionen[-anzahl:]\n        letzte.reverse()\n        \n        print(f\"\\n{'Datum':<20} {'Typ':<25} {'Betrag':>12} {'Stand':>12}\")\n        print(\"-\" * 70)\n        \n        for t in letzte:\n            datum = t['zeitpunkt'].strftime(\"%d.%m.%Y %H:%M:%S\")\n            betrag_str = f\"{t['betrag']:+.2f}‚Ç¨\"  # + f√ºr positiv, - f√ºr negativ\n            stand_str = f\"{t['kontostand_nach']:.2f}‚Ç¨\"\n            \n            print(f\"{datum:<20} {t['typ']:<25} {betrag_str:>12} {stand_str:>12}\")\n        \n        print(\"-\" * 70)\n    \n    def statistik(self):\n        \"\"\"Zeigt Statistiken √ºber das Konto\"\"\"\n        if not self.transaktionen:\n            print(\"Keine Transaktionen f√ºr Statistik\")\n            return\n        \n        einzahlungen = [t['betrag'] for t in self.transaktionen if t['betrag'] > 0]\n        abhebungen = [abs(t['betrag']) for t in self.transaktionen if t['betrag'] < 0]\n        \n        print(f\"\\nüìä STATISTIK - {self.inhaber}\")\n        print(f\"Transaktionen gesamt: {len(self.transaktionen)}\")\n        print(f\"Einzahlungen: {len(einzahlungen)} (‚àë {sum(einzahlungen):.2f}‚Ç¨)\")\n        print(f\"Abhebungen: {len(abhebungen)} (‚àë {sum(abhebungen):.2f}‚Ç¨)\")\n        \n        if einzahlungen:\n            print(f\"√ò Einzahlung: {sum(einzahlungen)/len(einzahlungen):.2f}‚Ç¨\")\n        if abhebungen:\n            print(f\"√ò Abhebung: {sum(abhebungen)/len(abhebungen):.2f}‚Ç¨\")\n\n# TESTEN\nprint(\"=\" * 70)\nprint(\"üè¶ ERWEITERTES BANKKONTO-SYSTEM\")\nprint(\"=\" * 70)\n\n# Konten erstellen\nanna = Bankkonto(\"Anna Schmidt\", \"DE111111\", startguthaben=1000)\nmax_k = Bankkonto(\"Max M√ºller\", \"DE222222\", startguthaben=500)\n\n# Transaktionen\nprint(\"\\nüí≥ Transaktionen:\")\nanna.einzahlen(500, \"Gehalt\")\nanna.abheben(100, \"Einkaufen\")\nanna.abheben(50, \"Tanken\")\n\nmax_k.einzahlen(200, \"Freelance\")\nmax_k.abheben(150, \"Restaurant\")\n\n# √úberweisung\nprint(\"\\nüí∏ √úberweisung:\")\nanna.√ºberweisen(max_k, 250, \"Miete\")\n\n# Kontoausz√ºge\nanna.kontoauszug(anzahl=5)\nmax_k.kontoauszug(anzahl=5)\n\n# Statistiken\nanna.statistik()\nmax_k.statistik()",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "__str__ und __repr__ - Objekte sch√∂n ausgeben",
            "goal": "Objekte lesbar machen",
            "why": "Ohne `__str__` zeigt `print(objekt)` nur `<__main__.Klasse object at 0x...>`",
            "code": "class Bankkonto:\n    \"\"\"Bankkonto mit sch√∂ner String-Darstellung\"\"\"\n    \n    def __init__(self, inhaber, kontonummer, kontostand=0):\n        self.inhaber = inhaber\n        self.kontonummer = kontonummer\n        self.kontostand = kontostand\n    \n    def __str__(self):\n        \"\"\"\n        Wird bei print() und str() aufgerufen\n        Soll benutzerfreundlich sein\n        \"\"\"\n        return f\"Bankkonto von {self.inhaber} (Kontostand: {self.kontostand:.2f}‚Ç¨)\"\n    \n    def __repr__(self):\n        \"\"\"\n        Wird in der Konsole/Debugger angezeigt\n        Soll eindeutig sein (idealerweise Code um Objekt nachzubauen)\n        \"\"\"\n        return f\"Bankkonto('{self.inhaber}', '{self.kontonummer}', {self.kontostand})\"\n    \n    def einzahlen(self, betrag):\n        self.kontostand += betrag\n    \n    def abheben(self, betrag):\n        if self.kontostand >= betrag:\n            self.kontostand -= betrag\n            return True\n        return False\n\n# Testen\nkonto = Bankkonto(\"Anna\", \"DE123\", 1000)\n\n# Ohne __str__/__repr__ w√ºrde das anzeigen:\n# <__main__.Bankkonto object at 0x7f8b2c3d4e10>\n\n# Mit __str__:\nprint(konto)  # Ruft __str__() auf\n# Ausgabe: Bankkonto von Anna (Kontostand: 1000.00‚Ç¨)\n\n# Mit __repr__:\nprint(repr(konto))  # Ruft __repr__() auf\n# Ausgabe: Bankkonto('Anna', 'DE123', 1000.0)\n\n# In einer Liste:\nkonten = [\n    Bankkonto(\"Anna\", \"DE111\", 1000),\n    Bankkonto(\"Ben\", \"DE222\", 500),\n    Bankkonto(\"Clara\", \"DE333\", 2000)\n]\n\nprint(\"\\nAlle Konten:\")\nfor k in konten:\n    print(k)  # Nutzt __str__\n\nprint(\"\\nRepr-Darstellung:\")\nprint(konten)  # Nutzt __repr__ f√ºr jedes Element\n\n# Weitere Magic Methods (kurzer √úberblick)\nclass ErweitertesBankkonto(Bankkonto):\n    \n    def __len__(self):\n        \"\"\"Wird bei len() aufgerufen\"\"\"\n        return int(self.kontostand)  # Kontostand als \"L√§nge\"\n    \n    def __bool__(self):\n        \"\"\"Wird bei if/bool() aufgerufen\"\"\"\n        return self.kontostand > 0  # True wenn Guthaben\n    \n    def __eq__(self, other):\n        \"\"\"Wird bei == aufgerufen\"\"\"\n        if isinstance(other, Bankkonto):\n            return self.kontonummer == other.kontonummer\n        return False\n\nkonto1 = ErweitertesBankkonto(\"Test\", \"DE123\", 500)\nkonto2 = ErweitertesBankkonto(\"Test2\", \"DE123\", 1000)  # Gleiche Nummer!\n\nprint(f\"\\nlen(konto1): {len(konto1)}\")  # 500\nprint(f\"bool(konto1): {bool(konto1)}\")  # True (hat Guthaben)\n\nleeres_konto = ErweitertesBankkonto(\"Leer\", \"DE999\", 0)\nprint(f\"bool(leeres_konto): {bool(leeres_konto)}\")  # False (kein Guthaben)\n\nprint(f\"konto1 == konto2: {konto1 == konto2}\")  # True (gleiche Nummer)",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 2,
        "weekId": 3,
        "title": "Spielcharakter-System (Classes Advanced)",
        "duration": "10-15 Min",
        "task": {
          "title": "Spielcharakter-System (Classes Advanced)",
          "description": "Lerne fortgeschrittene Class-Konzepte durch ein RPG-Charaktersystem!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Class Variables vs Instance Variables",
            "goal": "Unterschied zwischen Klassen- und Instanz-Variablen verstehen",
            "why": "",
            "code": "class Spieler:\n    \"\"\"Spieler in einem RPG\"\"\"\n    \n    # CLASS VARIABLE - Gilt f√ºr ALLE Spieler\n    anzahl_spieler = 0  # Z√§hlt wie viele Spieler erstellt wurden\n    max_level = 100     # Maximales Level f√ºr alle\n    spiel_version = \"1.0.0\"\n    \n    def __init__(self, name):\n        # INSTANCE VARIABLES - Jeder Spieler hat eigene Werte\n        self.name = name\n        self.level = 1\n        self.hp = 100\n        self.exp = 0\n        \n        # Class Variable erh√∂hen\n        Spieler.anzahl_spieler += 1\n    \n    def __str__(self):\n        return f\"{self.name} (Lv.{self.level}, HP: {self.hp})\"\n    \n    @classmethod  # Decorator f√ºr Class Methods\n    def zeige_statistik(cls):\n        \"\"\"\n        Class Method - arbeitet mit Class Variables\n        cls = die Klasse selbst (wie self, aber f√ºr die Klasse)\n        \"\"\"\n        print(f\"üéÆ Spiel Version: {cls.spiel_version}\")\n        print(f\"üë• Spieler online: {cls.anzahl_spieler}\")\n        print(f\"‚≠ê Max Level: {cls.max_level}\")\n    \n    @staticmethod  # Decorator f√ºr Static Methods\n    def ist_g√ºltiger_name(name):\n        \"\"\"\n        Static Method - braucht weder self noch cls\n        Ist wie eine normale Funktion, geh√∂rt aber zur Klasse\n        \"\"\"\n        return len(name) >= 3 and name.isalnum()\n\n# TESTEN\nprint(\"=\" * 60)\nprint(\"üéÆ CLASS VARIABLES vs INSTANCE VARIABLES\")\nprint(\"=\" * 60)\n\n# Spieler erstellen\nspieler1 = Spieler(\"Anna\")\nspieler2 = Spieler(\"Max\")\nspieler3 = Spieler(\"Lisa\")\n\n# Instance Variables - jeder hat eigene\nprint(\"\\nInstance Variables (individuell):\")\nprint(f\"Spieler 1: {spieler1}\")\nprint(f\"Spieler 2: {spieler2}\")\nprint(f\"Spieler 3: {spieler3}\")\n\nspieler1.hp = 50  # Nur spieler1 betroffen!\nprint(f\"\\nNach HP-√Ñnderung:\")\nprint(f\"Spieler 1 HP: {spieler1.hp}\")\nprint(f\"Spieler 2 HP: {spieler2.hp}\")\n\n# Class Variables - alle teilen\nprint(f\"\\nClass Variable (geteilt):\")\nprint(f\"Anzahl Spieler: {Spieler.anzahl_spieler}\")\nprint(f\"Auch √ºber Instanz: {spieler1.anzahl_spieler}\")\n\n# Class Method aufrufen\nprint(\"\\nüìä Statistik:\")\nSpieler.zeige_statistik()\n\n# Static Method aufrufen\nprint(\"\\n‚úÖ Namen validieren:\")\nnamen = [\"An\", \"Anna123\", \"Max_M√ºller\", \"Clara\"]\nfor name in namen:\n    g√ºltig = \"‚úÖ\" if Spieler.ist_g√ºltiger_name(name) else \"‚ùå\"\n    print(f\"{g√ºltig} {name}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Properties (@property)",
            "goal": "Getter und Setter elegant implementieren",
            "why": "Properties erlauben Kontrolle √ºber Attribut-Zugriff mit normaler Syntax!",
            "code": "class Charakter:\n    \"\"\"RPG-Charakter mit Properties\"\"\"\n    \n    def __init__(self, name, level=1):\n        self.name = name\n        self._level = level  # _ zeigt: \"privates\" Attribut\n        self._hp = 100\n        self._max_hp = 100\n        self._exp = 0\n    \n    # PROPERTY: hp (mit Getter und Setter)\n    @property\n    def hp(self):\n        \"\"\"Getter f√ºr HP\"\"\"\n        return self._hp\n    \n    @hp.setter\n    def hp(self, wert):\n        \"\"\"Setter f√ºr HP - mit Validierung!\"\"\"\n        if wert < 0:\n            self._hp = 0\n        elif wert > self._max_hp:\n            self._hp = self._max_hp\n        else:\n            self._hp = wert\n    \n    # READ-ONLY PROPERTY (nur Getter, kein Setter)\n    @property\n    def ist_am_leben(self):\n        \"\"\"Gibt True zur√ºck wenn HP > 0\"\"\"\n        return self._hp > 0\n    \n    # PROPERTY: level (mit automatischer HP-Anpassung)\n    @property\n    def level(self):\n        return self._level\n    \n    @level.setter\n    def level(self, wert):\n        if wert > self._level:\n            # Level-Up!\n            self._level = wert\n            self._max_hp = 100 + (wert - 1) * 10  # +10 HP pro Level\n            self._hp = self._max_hp  # Volle HP beim Level-Up\n            print(f\"üéâ LEVEL UP! {self.name} ist jetzt Level {wert}!\")\n    \n    # COMPUTED PROPERTY (wird berechnet, nicht gespeichert)\n    @property\n    def hp_prozent(self):\n        \"\"\"HP als Prozentsatz\"\"\"\n        return (self._hp / self._max_hp) * 100\n    \n    @property\n    def hp_bar(self):\n        \"\"\"Visuelle HP-Anzeige\"\"\"\n        filled = int(self.hp_prozent / 10)  # 10 Bl√∂cke\n        empty = 10 - filled\n        return f\"[{'‚ñà' * filled}{'‚ñë' * empty}] {self._hp}/{self._max_hp}\"\n    \n    def schaden_nehmen(self, schaden):\n        \"\"\"Nimmt Schaden\"\"\"\n        self.hp -= schaden  # Nutzt den Setter!\n        print(f\"üí• {self.name} nimmt {schaden} Schaden! HP: {self.hp_bar}\")\n    \n    def heilen(self, menge):\n        \"\"\"Heilt HP\"\"\"\n        self.hp += menge  # Nutzt den Setter!\n        print(f\"üíö {self.name} heilt {menge} HP! HP: {self.hp_bar}\")\n\n# TESTEN\nprint(\"\\n\" + \"=\" * 60)\nprint(\"‚ú® PROPERTIES DEMO\")\nprint(\"=\" * 60)\n\nheld = Charakter(\"Arathorn\")\n\nprint(f\"\\n{held.name} startet:\")\nprint(f\"Level: {held.level}\")\nprint(f\"HP: {held.hp_bar}\")\nprint(f\"Am Leben? {held.ist_am_leben}\")\n\n# Schaden nehmen\nprint(\"\\n‚öîÔ∏è Kampf:\")\nheld.schaden_nehmen(30)\nheld.schaden_nehmen(25)\n\n# Versuche negative HP (wird durch Setter verhindert!)\nprint(\"\\n‚öîÔ∏è Kritischer Treffer:\")\nheld.hp = -50  # Setter setzt auf 0\nprint(f\"HP nach -50: {held.hp}\")  # Zeigt 0\n\n# Heilen\nprint(\"\\nüíö Heilung:\")\nheld.heilen(40)\n\n# Versuche √ºber Maximum (wird durch Setter verhindert!)\nheld.hp = 999  # Setter begrenzt auf max_hp\nprint(f\"HP nach 999: {held.hp}\")\n\n# Level-Up\nprint(\"\\n‚≠ê Level-Up:\")\nheld.level = 5\n\nprint(f\"\\nFinaler Status:\")\nprint(f\"Level: {held.level}\")\nprint(f\"HP: {held.hp_bar}\")\n\n# Versuche read-only zu setzen (Fehler!)\ntry:\n    held.ist_am_leben = False  # Geht nicht!\nexcept AttributeError as e:\n    print(f\"\\n‚ùå Fehler: {e}\")\n    print(\"ist_am_leben ist read-only!\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Vollst√§ndiges RPG-Charakter-System",
            "goal": "Alle Konzepte in einem komplexen System kombinieren",
            "why": "Real-World Beispiel mit allen Features!",
            "code": "from dataclasses import dataclass\nfrom typing import List, Dict\nimport random\n\n@dataclass\nclass Item:\n    \"\"\"Einfaches Item (nutzt dataclass f√ºr weniger Code)\"\"\"\n    name: str\n    typ: str  # 'waffe', 'r√ºstung', 'trank'\n    wert: int\n    \n    def __str__(self):\n        return f\"{self.name} ({self.typ}, +{self.wert})\"\n\nclass Inventar:\n    \"\"\"Inventar f√ºr Items\"\"\"\n    \n    def __init__(self, max_gr√∂√üe=20):\n        self.items: List[Item] = []\n        self.max_gr√∂√üe = max_gr√∂√üe\n    \n    def hinzuf√ºgen(self, item: Item) -> bool:\n        \"\"\"F√ºgt Item hinzu\"\"\"\n        if len(self.items) < self.max_gr√∂√üe:\n            self.items.append(item)\n            print(f\"‚úÖ {item.name} hinzugef√ºgt\")\n            return True\n        else:\n            print(f\"‚ùå Inventar voll!\")\n            return False\n    \n    def entfernen(self, item_name: str) -> bool:\n        \"\"\"Entfernt Item nach Name\"\"\"\n        for item in self.items:\n            if item.name == item_name:\n                self.items.remove(item)\n                print(f\"üóëÔ∏è {item_name} entfernt\")\n                return True\n        return False\n    \n    def finde(self, item_name: str) -> Item:\n        \"\"\"Findet Item nach Name\"\"\"\n        for item in self.items:\n            if item.name.lower() == item_name.lower():\n                return item\n        return None\n    \n    def nach_typ(self, typ: str) -> List[Item]:\n        \"\"\"Gibt alle Items eines Typs zur√ºck\"\"\"\n        return [item for item in self.items if item.typ == typ]\n    \n    def anzeigen(self):\n        \"\"\"Zeigt Inventar\"\"\"\n        if not self.items:\n            print(\"üì¶ Inventar leer\")\n            return\n        \n        print(f\"\\nüì¶ INVENTAR ({len(self.items)}/{self.max_gr√∂√üe}):\")\n        \n        # Gruppiert nach Typ\n        typen = {}\n        for item in self.items:\n            if item.typ not in typen:\n                typen[item.typ] = []\n            typen[item.typ].append(item)\n        \n        for typ, items in typen.items():\n            print(f\"\\n{typ.upper()}:\")\n            for item in items:\n                print(f\"  - {item}\")\n\nclass Charakter:\n    \"\"\"Vollst√§ndiger RPG-Charakter\"\"\"\n    \n    # Class Variables\n    charaktere_erstellt = 0\n    \n    def __init__(self, name: str, klasse: str):\n        self.name = name\n        self.klasse = klasse  # z.B. \"Krieger\", \"Magier\"\n        \n        # Stats\n        self._level = 1\n        self._exp = 0\n        self._exp_f√ºr_next_level = 100\n        \n        # HP/Mana\n        self._max_hp = self._berechne_max_hp()\n        self._hp = self._max_hp\n        self._max_mana = self._berechne_max_mana()\n        self._mana = self._max_mana\n        \n        # Kampf-Stats\n        self._angriff = self._berechne_angriff()\n        self._verteidigung = self._berechne_verteidigung()\n        \n        # Inventar\n        self.inventar = Inventar()\n        \n        # Ausr√ºstung\n        self.waffe: Item = None\n        self.r√ºstung: Item = None\n        \n        Charakter.charaktere_erstellt += 1\n    \n    # === PROPERTIES ===\n    \n    @property\n    def level(self):\n        return self._level\n    \n    @property\n    def hp(self):\n        return self._hp\n    \n    @hp.setter\n    def hp(self, wert):\n        self._hp = max(0, min(wert, self._max_hp))\n    \n    @property\n    def mana(self):\n        return self._mana\n    \n    @mana.setter\n    def mana(self, wert):\n        self._mana = max(0, min(wert, self._max_mana))\n    \n    @property\n    def ist_am_leben(self):\n        return self._hp > 0\n    \n    @property\n    def angriff_total(self):\n        \"\"\"Basis-Angriff + Waffen-Bonus\"\"\"\n        bonus = self.waffe.wert if self.waffe else 0\n        return self._angriff + bonus\n    \n    @property\n    def verteidigung_total(self):\n        \"\"\"Basis-Verteidigung + R√ºstungs-Bonus\"\"\"\n        bonus = self.r√ºstung.wert if self.r√ºstung else 0\n        return self._verteidigung + bonus\n    \n    # === PRIVATE METHODEN ===\n    \n    def _berechne_max_hp(self):\n        \"\"\"Berechnet Max-HP basierend auf Level und Klasse\"\"\"\n        basis = 100\n        pro_level = 15 if self.klasse == \"Krieger\" else 10\n        return basis + (self._level - 1) * pro_level\n    \n    def _berechne_max_mana(self):\n        \"\"\"Berechnet Max-Mana basierend auf Level und Klasse\"\"\"\n        basis = 50\n        pro_level = 15 if self.klasse == \"Magier\" else 5\n        return basis + (self._level - 1) * pro_level\n    \n    def _berechne_angriff(self):\n        \"\"\"Berechnet Basis-Angriff\"\"\"\n        if self.klasse == \"Krieger\":\n            return 15 + self._level * 2\n        elif self.klasse == \"Magier\":\n            return 10 + self._level\n        else:\n            return 12 + self._level\n    \n    def _berechne_verteidigung(self):\n        \"\"\"Berechnet Basis-Verteidigung\"\"\"\n        return 5 + self._level\n    \n    # === √ñFFENTLICHE METHODEN ===\n    \n    def exp_sammeln(self, menge: int):\n        \"\"\"Sammelt EXP und pr√ºft Level-Up\"\"\"\n        self._exp += menge\n        print(f\"‚ú® {menge} EXP gesammelt! ({self._exp}/{self._exp_f√ºr_next_level})\")\n        \n        while self._exp >= self._exp_f√ºr_next_level:\n            self._level_up()\n    \n    def _level_up(self):\n        \"\"\"Level-Up mit Stat-Erh√∂hungen\"\"\"\n        self._level += 1\n        self._exp -= self._exp_f√ºr_next_level\n        self._exp_f√ºr_next_level = int(self._exp_f√ºr_next_level * 1.5)\n        \n        # Stats neu berechnen\n        self._max_hp = self._berechne_max_hp()\n        self._max_mana = self._berechne_max_mana()\n        self._angriff = self._berechne_angriff()\n        self._verteidigung = self._berechne_verteidigung()\n        \n        # Volle HP/Mana beim Level-Up\n        self._hp = self._max_hp\n        self._mana = self._max_mana\n        \n        print(f\"üéâ LEVEL UP! {self.name} ist jetzt Level {self._level}!\")\n        print(f\"   HP: {self._max_hp} | Mana: {self._max_mana}\")\n        print(f\"   Angriff: {self._angriff} | Verteidigung: {self._verteidigung}\")\n    \n    def angreifen(self, gegner: 'Charakter'):\n        \"\"\"Greift einen Gegner an\"\"\"\n        if not self.ist_am_leben:\n            print(f\"‚ùå {self.name} ist tot!\")\n            return\n        \n        # Schaden berechnen\n        basis_schaden = self.angriff_total\n        schaden = max(1, basis_schaden - gegner.verteidigung_total)\n        \n        # Kritischer Treffer? (10% Chance)\n        if random.random() < 0.1:\n            schaden *= 2\n            print(f\"üí• KRITISCHER TREFFER!\")\n        \n        gegner.hp -= schaden\n        print(f\"‚öîÔ∏è {self.name} greift {gegner.name} an! -{schaden} HP\")\n        \n        if not gegner.ist_am_leben:\n            print(f\"üíÄ {gegner.name} wurde besiegt!\")\n            self.exp_sammeln(gegner.level * 50)\n    \n    def heilen(self, menge: int):\n        \"\"\"Heilt HP\"\"\"\n        alt = self._hp\n        self.hp += menge\n        geheilt = self._hp - alt\n        print(f\"üíö {self.name} heilt {geheilt} HP! ({self._hp}/{self._max_hp})\")\n    \n    def ausr√ºsten(self, item_name: str):\n        \"\"\"R√ºstet Item aus Inventar aus\"\"\"\n        item = self.inventar.finde(item_name)\n        \n        if not item:\n            print(f\"‚ùå {item_name} nicht im Inventar!\")\n            return\n        \n        if item.typ == \"waffe\":\n            if self.waffe:\n                self.inventar.hinzuf√ºgen(self.waffe)\n            self.waffe = item\n            self.inventar.entfernen(item_name)\n            print(f\"‚öîÔ∏è {item_name} ausger√ºstet!\")\n            \n        elif item.typ == \"r√ºstung\":\n            if self.r√ºstung:\n                self.inventar.hinzuf√ºgen(self.r√ºstung)\n            self.r√ºstung = item\n            self.inventar.entfernen(item_name)\n            print(f\"üõ°Ô∏è {item_name} ausger√ºstet!\")\n    \n    def status(self):\n        \"\"\"Zeigt Status\"\"\"\n        print(f\"\\n{'=' * 60}\")\n        print(f\"üë§ {self.name} - {self.klasse} (Level {self.level})\")\n        print(f\"{'=' * 60}\")\n        print(f\"‚ù§Ô∏è  HP: {self._hp}/{self._max_hp}\")\n        print(f\"üíô Mana: {self._mana}/{self._max_mana}\")\n        print(f\"‚ú® EXP: {self._exp}/{self._exp_f√ºr_next_level}\")\n        print(f\"‚öîÔ∏è  Angriff: {self.angriff_total} ({self._angriff} + {self.waffe.wert if self.waffe else 0})\")\n        print(f\"üõ°Ô∏è  Verteidigung: {self.verteidigung_total} ({self._verteidigung} + {self.r√ºstung.wert if self.r√ºstung else 0})\")\n        \n        print(f\"\\nüì¶ Ausr√ºstung:\")\n        print(f\"   Waffe: {self.waffe if self.waffe else 'Keine'}\")\n        print(f\"   R√ºstung: {self.r√ºstung if self.r√ºstung else 'Keine'}\")\n    \n    def __str__(self):\n        return f\"{self.name} (Lv.{self.level} {self.klasse})\"\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"üéÆ RPG CHARAKTER-SYSTEM\")\nprint(\"=\" * 60)\n\n# Charakter erstellen\nheld = Charakter(\"Arathorn\", \"Krieger\")\nmagier = Charakter(\"Gandalf\", \"Magier\")\n\n# Status anzeigen\nheld.status()\n\n# Items finden\nprint(\"\\nüéÅ Items gefunden:\")\nschwert = Item(\"Eisenschwert\", \"waffe\", 15)\nr√ºstung = Item(\"Kettenr√ºstung\", \"r√ºstung\", 10)\ntrank = Item(\"Heiltrank\", \"trank\", 50)\n\nheld.inventar.hinzuf√ºgen(schwert)\nheld.inventar.hinzuf√ºgen(r√ºstung)\nheld.inventar.hinzuf√ºgen(trank)\n\n# Inventar anzeigen\nheld.inventar.anzeigen()\n\n# Ausr√ºsten\nprint(\"\\n‚öîÔ∏è Ausr√ºsten:\")\nheld.ausr√ºsten(\"Eisenschwert\")\nheld.ausr√ºsten(\"Kettenr√ºstung\")\n\nheld.status()\n\n# Kampf\nprint(\"\\n‚öîÔ∏è KAMPF:\")\ngoblin = Charakter(\"Goblin\", \"Monster\")\ngoblin._level = 3\ngoblin._hp = 50\ngoblin._angriff = 8\n\nprint(f\"\\n{held} vs {goblin}\")\n\nwhile held.ist_am_leben and goblin.ist_am_leben:\n    held.angreifen(goblin)\n    if goblin.ist_am_leben:\n        goblin.angreifen(held)\n    print()\n\nprint(f\"\\nüèÜ Kampf beendet!\")\nheld.status()",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 3,
        "weekId": 3,
        "title": "Tier-Hierarchie (Vererbung)",
        "duration": "10-15 Min",
        "task": {
          "title": "Tier-Hierarchie (Vererbung)",
          "description": "Lerne Vererbung (Inheritance) - eines der m√§chtigsten OOP-Konzepte!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Vererbung Grundlagen",
            "goal": "Verstehen wie Vererbung funktioniert",
            "why": "",
            "code": "# OHNE VERERBUNG - Code-Duplikation! üò±\nclass Hund:\n    def __init__(self, name):\n        self.name = name\n        self.alter = 0\n    \n    def fressen(self):\n        print(f\"{self.name} frisst\")\n    \n    def schlafen(self):\n        print(f\"{self.name} schl√§ft\")\n    \n    def bellen(self):\n        print(f\"{self.name}: Wuff!\")\n\nclass Katze:\n    def __init__(self, name):\n        self.name = name\n        self.alter = 0\n    \n    def fressen(self):  # Duplikat!\n        print(f\"{self.name} frisst\")\n    \n    def schlafen(self):  # Duplikat!\n        print(f\"{self.name} schl√§ft\")\n    \n    def miauen(self):\n        print(f\"{self.name}: Miau!\")\n\n# MIT VERERBUNG - DRY (Don't Repeat Yourself)! üòä\n\nclass Tier:\n    \"\"\"Basis-Klasse f√ºr alle Tiere\"\"\"\n    \n    def __init__(self, name, art):\n        self.name = name\n        self.art = art\n        self.alter = 0\n    \n    def fressen(self):\n        print(f\"{self.name} ({self.art}) frisst\")\n    \n    def schlafen(self):\n        print(f\"{self.name} ({self.art}) schl√§ft\")\n    \n    def __str__(self):\n        return f\"{self.name} ({self.art}, {self.alter} Jahre alt)\"\n\n# Hund ERBT von Tier\nclass Hund(Tier):  # Tier in Klammern = Parent-Class\n    \"\"\"Spezialisierte Tier-Klasse f√ºr Hunde\"\"\"\n    \n    def __init__(self, name, rasse):\n        # super() ruft Parent-Class-Methode auf\n        super().__init__(name, art=\"Hund\")\n        self.rasse = rasse\n    \n    def bellen(self):\n        \"\"\"Hunde-spezifische Methode\"\"\"\n        print(f\"{self.name}: Wuff! Wuff!\")\n    \n    def apportieren(self):\n        print(f\"{self.name} apportiert den Ball!\")\n\nclass Katze(Tier):\n    \"\"\"Spezialisierte Tier-Klasse f√ºr Katzen\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name, art=\"Katze\")\n    \n    def miauen(self):\n        \"\"\"Katzen-spezifische Methode\"\"\"\n        print(f\"{self.name}: Miau!\")\n    \n    def kratzen(self):\n        print(f\"{self.name} kratzt am Sofa!\")\n\n# TESTEN\nprint(\"=\" * 60)\nprint(\"üêæ VERERBUNG - TIER-HIERARCHIE\")\nprint(\"=\" * 60)\n\n# Erstelle Tiere\nbello = Hund(\"Bello\", \"Golden Retriever\")\nmimi = Katze(\"Mimi\")\n\nprint(f\"\\n{bello}\")\nprint(f\"{mimi}\")\n\n# Gemeinsame Methoden (von Tier geerbt)\nprint(\"\\nüçñ Gemeinsame Aktionen:\")\nbello.fressen()\nmimi.fressen()\n\n# Spezifische Methoden\nprint(\"\\nüîä Spezifische Aktionen:\")\nbello.bellen()\nbello.apportieren()\n\nmimi.miauen()\nmimi.kratzen()\n\n# Instanz-Pr√ºfung\nprint(\"\\nüîç Typ-Pr√ºfung:\")\nprint(f\"bello ist ein Hund? {isinstance(bello, Hund)}\")  # True\nprint(f\"bello ist ein Tier? {isinstance(bello, Tier)}\")  # True!\nprint(f\"bello ist eine Katze? {isinstance(bello, Katze)}\")  # False\n\nprint(f\"mimi ist eine Katze? {isinstance(mimi, Katze)}\")  # True\nprint(f\"mimi ist ein Tier? {isinstance(mimi, Tier)}\")  # True!",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Method Overriding",
            "goal": "Parent-Methoden in Kind-Klasse √ºberschreiben",
            "why": "Spezialisiertes Verhalten f√ºr verschiedene Typen!",
            "code": "class Tier:\n    def __init__(self, name):\n        self.name = name\n    \n    def laut_geben(self):\n        \"\"\"Basis-Implementation - wird √ºberschrieben\"\"\"\n        print(f\"{self.name} macht ein Ger√§usch\")\n    \n    def bewegen(self):\n        print(f\"{self.name} bewegt sich\")\n\nclass Hund(Tier):\n    def laut_geben(self):  # √úBERSCHREIBT Tier.laut_geben()\n        \"\"\"Spezialisierte Version f√ºr Hunde\"\"\"\n        print(f\"{self.name}: Wuff! Wuff!\")\n    \n    def bewegen(self):  # √úBERSCHREIBT und ERWEITERT\n        \"\"\"Ruft Parent-Methode auf UND f√ºgt hinzu\"\"\"\n        super().bewegen()  # Ruft Tier.bewegen() auf\n        print(f\"{self.name} wedelt mit dem Schwanz\")  # Zus√§tzlich\n\nclass Katze(Tier):\n    def laut_geben(self):  # √úBERSCHREIBT\n        print(f\"{self.name}: Miau!\")\n\nclass Vogel(Tier):\n    def laut_geben(self):  # √úBERSCHREIBT\n        print(f\"{self.name}: Piep!\")\n    \n    def bewegen(self):  # KOMPLETT NEU\n        print(f\"{self.name} fliegt durch die Luft\")\n\n# POLYMORPHISMUS - Gleiche Methode, unterschiedliches Verhalten\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üîÑ METHOD OVERRIDING & POLYMORPHISMUS\")\nprint(\"=\" * 60)\n\ntiere = [\n    Hund(\"Bello\"),\n    Katze(\"Mimi\"),\n    Vogel(\"Tweety\")\n]\n\nprint(\"\\nüîä Alle Tiere machen Laute:\")\nfor tier in tiere:\n    tier.laut_geben()  # Jedes ruft SEINE Version auf!\n\nprint(\"\\nüèÉ Alle Tiere bewegen sich:\")\nfor tier in tiere:\n    tier.bewegen()",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Mehrfachvererbung",
            "goal": "Von mehreren Parent-Classes erben",
            "why": "Manchmal braucht man Eigenschaften von mehreren Quellen!",
            "code": "# Mehrere Parent-Classes\n\nclass Schwimmer:\n    \"\"\"Mixin f√ºr schwimmende F√§higkeiten\"\"\"\n    \n    def schwimmen(self):\n        print(f\"{self.name} schwimmt\")\n\nclass Flieger:\n    \"\"\"Mixin f√ºr fliegende F√§higkeiten\"\"\"\n    \n    def fliegen(self):\n        print(f\"{self.name} fliegt\")\n\nclass L√§ufer:\n    \"\"\"Mixin f√ºr laufende F√§higkeiten\"\"\"\n    \n    def laufen(self):\n        print(f\"{self.name} l√§uft\")\n\n# Tier mit einer F√§higkeit\nclass Fisch(Tier, Schwimmer):\n    \"\"\"Erbt von Tier UND Schwimmer\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name)\n\n# Tier mit zwei F√§higkeiten\nclass Ente(Tier, Schwimmer, Flieger):\n    \"\"\"Erbt von Tier, Schwimmer UND Flieger\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name)\n    \n    def quaken(self):\n        print(f\"{self.name}: Quak!\")\n\n# Tier mit drei F√§higkeiten\nclass Pinguin(Tier, Schwimmer, L√§ufer):\n    \"\"\"Kann schwimmen und laufen, aber NICHT fliegen\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name)\n\n# TESTEN\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üåä MEHRFACHVERERBUNG\")\nprint(\"=\" * 60)\n\nnemo = Fisch(\"Nemo\")\ndonald = Ente(\"Donald\")\ntux = Pinguin(\"Tux\")\n\nprint(\"\\nüêü Fisch (nur schwimmen):\")\nnemo.schwimmen()\n# nemo.fliegen()  # Fehler! Fisch kann nicht fliegen\n\nprint(\"\\nü¶Ü Ente (schwimmen + fliegen):\")\ndonald.schwimmen()\ndonald.fliegen()\ndonald.quaken()\n\nprint(\"\\nüêß Pinguin (schwimmen + laufen):\")\ntux.schwimmen()\ntux.laufen()\n# tux.fliegen()  # Fehler! Pinguin kann nicht fliegen\n\n# MRO (Method Resolution Order) - In welcher Reihenfolge werden Parents gesucht?\nprint(\"\\nüìã Method Resolution Order:\")\nprint(f\"Ente MRO: {[cls.__name__ for cls in Ente.__mro__]}\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Vollst√§ndige Tier-Hierarchie",
            "goal": "Komplexes System mit Vererbung aufbauen",
            "why": "Real-World Beispiel mit allen Konzepten!",
            "code": "from abc import ABC, abstractmethod\nfrom typing import List\n\n# ABSTRAKTE BASIS-KLASSE\nclass Tier(ABC):\n    \"\"\"\n    Abstrakte Basis-Klasse f√ºr alle Tiere\n    ABC = Abstract Base Class\n    Kann nicht direkt instanziiert werden!\n    \"\"\"\n    \n    def __init__(self, name: str, alter: int, gewicht: float):\n        self.name = name\n        self.alter = alter\n        self.gewicht = gewicht  # in kg\n        self.hunger = 50  # 0-100\n        self.gesundheit = 100  # 0-100\n    \n    @abstractmethod\n    def laut_geben(self):\n        \"\"\"MUSS von Subklassen implementiert werden!\"\"\"\n        pass\n    \n    @abstractmethod\n    def nahrung(self) -> str:\n        \"\"\"MUSS von Subklassen implementiert werden!\"\"\"\n        pass\n    \n    def fressen(self, menge: int = 30):\n        \"\"\"Gemeinsame Methode f√ºr alle Tiere\"\"\"\n        self.hunger = max(0, self.hunger - menge)\n        print(f\"{self.name} frisst {self.nahrung()}. Hunger: {self.hunger}\")\n    \n    def altern(self):\n        \"\"\"Altert um 1 Jahr\"\"\"\n        self.alter += 1\n        self.gesundheit = max(0, self.gesundheit - 5)\n        print(f\"{self.name} ist jetzt {self.alter} Jahre alt\")\n    \n    def status(self):\n        \"\"\"Zeigt Status\"\"\"\n        print(f\"\\n{'='*50}\")\n        print(f\"üêæ {self.name} ({self.__class__.__name__})\")\n        print(f\"{'='*50}\")\n        print(f\"Alter: {self.alter} Jahre\")\n        print(f\"Gewicht: {self.gewicht} kg\")\n        print(f\"Hunger: {self.hunger}/100\")\n        print(f\"Gesundheit: {self.gesundheit}/100\")\n    \n    def __str__(self):\n        return f\"{self.name} ({self.__class__.__name__}, {self.alter}J)\"\n\n# S√ÑUGETIERE\nclass S√§ugetier(Tier):\n    \"\"\"Basis f√ºr alle S√§ugetiere\"\"\"\n    \n    def __init__(self, name, alter, gewicht, fellfarbe):\n        super().__init__(name, alter, gewicht)\n        self.fellfarbe = fellfarbe\n    \n    def s√§ugen(self):\n        print(f\"{self.name} s√§ugt ihre Jungen\")\n\nclass Hund(S√§ugetier):\n    def __init__(self, name, alter, gewicht, fellfarbe, rasse):\n        super().__init__(name, alter, gewicht, fellfarbe)\n        self.rasse = rasse\n        self.loyalit√§t = 100\n    \n    def laut_geben(self):\n        print(f\"{self.name}: Wuff! Wuff!\")\n    \n    def nahrung(self) -> str:\n        return \"Hundefutter\"\n    \n    def apportieren(self):\n        self.loyalit√§t = min(100, self.loyalit√§t + 5)\n        print(f\"{self.name} apportiert! Loyalit√§t: {self.loyalit√§t}\")\n\nclass Katze(S√§ugetier):\n    def __init__(self, name, alter, gewicht, fellfarbe):\n        super().__init__(name, alter, gewicht, fellfarbe)\n        self.unabh√§ngigkeit = 80\n    \n    def laut_geben(self):\n        print(f\"{self.name}: Miau!\")\n    \n    def nahrung(self) -> str:\n        return \"Katzenfutter\"\n    \n    def schnurren(self):\n        print(f\"{self.name} schnurrt zufrieden\")\n\n# V√ñGEL\nclass Vogel(Tier):\n    \"\"\"Basis f√ºr alle V√∂gel\"\"\"\n    \n    def __init__(self, name, alter, gewicht, kann_fliegen=True):\n        super().__init__(name, alter, gewicht)\n        self.kann_fliegen = kann_fliegen\n        self.fl√ºgelspannweite = gewicht * 0.3  # Vereinfacht\n    \n    def nahrung(self) -> str:\n        return \"K√∂rner\"\n    \n    def fliegen(self):\n        if self.kann_fliegen:\n            print(f\"{self.name} fliegt durch die Luft\")\n        else:\n            print(f\"{self.name} kann nicht fliegen!\")\n\nclass Papagei(Vogel):\n    def __init__(self, name, alter, gewicht):\n        super().__init__(name, alter, gewicht, kann_fliegen=True)\n        self.vokabular = []\n    \n    def laut_geben(self):\n        if self.vokabular:\n            import random\n            wort = random.choice(self.vokabular)\n            print(f\"{self.name}: {wort}!\")\n        else:\n            print(f\"{self.name}: Kr√§chz!\")\n    \n    def wort_lernen(self, wort: str):\n        self.vokabular.append(wort)\n        print(f\"{self.name} hat '{wort}' gelernt!\")\n\nclass Pinguin(Vogel):\n    def __init__(self, name, alter, gewicht):\n        super().__init__(name, alter, gewicht, kann_fliegen=False)\n    \n    def laut_geben(self):\n        print(f\"{self.name}: Gack!\")\n    \n    def nahrung(self) -> str:\n        return \"Fisch\"\n    \n    def schwimmen(self):\n        print(f\"{self.name} schwimmt elegant durch das Wasser\")\n\n# ZOO-VERWALTUNG\nclass Zoo:\n    \"\"\"Verwaltet eine Sammlung von Tieren\"\"\"\n    \n    def __init__(self, name: str):\n        self.name = name\n        self.tiere: List[Tier] = []\n    \n    def tier_hinzuf√ºgen(self, tier: Tier):\n        self.tiere.append(tier)\n        print(f\"‚úÖ {tier} wurde dem Zoo hinzugef√ºgt\")\n    \n    def alle_f√ºttern(self):\n        print(f\"\\nüçñ F√ºtterungszeit im {self.name}!\")\n        for tier in self.tiere:\n            tier.fressen()\n    \n    def konzert(self):\n        print(f\"\\nüéµ Tier-Konzert im {self.name}!\")\n        for tier in self.tiere:\n            tier.laut_geben()\n    \n    def tiere_nach_typ(self, typ):\n        \"\"\"Filtert Tiere nach Typ\"\"\"\n        return [t for t in self.tiere if isinstance(t, typ)]\n    \n    def statistik(self):\n        \"\"\"Zeigt Zoo-Statistiken\"\"\"\n        print(f\"\\nüìä {self.name} - STATISTIK\")\n        print(f\"{'='*50}\")\n        print(f\"Tiere gesamt: {len(self.tiere)}\")\n        \n        # Nach Typ gruppieren\n        typen = {}\n        for tier in self.tiere:\n            typ_name = tier.__class__.__name__\n            typen[typ_name] = typen.get(typ_name, 0) + 1\n        \n        print(\"\\nNach Typ:\")\n        for typ, anzahl in sorted(typen.items()):\n            print(f\"  {typ}: {anzahl}\")\n        \n        # √Ñltestes/J√ºngstes\n        if self.tiere:\n            √§ltestes = max(self.tiere, key=lambda t: t.alter)\n            j√ºngstes = min(self.tiere, key=lambda t: t.alter)\n            print(f\"\\n√Ñltestes: {√§ltestes.name} ({√§ltestes.alter}J)\")\n            print(f\"J√ºngstes: {j√ºngstes.name} ({j√ºngstes.alter}J)\")\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"ü¶Å ZOO-SIMULATOR MIT VERERBUNG\")\nprint(\"=\" * 60)\n\n# Zoo erstellen\nmein_zoo = Zoo(\"Tierpark Berlin\")\n\n# Tiere erstellen\nbello = Hund(\"Bello\", 5, 25, \"braun\", \"Golden Retriever\")\nmimi = Katze(\"Mimi\", 3, 4, \"orange\")\ntweety = Papagei(\"Tweety\", 2, 0.5)\ntux = Pinguin(\"Tux\", 4, 15)\n\n# Zum Zoo hinzuf√ºgen\nmein_zoo.tier_hinzuf√ºgen(bello)\nmein_zoo.tier_hinzuf√ºgen(mimi)\nmein_zoo.tier_hinzuf√ºgen(tweety)\nmein_zoo.tier_hinzuf√ºgen(tux)\n\n# Papagei trainieren\nprint(\"\\nü¶ú Papagei-Training:\")\ntweety.wort_lernen(\"Hallo\")\ntweety.wort_lernen(\"Python\")\ntweety.wort_lernen(\"Lernen\")\n\n# Tier-Konzert\nmein_zoo.konzert()\n\n# F√ºttern\nmein_zoo.alle_f√ºttern()\n\n# Spezielle Aktionen\nprint(\"\\nüéæ Spezielle Aktionen:\")\nbello.apportieren()\nmimi.schnurren()\ntweety.fliegen()\ntux.schwimmen()\ntux.fliegen()  # Pinguin kann nicht fliegen!\n\n# Statistiken\nmein_zoo.statistik()\n\n# Nur S√§ugetiere\nprint(\"\\nüêæ Nur S√§ugetiere:\")\ns√§ugetiere = mein_zoo.tiere_nach_typ(S√§ugetier)\nfor s in s√§ugetiere:\n    print(f\"  - {s}\")\n\n# Status einzelnes Tier\nbello.status()",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 4,
        "weekId": 3,
        "title": "Ordner-Organizer (OS-Modul)",
        "duration": "10-15 Min",
        "task": {
          "title": "Ordner-Organizer (OS-Modul)",
          "description": "Lerne das OS-Modul kennen und erstelle einen automatischen Ordner-Organizer!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "OS-Modul Grundlagen",
            "goal": "Verstehen wie man mit dem Betriebssystem interagiert",
            "why": "Datei- und Ordner-Operationen sind essentiell f√ºr praktische Programme!",
            "code": "import os\n\nprint(\"=\" * 60)\nprint(\"üìÅ OS-MODUL GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# AKTUELLES VERZEICHNIS\naktuell = os.getcwd()  # Get Current Working Directory\nprint(f\"\\nüìç Aktuelles Verzeichnis:\\n{aktuell}\")\n\n# VERZEICHNIS WECHSELN (Vorsicht!)\n# os.chdir(\"/pfad/zum/ordner\")  # Change Directory\n\n# DATEIEN UND ORDNER AUFLISTEN\nprint(f\"\\nüìÇ Inhalt des aktuellen Verzeichniss:\")\ninhalt = os.listdir()  # Listet alles auf\nfor item in inhalt[:10]:  # Nur erste 10\n    print(f\"  - {item}\")\n\n# PFADE ZUSAMMENBAUEN (WICHTIG: Funktioniert auf allen OS!)\n# Windows: \\ (Backslash)\n# Mac/Linux: / (Forward slash)\n# os.path.join() macht es automatisch richtig!\n\n# FALSCH (funktioniert nur auf einem OS):\n# pfad = \"ordner1\\ordner2\\datei.txt\"  # Nur Windows\n\n# RICHTIG (funktioniert √ºberall):\npfad = os.path.join(\"ordner1\", \"ordner2\", \"datei.txt\")\nprint(f\"\\nüîó Zusammengesetzter Pfad:\\n{pfad}\")\n\n# PFAD-INFORMATIONEN\nbeispiel_datei = __file__  # Aktuelles Script\n\nprint(f\"\\nüìÑ Pfad-Analyse von '{os.path.basename(beispiel_datei)}':\")\nprint(f\"Kompletter Pfad: {os.path.abspath(beispiel_datei)}\")\nprint(f\"Verzeichnis: {os.path.dirname(beispiel_datei)}\")\nprint(f\"Dateiname: {os.path.basename(beispiel_datei)}\")\nprint(f\"Ohne Endung: {os.path.splitext(beispiel_datei)[0]}\")\nprint(f\"Nur Endung: {os.path.splitext(beispiel_datei)[1]}\")\n\n# PR√úFUNGEN\nprint(f\"\\n‚úÖ Existenz-Pr√ºfungen:\")\nprint(f\"Datei existiert? {os.path.exists(beispiel_datei)}\")\nprint(f\"Ist Datei? {os.path.isfile(beispiel_datei)}\")\nprint(f\"Ist Ordner? {os.path.isdir(beispiel_datei)}\")\n\n# Test-Ordner pr√ºfen\nprint(f\"\\nAktuelles Verzeichnis ist Ordner? {os.path.isdir(aktuell)}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Ordner und Dateien erstellen/l√∂schen",
            "goal": "Dateisystem manipulieren",
            "why": "Programme m√ºssen oft Ordner erstellen, Dateien verschieben, etc.!",
            "code": "import os\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üìÅ DATEISYSTEM MANIPULIEREN\")\nprint(\"=\" * 60)\n\n# Test-Verzeichnis erstellen\ntest_ordner = \"test_os_operationen\"\n\n# ORDNER ERSTELLEN\nif not os.path.exists(test_ordner):\n    os.mkdir(test_ordner)  # Erstellt einen Ordner\n    print(f\"‚úÖ Ordner '{test_ordner}' erstellt\")\nelse:\n    print(f\"‚ÑπÔ∏è Ordner '{test_ordner}' existiert bereits\")\n\n# VERSCHACHTELTE ORDNER ERSTELLEN\n# mkdir() schl√§gt fehl wenn Parent nicht existiert\n# makedirs() erstellt alle fehlenden Parents\n\nverschachtelt = os.path.join(test_ordner, \"sub1\", \"sub2\", \"sub3\")\nos.makedirs(verschachtelt, exist_ok=True)  # exist_ok=True verhindert Fehler wenn existiert\nprint(f\"‚úÖ Verschachtelte Ordner erstellt: {verschachtelt}\")\n\n# DATEI ERSTELLEN\ntest_datei = os.path.join(test_ordner, \"test.txt\")\nwith open(test_datei, \"w\") as f:\n    f.write(\"Test-Inhalt\")\nprint(f\"‚úÖ Datei erstellt: {test_datei}\")\n\n# DATEI UMBENENNEN\nalter_name = test_datei\nneuer_name = os.path.join(test_ordner, \"umbenannt.txt\")\nos.rename(alter_name, neuer_name)\nprint(f\"‚úÖ Umbenannt: {os.path.basename(alter_name)} ‚Üí {os.path.basename(neuer_name)}\")\n\n# DATEI-INFORMATIONEN\nprint(f\"\\nüìä Datei-Info f√ºr '{os.path.basename(neuer_name)}':\")\nstats = os.stat(neuer_name)\nprint(f\"Gr√∂√üe: {stats.st_size} Bytes\")\nprint(f\"Erstellt: {stats.st_ctime}\")\nprint(f\"Ge√§ndert: {stats.st_mtime}\")\n\n# ALLE DATEIEN IN EINEM ORDNER\nprint(f\"\\nüìÇ Alle Dateien in '{test_ordner}':\")\nfor item in os.listdir(test_ordner):\n    pfad = os.path.join(test_ordner, item)\n    typ = \"üìÅ\" if os.path.isdir(pfad) else \"üìÑ\"\n    print(f\"{typ} {item}\")\n\n# ORDNER REKURSIV DURCHLAUFEN\nprint(f\"\\nüîç Rekursive Suche in '{test_ordner}':\")\nfor root, dirs, files in os.walk(test_ordner):\n    # root = aktueller Ordner\n    # dirs = Liste von Unterordnern\n    # files = Liste von Dateien\n    ebene = root.replace(test_ordner, \"\").count(os.sep)\n    einr√ºckung = \"  \" * ebene\n    print(f\"{einr√ºckung}üìÅ {os.path.basename(root)}/\")\n    \n    sub_einr√ºckung = \"  \" * (ebene + 1)\n    for datei in files:\n        print(f\"{sub_einr√ºckung}üìÑ {datei}\")\n\n# AUFR√ÑUMEN (VORSICHTIG!)\n# NICHT AUSF√úHREN wenn du Daten behalten willst!\nprint(\"\\nüßπ Aufr√§umen...\")\n\n# Datei l√∂schen\nif os.path.exists(neuer_name):\n    os.remove(neuer_name)  # L√∂scht Datei\n    print(f\"üóëÔ∏è Datei gel√∂scht: {os.path.basename(neuer_name)}\")\n\n# Leeren Ordner l√∂schen\nif os.path.exists(verschachtelt):\n    os.rmdir(verschachtelt)  # L√∂scht nur LEERE Ordner\n    print(f\"üóëÔ∏è Ordner gel√∂scht: {os.path.basename(verschachtelt)}\")\n\n# Ordner mit Inhalt l√∂schen (gef√§hrlich!)\n# import shutil\n# shutil.rmtree(test_ordner)  # L√∂scht ALLES rekursiv!",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Ordner-Organizer nach Dateityp",
            "goal": "Praktisches Tool das Dateien nach Typ sortiert",
            "why": "Automatisiere das Aufr√§umen deines Downloads-Ordners!",
            "code": "import os\nimport shutil\nfrom collections import defaultdict\n\nclass OrdnerOrganizer:\n    \"\"\"Organisiert Dateien in einem Ordner nach Dateityp\"\"\"\n    \n    # Dateityp-Kategorien\n    KATEGORIEN = {\n        'Bilder': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp'],\n        'Dokumente': ['.pdf', '.doc', '.docx', '.txt', '.xlsx', '.pptx', '.odt'],\n        'Videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv'],\n        'Musik': ['.mp3', '.wav', '.flac', '.m4a', '.aac'],\n        'Archive': ['.zip', '.rar', '.7z', '.tar', '.gz'],\n        'Code': ['.py', '.js', '.html', '.css', '.java', '.cpp', '.c'],\n        'Sonstiges': []  # Alles andere\n    }\n    \n    def __init__(self, quell_ordner):\n        self.quell_ordner = os.path.abspath(quell_ordner)\n        \n        if not os.path.exists(self.quell_ordner):\n            raise FileNotFoundError(f\"Ordner nicht gefunden: {self.quell_ordner}\")\n    \n    def _ermittle_kategorie(self, dateiname):\n        \"\"\"Bestimmt Kategorie basierend auf Dateierweiterung\"\"\"\n        _, erweiterung = os.path.splitext(dateiname)\n        erweiterung = erweiterung.lower()\n        \n        for kategorie, erweiterungen in self.KATEGORIEN.items():\n            if erweiterung in erweiterungen:\n                return kategorie\n        \n        return 'Sonstiges'\n    \n    def analysieren(self):\n        \"\"\"Analysiert Ordner und zeigt Statistiken\"\"\"\n        stats = defaultdict(list)\n        \n        for item in os.listdir(self.quell_ordner):\n            pfad = os.path.join(self.quell_ordner, item)\n            \n            # Nur Dateien, keine Ordner\n            if os.path.isfile(pfad):\n                kategorie = self._ermittle_kategorie(item)\n                gr√∂√üe = os.path.getsize(pfad)\n                stats[kategorie].append({\n                    'name': item,\n                    'gr√∂√üe': gr√∂√üe,\n                    'pfad': pfad\n                })\n        \n        return stats\n    \n    def bericht(self):\n        \"\"\"Zeigt Analyse-Bericht\"\"\"\n        stats = self.analysieren()\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"üìä ORDNER-ANALYSE: {os.path.basename(self.quell_ordner)}\")\n        print(f\"{'='*60}\")\n        \n        gesamt_dateien = sum(len(dateien) for dateien in stats.values())\n        gesamt_gr√∂√üe = sum(\n            d['gr√∂√üe'] for dateien in stats.values() for d in dateien\n        )\n        \n        print(f\"\\nDateien gesamt: {gesamt_dateien}\")\n        print(f\"Gesamtgr√∂√üe: {gesamt_gr√∂√üe / 1024 / 1024:.2f} MB\")\n        \n        print(f\"\\n{'Kategorie':<15} {'Anzahl':>8} {'Gr√∂√üe (MB)':>12}\")\n        print(\"-\" * 60)\n        \n        for kategorie, dateien in sorted(stats.items()):\n            if dateien:\n                anzahl = len(dateien)\n                gr√∂√üe = sum(d['gr√∂√üe'] for d in dateien) / 1024 / 1024\n                print(f\"{kategorie:<15} {anzahl:>8} {gr√∂√üe:>12.2f}\")\n        \n        return stats\n    \n    def organisieren(self, modus='kopieren', test_lauf=False):\n        \"\"\"\n        Organisiert Dateien in Unterordner nach Kategorie\n        \n        Args:\n            modus: 'kopieren' oder 'verschieben'\n            test_lauf: Wenn True, nur simulieren ohne √Ñnderungen\n        \"\"\"\n        stats = self.analysieren()\n        \n        if test_lauf:\n            print(f\"\\n{'='*60}\")\n            print(f\"üß™ TEST-LAUF (keine √Ñnderungen)\")\n            print(f\"{'='*60}\")\n        else:\n            print(f\"\\n{'='*60}\")\n            print(f\"üóÇÔ∏è ORGANISIERE ORDNER ({modus})\")\n            print(f\"{'='*60}\")\n        \n        √§nderungen = 0\n        \n        for kategorie, dateien in stats.items():\n            if not dateien:\n                continue\n            \n            # Ziel-Ordner erstellen\n            ziel_ordner = os.path.join(self.quell_ordner, kategorie)\n            \n            if not test_lauf:\n                os.makedirs(ziel_ordner, exist_ok=True)\n            \n            print(f\"\\nüìÅ {kategorie}:\")\n            \n            for datei_info in dateien:\n                quelle = datei_info['pfad']\n                ziel = os.path.join(ziel_ordner, datei_info['name'])\n                \n                # Pr√ºfe ob Datei bereits im Ziel-Ordner ist\n                if os.path.dirname(quelle) == ziel_ordner:\n                    continue\n                \n                print(f\"  {'‚Üí' if modus == 'verschieben' else 'üìã'} {datei_info['name']}\")\n                \n                if not test_lauf:\n                    try:\n                        if modus == 'verschieben':\n                            shutil.move(quelle, ziel)\n                        else:  # kopieren\n                            shutil.copy2(quelle, ziel)\n                        \n                        √§nderungen += 1\n                    except Exception as e:\n                        print(f\"    ‚ùå Fehler: {e}\")\n        \n        if test_lauf:\n            print(f\"\\nüí° {√§nderungen} Dateien w√ºrden organisiert werden\")\n            print(\"F√ºhre mit test_lauf=False aus um tats√§chlich zu organisieren\")\n        else:\n            print(f\"\\n‚úÖ {√§nderungen} Dateien {modus}t\")\n    \n    def duplikate_finden(self):\n        \"\"\"Findet Duplikate basierend auf Dateinamen\"\"\"\n        dateien = {}\n        duplikate = []\n        \n        for item in os.listdir(self.quell_ordner):\n            pfad = os.path.join(self.quell_ordner, item)\n            \n            if os.path.isfile(pfad):\n                name = os.path.splitext(item)[0].lower()\n                \n                if name in dateien:\n                    duplikate.append((dateien[name], pfad))\n                else:\n                    dateien[name] = pfad\n        \n        if duplikate:\n            print(f\"\\n{'='*60}\")\n            print(f\"üîç DUPLIKATE GEFUNDEN\")\n            print(f\"{'='*60}\")\n            \n            for original, duplikat in duplikate:\n                print(f\"\\nüìÑ {os.path.basename(original)}\")\n                print(f\"  ‚Ü≥ {os.path.basename(duplikat)}\")\n        else:\n            print(\"\\n‚úÖ Keine Duplikate gefunden\")\n        \n        return duplikate\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"üìÅ ORDNER-ORGANIZER\")\nprint(\"=\" * 60)\n\n# Test-Umgebung erstellen\ntest_ordner = \"test_organizer\"\nos.makedirs(test_ordner, exist_ok=True)\n\n# Test-Dateien erstellen\ntest_dateien = [\n    \"dokument.pdf\",\n    \"foto1.jpg\",\n    \"foto2.png\",\n    \"musik.mp3\",\n    \"video.mp4\",\n    \"code.py\",\n    \"archiv.zip\",\n    \"notizen.txt\",\n    \"bild.gif\",\n    \"song.wav\"\n]\n\nprint(\"\\nüìù Erstelle Test-Dateien...\")\nfor datei in test_dateien:\n    pfad = os.path.join(test_ordner, datei)\n    with open(pfad, \"w\") as f:\n        f.write(f\"Test-Inhalt f√ºr {datei}\")\n\n# Organizer erstellen\norganizer = OrdnerOrganizer(test_ordner)\n\n# Analyse\norganizer.bericht()\n\n# Test-Lauf (simulieren)\norganizer.organisieren(test_lauf=True)\n\n# Wirklich organisieren?\nprint(\"\\n\" + \"=\"*60)\nantwort = input(\"Wirklich organisieren? (j/n): \")\nif antwort.lower() == 'j':\n    organizer.organisieren(modus='verschieben', test_lauf=False)\n    \n    # Nach dem Organisieren nochmal analysieren\n    print(\"\\nüìä Analyse nach Organisierung:\")\n    organizer.bericht()",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 5,
        "weekId": 3,
        "title": "Datei-Scanner (Pathlib)",
        "duration": "10-15 Min",
        "task": {
          "title": "Datei-Scanner (Pathlib)",
          "description": "Lerne Pathlib kennen - die moderne Alternative zu os.path!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Pathlib Grundlagen",
            "goal": "Verstehen warum Pathlib besser als os.path ist",
            "why": "",
            "code": "from pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"üõ§Ô∏è PATHLIB - MODERNE PFAD-OPERATIONEN\")\nprint(\"=\" * 60)\n\n# Path-Objekt erstellen\n# Verschiedene Methoden:\n\n# 1. Aktuelles Verzeichnis\naktuell = Path.cwd()  # Current Working Directory\nprint(f\"\\nüìç Aktuelles Verzeichnis:\\n{aktuell}\")\n\n# 2. Home-Verzeichnis des Benutzers\nhome = Path.home()\nprint(f\"\\nüè† Home-Verzeichnis:\\n{home}\")\n\n# 3. Pfad aus String\npfad = Path(\"ordner/unterordner/datei.txt\")\nprint(f\"\\nüìÑ Pfad-Objekt:\\n{pfad}\")\n\n# 4. Pfade kombinieren mit / Operator (!)\n# Das ist VIEL eleganter als os.path.join()!\nbasis = Path(\"projekte\")\nprojekt = basis / \"python\" / \"mein_script.py\"\nprint(f\"\\nüîó Kombiniert mit / Operator:\\n{projekt}\")\n\n# PFAD-EIGENSCHAFTEN (als Attribute, nicht Funktionen!)\nbeispiel = Path(\"/home/user/dokumente/bericht.pdf\")\n\nprint(f\"\\nüìä Pfad-Eigenschaften:\")\nprint(f\"Name: {beispiel.name}\")              # bericht.pdf\nprint(f\"Stamm (stem): {beispiel.stem}\")      # bericht\nprint(f\"Suffix: {beispiel.suffix}\")          # .pdf\nprint(f\"Suffixe: {beispiel.suffixes}\")       # ['.pdf']\nprint(f\"Parent: {beispiel.parent}\")          # /home/user/dokumente\nprint(f\"Parents: {list(beispiel.parents)}\")  # Alle Parent-Ordner\nprint(f\"Anchor: {beispiel.anchor}\")          # / (Wurzel)\nprint(f\"Parts: {beispiel.parts}\")            # Alle Teile als Tupel\n\n# VERGLEICH: os.path vs Pathlib\nimport os\n\nprint(f\"\\n{'='*60}\")\nprint(\"VERGLEICH: os.path vs Pathlib\")\nprint(f\"{'='*60}\")\n\ndatei = \"test.txt\"\n\n# Mit os.path (alte Methode)\nos_pfad = os.path.join(\"ordner\", \"unterordner\", datei)\nos_name = os.path.basename(os_pfad)\nos_ohne_ext = os.path.splitext(os_pfad)[0]\n\nprint(\"\\nüìÅ os.path:\")\nprint(f\"Pfad: {os_pfad}\")\nprint(f\"Name: {os_name}\")\nprint(f\"Ohne Ext: {os_ohne_ext}\")\n\n# Mit Pathlib (neue Methode)\np_pfad = Path(\"ordner\") / \"unterordner\" / datei\np_name = p_pfad.name\np_ohne_ext = p_pfad.stem\n\nprint(\"\\nüìÅ Pathlib:\")\nprint(f\"Pfad: {p_pfad}\")\nprint(f\"Name: {p_name}\")\nprint(f\"Ohne Ext: {p_ohne_ext}\")\n\n# Welche ist lesbarer? Pathlib! üòä",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Dateisystem-Operationen mit Pathlib",
            "goal": "Dateien und Ordner mit Pathlib manipulieren",
            "why": "Pathlib kann fast alles was os kann - nur eleganter!",
            "code": "from pathlib import Path\nimport time\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üîß DATEISYSTEM-OPERATIONEN MIT PATHLIB\")\nprint(\"=\" * 60)\n\n# Test-Umgebung\ntest_basis = Path(\"test_pathlib\")\ntest_basis.mkdir(exist_ok=True)  # Ordner erstellen\nprint(f\"‚úÖ Basis-Ordner erstellt: {test_basis}\")\n\n# VERSCHACHTELTE ORDNER\ntief = test_basis / \"ebene1\" / \"ebene2\" / \"ebene3\"\ntief.mkdir(parents=True, exist_ok=True)  # parents=True wie os.makedirs()\nprint(f\"‚úÖ Verschachtelte Ordner: {tief}\")\n\n# DATEIEN ERSTELLEN\ndateien = [\n    test_basis / \"dokument.txt\",\n    test_basis / \"bild.jpg\",\n    test_basis / \"daten.json\",\n    tief / \"tief.txt\"\n]\n\nfor datei in dateien:\n    datei.write_text(f\"Inhalt von {datei.name}\")  # Schreibt Text\n    print(f\"‚úÖ Datei erstellt: {datei.name}\")\n\n# EXISTENZ PR√úFEN\nprint(f\"\\n‚úÖ Existenz-Pr√ºfungen:\")\nprint(f\"Basis existiert? {test_basis.exists()}\")\nprint(f\"Ist Ordner? {test_basis.is_dir()}\")\nprint(f\"Ist Datei? {test_basis.is_file()}\")\n\ntest_datei = test_basis / \"dokument.txt\"\nprint(f\"\\n'{test_datei.name}' existiert? {test_datei.exists()}\")\nprint(f\"Ist Datei? {test_datei.is_file()}\")\n\n# DATEI LESEN/SCHREIBEN\nprint(f\"\\nüìù Datei-Operationen:\")\n\n# Schreiben\ntest_datei.write_text(\"Neuer Inhalt!\")\nprint(f\"‚úÖ Text geschrieben\")\n\n# Lesen\ninhalt = test_datei.read_text()\nprint(f\"üìñ Gelesen: '{inhalt}'\")\n\n# Bytes schreiben/lesen\nbin√§r_datei = test_basis / \"binary.dat\"\nbin√§r_datei.write_bytes(b'\\x00\\x01\\x02\\x03')\ndaten = bin√§r_datei.read_bytes()\nprint(f\"üì¶ Bin√§r: {daten}\")\n\n# DATEI-INFORMATIONEN\nprint(f\"\\nüìä Datei-Info f√ºr '{test_datei.name}':\")\nstats = test_datei.stat()\nprint(f\"Gr√∂√üe: {stats.st_size} Bytes\")\nprint(f\"Erstellt: {time.ctime(stats.st_ctime)}\")\nprint(f\"Ge√§ndert: {time.ctime(stats.st_mtime)}\")\n\n# UMBENENNEN\nalt = test_datei\nneu = test_basis / \"umbenannt.txt\"\nalt.rename(neu)\nprint(f\"\\n‚úÖ Umbenannt: {alt.name} ‚Üí {neu.name}\")\n\n# VERSCHIEBEN (rename funktioniert auch f√ºr Verschieben!)\nziel_ordner = test_basis / \"verschoben\"\nziel_ordner.mkdir(exist_ok=True)\nverschoben = neu.rename(ziel_ordner / neu.name)\nprint(f\"‚úÖ Verschoben nach: {verschoben.parent.name}/\")\n\n# ORDNER-INHALT AUFLISTEN\nprint(f\"\\nüìÇ Inhalt von '{test_basis.name}':\")\nfor item in test_basis.iterdir():  # Wie os.listdir(), aber besser\n    typ = \"üìÅ\" if item.is_dir() else \"üìÑ\"\n    print(f\"{typ} {item.name}\")\n\n# REKURSIV SUCHEN\nprint(f\"\\nüîç Alle .txt Dateien (rekursiv):\")\nfor txt_datei in test_basis.rglob(\"*.txt\"):  # rglob = rekursives glob\n    print(f\"  üìÑ {txt_datei.relative_to(test_basis)}\")\n\n# AUFR√ÑUMEN\nprint(f\"\\nüßπ Aufr√§umen...\")\n# Datei l√∂schen\nif verschoben.exists():\n    verschoben.unlink()  # unlink() = l√∂schen\n    print(f\"üóëÔ∏è {verschoben.name} gel√∂scht\")\n\n# Ordner l√∂schen (nur wenn leer!)\nif ziel_ordner.exists():\n    ziel_ordner.rmdir()\n    print(f\"üóëÔ∏è {ziel_ordner.name}/ gel√∂scht\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Glob-Patterns f√ºr Dateisuche",
            "goal": "Dateien nach Mustern finden",
            "why": "Oft brauchen wir \"alle .jpg Dateien\" oder \"alle Dateien die mit test_ beginnen\"!",
            "code": "from pathlib import Path\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üîç GLOB-PATTERNS - DATEI-SUCHE\")\nprint(\"=\" * 60)\n\n# Test-Struktur erstellen\nbasis = Path(\"test_glob\")\nbasis.mkdir(exist_ok=True)\n\n# Verschiedene Dateien erstellen\ntest_dateien = [\n    \"bild1.jpg\", \"bild2.jpg\", \"foto.png\",\n    \"dokument.pdf\", \"notizen.txt\", \"backup.txt\",\n    \"script.py\", \"data.json\", \"config.yaml\"\n]\n\nfor datei in test_dateien:\n    (basis / datei).write_text(f\"Inhalt von {datei}\")\n\n# Unterordner mit Dateien\nsub = basis / \"unterordner\"\nsub.mkdir(exist_ok=True)\n(sub / \"deep.jpg\").write_text(\"Tief verschachtelt\")\n(sub / \"readme.txt\").write_text(\"README\")\n\nprint(f\"‚úÖ {len(test_dateien) + 2} Test-Dateien erstellt\\n\")\n\n# GLOB-PATTERNS\n\n# Alle Dateien mit .txt\nprint(\"üìù Alle .txt Dateien:\")\nfor datei in basis.glob(\"*.txt\"):\n    print(f\"  - {datei.name}\")\n\n# Alle Bild-Dateien (jpg ODER png)\nprint(\"\\nüñºÔ∏è Alle Bilder (.jpg, .png):\")\nfor ext in [\".jpg\", \".png\"]:\n    for datei in basis.glob(f\"*{ext}\"):\n        print(f\"  - {datei.name}\")\n\n# Alternativ: Mehrere Patterns\nprint(\"\\nüñºÔ∏è Bilder (Alternative):\")\nfor datei in basis.glob(\"bild*\"):  # Alles was mit \"bild\" beginnt\n    print(f\"  - {datei.name}\")\n\n# REKURSIVE SUCHE mit rglob()\nprint(\"\\nüîç Alle .txt Dateien (inkl. Unterordner):\")\nfor datei in basis.rglob(\"*.txt\"):  # Sucht in ALLEN Unterordnern\n    print(f\"  - {datei.relative_to(basis)}\")\n\n# Alle Dateien rekursiv\nprint(\"\\nüìÇ ALLE Dateien rekursiv:\")\nfor datei in basis.rglob(\"*\"):\n    if datei.is_file():\n        rel_pfad = datei.relative_to(basis)\n        print(f\"  - {rel_pfad}\")\n\n# ERWEITERTE PATTERNS\n\n# Dateien die mit bestimmtem Buchstaben beginnen\nprint(\"\\nüî§ Dateien die mit 'b' oder 'd' beginnen:\")\nfor datei in list(basis.glob(\"b*\")) + list(basis.glob(\"d*\")):\n    print(f\"  - {datei.name}\")\n\n# Dateien mit mehreren Buchstaben im Namen\nprint(\"\\nüìù Dateien mit 'data' oder 'config' im Namen:\")\nfor pattern in [\"*data*\", \"*config*\"]:\n    for datei in basis.glob(pattern):\n        print(f\"  - {datei.name}\")\n\n# Nach Gr√∂√üe filtern\nprint(\"\\nüì¶ Dateien gr√∂√üer als 10 Bytes:\")\nfor datei in basis.rglob(\"*\"):\n    if datei.is_file() and datei.stat().st_size > 10:\n        gr√∂√üe = datei.stat().st_size\n        print(f\"  - {datei.name} ({gr√∂√üe} Bytes)\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Datei-Scanner Tool",
            "goal": "Vollst√§ndiges Tool zum Durchsuchen und Analysieren",
            "why": "Praktisches Tool das du wiederverwenden kannst!",
            "code": "from pathlib import Path\nfrom datetime import datetime\nfrom collections import defaultdict\nimport mimetypes\n\nclass DateiScanner:\n    \"\"\"Scannt und analysiert Verzeichnisse\"\"\"\n    \n    def __init__(self, basis_pfad):\n        self.basis = Path(basis_pfad)\n        \n        if not self.basis.exists():\n            raise FileNotFoundError(f\"Pfad existiert nicht: {basis_pfad}\")\n        \n        self.dateien = []\n        self.ordner = []\n    \n    def scannen(self, rekursiv=True):\n        \"\"\"Scannt das Verzeichnis\"\"\"\n        self.dateien = []\n        self.ordner = []\n        \n        if rekursiv:\n            items = self.basis.rglob(\"*\")\n        else:\n            items = self.basis.glob(\"*\")\n        \n        for item in items:\n            if item.is_file():\n                self.dateien.append(item)\n            elif item.is_dir():\n                self.ordner.append(item)\n        \n        return len(self.dateien), len(self.ordner)\n    \n    def nach_erweiterung(self):\n        \"\"\"Gruppiert Dateien nach Erweiterung\"\"\"\n        gruppen = defaultdict(list)\n        \n        for datei in self.dateien:\n            ext = datei.suffix.lower() or \".keine\"\n            gruppen[ext].append(datei)\n        \n        return dict(gruppen)\n    \n    def nach_gr√∂√üe(self, min_mb=None, max_mb=None):\n        \"\"\"Filtert Dateien nach Gr√∂√üe\"\"\"\n        ergebnis = []\n        \n        for datei in self.dateien:\n            gr√∂√üe_mb = datei.stat().st_size / 1024 / 1024\n            \n            if min_mb and gr√∂√üe_mb < min_mb:\n                continue\n            if max_mb and gr√∂√üe_mb > max_mb:\n                continue\n            \n            ergebnis.append((datei, gr√∂√üe_mb))\n        \n        return sorted(ergebnis, key=lambda x: x[1], reverse=True)\n    \n    def nach_datum(self, tage=7):\n        \"\"\"Findet Dateien der letzten N Tage\"\"\"\n        from datetime import timedelta\n        \n        jetzt = datetime.now().timestamp()\n        grenze = jetzt - (tage * 24 * 60 * 60)\n        \n        neu = []\n        \n        for datei in self.dateien:\n            mod_zeit = datei.stat().st_mtime\n            if mod_zeit > grenze:\n                alter = (jetzt - mod_zeit) / 60 / 60 / 24  # in Tagen\n                neu.append((datei, alter))\n        \n        return sorted(neu, key=lambda x: x[1])\n    \n    def duplikate_nach_name(self):\n        \"\"\"Findet Duplikate nach Dateinamen\"\"\"\n        namen = defaultdict(list)\n        \n        for datei in self.dateien:\n            namen[datei.stem.lower()].append(datei)\n        \n        duplikate = {k: v for k, v in namen.items() if len(v) > 1}\n        return duplikate\n    \n    def gr√∂√üte_dateien(self, n=10):\n        \"\"\"Gibt die N gr√∂√üten Dateien zur√ºck\"\"\"\n        mit_gr√∂√üe = [(d, d.stat().st_size) for d in self.dateien]\n        sortiert = sorted(mit_gr√∂√üe, key=lambda x: x[1], reverse=True)\n        return sortiert[:n]\n    \n    def statistik(self):\n        \"\"\"Erstellt umfassende Statistik\"\"\"\n        if not self.dateien:\n            print(\"‚ö†Ô∏è Keine Dateien gescannt. Rufe .scannen() auf!\")\n            return\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"üìä DATEI-SCANNER STATISTIK\")\n        print(f\"{'='*70}\")\n        print(f\"Basis: {self.basis}\")\n        print(f\"\\nOrdner: {len(self.ordner)}\")\n        print(f\"Dateien: {len(self.dateien)}\")\n        \n        # Gesamtgr√∂√üe\n        gesamt_bytes = sum(d.stat().st_size for d in self.dateien)\n        gesamt_mb = gesamt_bytes / 1024 / 1024\n        print(f\"Gesamtgr√∂√üe: {gesamt_mb:.2f} MB\")\n        \n        # Nach Typ\n        print(f\"\\nüìÅ Nach Dateityp:\")\n        typen = self.nach_erweiterung()\n        for ext, dateien in sorted(typen.items(), key=lambda x: len(x[1]), reverse=True):\n            anzahl = len(dateien)\n            gr√∂√üe = sum(d.stat().st_size for d in dateien) / 1024 / 1024\n            print(f\"  {ext:<10} {anzahl:>5} Dateien  {gr√∂√üe:>8.2f} MB\")\n        \n        # Gr√∂√üte Dateien\n        print(f\"\\nüì¶ Top 5 gr√∂√üte Dateien:\")\n        for datei, gr√∂√üe in self.gr√∂√üte_dateien(5):\n            rel = datei.relative_to(self.basis) if datei.is_relative_to(self.basis) else datei\n            print(f\"  {gr√∂√üe/1024/1024:>8.2f} MB  {rel}\")\n        \n        # Neueste Dateien\n        print(f\"\\nüÜï Dateien der letzten 7 Tage:\")\n        neueste = self.nach_datum(7)\n        if neueste:\n            for datei, alter in neueste[:5]:\n                rel = datei.relative_to(self.basis) if datei.is_relative_to(self.basis) else datei\n                print(f\"  vor {alter:.1f} Tagen: {rel}\")\n        else:\n            print(\"  Keine neuen Dateien\")\n        \n        # Duplikate\n        dups = self.duplikate_nach_name()\n        if dups:\n            print(f\"\\n‚ö†Ô∏è M√∂gliche Duplikate nach Name:\")\n            for name, dateien in list(dups.items())[:3]:\n                print(f\"  '{name}':\")\n                for d in dateien:\n                    print(f\"    - {d.relative_to(self.basis) if d.is_relative_to(self.basis) else d}\")\n    \n    def suche(self, pattern, in_namen=True, in_inhalt=False):\n        \"\"\"Sucht nach Pattern in Dateinamen oder Inhalt\"\"\"\n        ergebnisse = []\n        \n        for datei in self.dateien:\n            # In Namen suchen\n            if in_namen and pattern.lower() in datei.name.lower():\n                ergebnisse.append(datei)\n                continue\n            \n            # In Inhalt suchen (nur Text-Dateien)\n            if in_inhalt:\n                try:\n                    if datei.suffix in ['.txt', '.py', '.md', '.json']:\n                        inhalt = datei.read_text(encoding='utf-8', errors='ignore')\n                        if pattern.lower() in inhalt.lower():\n                            ergebnisse.append(datei)\n                except:\n                    pass\n        \n        return ergebnisse\n\n# === TESTEN ===\nprint(\"=\" * 70)\nprint(\"üîç DATEI-SCANNER\")\nprint(\"=\" * 70)\n\n# Test-Struktur erstellen\ntest = Path(\"test_scanner\")\ntest.mkdir(exist_ok=True)\n\n# Verschiedene Dateien\ndateien_info = [\n    (\"gro√ü.dat\", \"x\" * 1000000),  # ~1 MB\n    (\"klein.txt\", \"klein\"),\n    (\"bild1.jpg\", \"fake jpg\" * 1000),\n    (\"bild2.jpg\", \"fake jpg\" * 500),\n    (\"dokument.pdf\", \"pdf\" * 10000),\n    (\"script.py\", \"print('hello')\" * 100),\n]\n\nfor name, inhalt in dateien_info:\n    (test / name).write_text(inhalt)\n\n# Unterordner\nsub = test / \"archiv\"\nsub.mkdir(exist_ok=True)\n(sub / \"alt.txt\").write_text(\"alt\")\n(sub / \"backup.zip\").write_text(\"zip\" * 5000)\n\nprint(f\"‚úÖ Test-Struktur erstellt\\n\")\n\n# Scanner erstellen und ausf√ºhren\nscanner = DateiScanner(test)\ndateien, ordner = scanner.scannen(rekursiv=True)\nprint(f\"üìÇ Gescannt: {dateien} Dateien, {ordner} Ordner\")\n\n# Statistik\nscanner.statistik()\n\n# Suche\nprint(f\"\\nüîç Suche nach 'bild':\")\ntreffer = scanner.suche(\"bild\", in_namen=True)\nfor t in treffer:\n    print(f\"  - {t.name}\")\n\n# Nach Gr√∂√üe filtern\nprint(f\"\\nüì¶ Dateien gr√∂√üer als 0.5 MB:\")\ngro√üe = scanner.nach_gr√∂√üe(min_mb=0.5)\nfor datei, gr√∂√üe in gro√üe:\n    print(f\"  {gr√∂√üe:.2f} MB: {datei.name}\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 6,
        "weekId": 3,
        "title": "Backup-Tool (Shutil)",
        "duration": "10-15 Min",
        "task": {
          "title": "Backup-Tool (Shutil)",
          "description": "Lerne Shutil kennen - das Modul f√ºr High-Level Datei-Operationen!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Shutil Grundlagen",
            "goal": "Verstehen was Shutil kann",
            "why": "Shutil macht komplexe Operationen einfach - kopieren, verschieben, archivieren!",
            "code": "import shutil\nfrom pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"üì¶ SHUTIL - HIGH-LEVEL DATEI-OPERATIONEN\")\nprint(\"=\" * 60)\n\n# Test-Umgebung\nquelle = Path(\"test_shutil_quelle\")\nquelle.mkdir(exist_ok=True)\n\n# Test-Dateien\ntest_datei = quelle / \"dokument.txt\"\ntest_datei.write_text(\"Wichtiger Inhalt!\")\n\nprint(f\"‚úÖ Test-Datei erstellt: {test_datei.name}\\n\")\n\n# DATEIEN KOPIEREN\n\n# 1. copy() - Kopiert Datei (ohne Metadaten)\nziel1 = Path(\"kopie1.txt\")\nshutil.copy(test_datei, ziel1)\nprint(f\"üìã copy(): {test_datei.name} ‚Üí {ziel1.name}\")\n\n# 2. copy2() - Kopiert Datei (MIT Metadaten - Datum, Rechte)\nziel2 = Path(\"kopie2.txt\")\nshutil.copy2(test_datei, ziel2)\nprint(f\"üìã copy2(): {test_datei.name} ‚Üí {ziel2.name}\")\n\n# 3. copyfile() - Nur Inhalt (schneller, aber keine Metadaten)\nziel3 = Path(\"kopie3.txt\")\nshutil.copyfile(test_datei, ziel3)\nprint(f\"üìã copyfile(): {test_datei.name} ‚Üí {ziel3.name}\")\n\n# ORDNER KOPIEREN\n\n# Unterordner mit Dateien erstellen\nsub = quelle / \"unterordner\"\nsub.mkdir(exist_ok=True)\n(sub / \"datei1.txt\").write_text(\"Datei 1\")\n(sub / \"datei2.txt\").write_text(\"Datei 2\")\n\n# copytree() - Kopiert ganzen Ordner rekursiv\nziel_ordner = Path(\"kopierter_ordner\")\nshutil.copytree(quelle, ziel_ordner)\nprint(f\"\\nüìÅ copytree(): {quelle.name}/ ‚Üí {ziel_ordner.name}/\")\n\n# VERSCHIEBEN\n\n# move() - Verschiebt Datei oder Ordner\nzu_verschieben = Path(\"zu_verschieben.txt\")\nzu_verschieben.write_text(\"Ich werde verschoben\")\n\nverschoben = Path(\"verschoben\") / \"neue_position.txt\"\nverschoben.parent.mkdir(exist_ok=True)\n\nshutil.move(zu_verschieben, verschoben)\nprint(f\"\\nüöö move(): {zu_verschieben.name} ‚Üí {verschoben}\")\n\n# DISK USAGE - Speicherplatz pr√ºfen\nusage = shutil.disk_usage(Path.cwd())\nprint(f\"\\nüíæ Disk Usage (aktuelles Laufwerk):\")\nprint(f\"Total: {usage.total / 1024**3:.2f} GB\")\nprint(f\"Benutzt: {usage.used / 1024**3:.2f} GB\")\nprint(f\"Frei: {usage.free / 1024**3:.2f} GB\")\n\n# L√ñSCHEN\n\n# rmtree() - L√∂scht Ordner rekursiv (GEF√ÑHRLICH!)\nif ziel_ordner.exists():\n    shutil.rmtree(ziel_ordner)\n    print(f\"\\nüóëÔ∏è rmtree(): {ziel_ordner.name}/ gel√∂scht (rekursiv)\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Archive erstellen",
            "goal": "ZIP, TAR und andere Archive erstellen",
            "why": "Backups komprimieren spart Platz!",
            "code": "import shutil\nfrom pathlib import Path\nfrom datetime import datetime\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üóúÔ∏è ARCHIVE ERSTELLEN\")\nprint(\"=\" * 60)\n\n# Zu archivierende Daten\nquelle = Path(\"test_archiv\")\nquelle.mkdir(exist_ok=True)\n\n# Mehrere Dateien erstellen\nfor i in range(5):\n    (quelle / f\"datei{i}.txt\").write_text(f\"Inhalt von Datei {i}\" * 100)\n\nsub = quelle / \"unterordner\"\nsub.mkdir(exist_ok=True)\n(sub / \"wichtig.txt\").write_text(\"Wichtige Daten!\" * 50)\n\nprint(f\"‚úÖ Test-Daten erstellt in '{quelle.name}/'\\n\")\n\n# Verf√ºgbare Archive-Formate\nformate = shutil.get_archive_formats()\nprint(f\"üì¶ Verf√ºgbare Archive-Formate:\")\nfor name, beschreibung in formate:\n    print(f\"  {name}: {beschreibung}\")\n\n# ZIP erstellen\nprint(f\"\\nüóúÔ∏è Erstelle ZIP-Archiv...\")\nzip_name = \"backup_zip\"\nshutil.make_archive(\n    zip_name,           # Name (ohne .zip)\n    'zip',              # Format\n    quelle              # Quelle-Ordner\n)\nprint(f\"‚úÖ Erstellt: {zip_name}.zip\")\n\n# Gr√∂√üe pr√ºfen\noriginal_gr√∂√üe = sum(f.stat().st_size for f in quelle.rglob(\"*\") if f.is_file())\narchiv_gr√∂√üe = Path(f\"{zip_name}.zip\").stat().st_size\n\nprint(f\"\\nüìä Kompression:\")\nprint(f\"Original: {original_gr√∂√üe / 1024:.2f} KB\")\nprint(f\"Archiv: {archiv_gr√∂√üe / 1024:.2f} KB\")\nprint(f\"Kompression: {(1 - archiv_gr√∂√üe/original_gr√∂√üe) * 100:.1f}%\")\n\n# TAR.GZ erstellen (st√§rkere Kompression)\nprint(f\"\\nüóúÔ∏è Erstelle TAR.GZ-Archiv...\")\ntar_name = \"backup_tar\"\nshutil.make_archive(tar_name, 'gztar', quelle)\nprint(f\"‚úÖ Erstellt: {tar_name}.tar.gz\")\n\ntar_gr√∂√üe = Path(f\"{tar_name}.tar.gz\").stat().st_size\nprint(f\"TAR.GZ Gr√∂√üe: {tar_gr√∂√üe / 1024:.2f} KB\")\n\n# ARCHIV ENTPACKEN\nprint(f\"\\nüìÇ Entpacke Archive...\")\n\n# ZIP entpacken\nzip_ziel = Path(\"entpackt_zip\")\nshutil.unpack_archive(f\"{zip_name}.zip\", zip_ziel)\nprint(f\"‚úÖ ZIP entpackt nach: {zip_ziel}/\")\n\n# TAR.GZ entpacken\ntar_ziel = Path(\"entpackt_tar\")\nshutil.unpack_archive(f\"{tar_name}.tar.gz\", tar_ziel)\nprint(f\"‚úÖ TAR.GZ entpackt nach: {tar_ziel}/\")\n\n# Mit Zeitstempel\nprint(f\"\\n‚è∞ Archiv mit Timestamp:\")\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\ntimestamped = f\"backup_{timestamp}\"\nshutil.make_archive(timestamped, 'zip', quelle)\nprint(f\"‚úÖ Erstellt: {timestamped}.zip\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Intelligentes Kopieren mit Filtern",
            "goal": "Nur bestimmte Dateien kopieren",
            "why": "Oft wollen wir nicht ALLES kopieren - z.B. keine .pyc Dateien!",
            "code": "import shutil\nfrom pathlib import Path\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üîç SELEKTIVES KOPIEREN MIT FILTERN\")\nprint(\"=\" * 60)\n\n# Test-Struktur\nquelle = Path(\"test_filter_quelle\")\nquelle.mkdir(exist_ok=True)\n\n# Verschiedene Dateitypen\ndateien = {\n    \"code.py\": \"print('hello')\",\n    \"compiled.pyc\": \"binary data\",\n    \"__pycache__\": None,  # Ordner\n    \"dokument.txt\": \"text\",\n    \"bild.jpg\": \"fake image data\",\n    \"backup.bak\": \"old backup\",\n    \"wichtig.pdf\": \"pdf content\",\n}\n\nfor name, inhalt in dateien.items():\n    pfad = quelle / name\n    if inhalt is None:  # Ordner\n        pfad.mkdir(exist_ok=True)\n    else:\n        pfad.write_text(inhalt)\n\nprint(f\"‚úÖ Test-Struktur mit {len(dateien)} Items erstellt\\n\")\n\n# FILTER-FUNKTIONEN\n\ndef ignoriere_pyc(verzeichnis, inhalt):\n    \"\"\"\n    Filter f√ºr copytree()\n    \n    Args:\n        verzeichnis: Aktuelles Verzeichnis (String)\n        inhalt: Liste aller Dateien/Ordner im Verzeichnis\n        \n    Returns:\n        Liste von Namen die IGNORIERT werden sollen\n    \"\"\"\n    ignorieren = []\n    \n    for item in inhalt:\n        # Ignoriere .pyc und __pycache__\n        if item.endswith('.pyc') or item == '__pycache__':\n            ignorieren.append(item)\n    \n    return ignorieren\n\ndef ignoriere_backups(verzeichnis, inhalt):\n    \"\"\"Ignoriert Backup-Dateien (.bak, .backup, .old)\"\"\"\n    return [item for item in inhalt \n            if item.endswith(('.bak', '.backup', '.old'))]\n\ndef nur_dokumente(verzeichnis, inhalt):\n    \"\"\"Kopiert nur Dokumente (.txt, .pdf, .doc)\"\"\"\n    doc_extensions = {'.txt', '.pdf', '.doc', '.docx'}\n    \n    ignorieren = []\n    for item in inhalt:\n        pfad = Path(verzeichnis) / item\n        if pfad.is_file():\n            if pfad.suffix not in doc_extensions:\n                ignorieren.append(item)\n    \n    return ignorieren\n\n# KOPIEREN MIT FILTERN\n\n# 1. Ohne Python-Compile-Dateien\nziel1 = Path(\"kopie_ohne_pyc\")\nshutil.copytree(quelle, ziel1, ignore=ignoriere_pyc)\nprint(f\"üìÅ Kopiert (ohne .pyc): {ziel1.name}/\")\n\n# 2. Ohne Backups\nziel2 = Path(\"kopie_ohne_backups\")\nshutil.copytree(quelle, ziel2, ignore=ignoriere_backups)\nprint(f\"üìÅ Kopiert (ohne .bak): {ziel2.name}/\")\n\n# 3. Nur Dokumente\nziel3 = Path(\"kopie_nur_dokumente\")\nshutil.copytree(quelle, ziel3, ignore=nur_dokumente)\nprint(f\"üìÅ Kopiert (nur Docs): {ziel3.name}/\")\n\n# 4. Kombinierte Filter\ndef kombinierter_filter(verzeichnis, inhalt):\n    \"\"\"Kombiniert mehrere Filter\"\"\"\n    ignorieren = set()\n    \n    # Sammle alle zu ignorierenden Items\n    ignorieren.update(ignoriere_pyc(verzeichnis, inhalt))\n    ignorieren.update(ignoriere_backups(verzeichnis, inhalt))\n    \n    return list(ignorieren)\n\nziel4 = Path(\"kopie_gefiltert\")\nshutil.copytree(quelle, ziel4, ignore=kombinierter_filter)\nprint(f\"üìÅ Kopiert (kombiniert): {ziel4.name}/\")\n\n# Inhalt vergleichen\nprint(f\"\\nüìä Vergleich:\")\nprint(f\"Original: {len(list(quelle.iterdir()))} Items\")\nprint(f\"Ohne .pyc: {len(list(ziel1.iterdir()))} Items\")\nprint(f\"Ohne .bak: {len(list(ziel2.iterdir()))} Items\")\nprint(f\"Nur Docs: {len(list(ziel3.iterdir()))} Items\")\nprint(f\"Kombiniert: {len(list(ziel4.iterdir()))} Items\")\n\n# PATTERN-BASIERTE FILTER (einfacher!)\nprint(f\"\\nüéØ Pattern-basierte Filter:\")\n\n# ignore_patterns() - Eingebaute Funktion!\nziel5 = Path(\"kopie_pattern\")\nshutil.copytree(\n    quelle,\n    ziel5,\n    ignore=shutil.ignore_patterns('*.pyc', '__pycache__', '*.bak')\n)\nprint(f\"üìÅ Kopiert (mit ignore_patterns): {ziel5.name}/\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Vollst√§ndiges Backup-Tool",
            "goal": "Production-Ready Backup-System",
            "why": "Alle Konzepte in einem praktischen Tool!",
            "code": "import shutil\nfrom pathlib import Path\nfrom datetime import datetime\nimport json\n\nclass BackupManager:\n    \"\"\"Vollst√§ndiges Backup-System\"\"\"\n    \n    def __init__(self, quelle, ziel_basis):\n        self.quelle = Path(quelle)\n        self.ziel_basis = Path(ziel_basis)\n        \n        if not self.quelle.exists():\n            raise FileNotFoundError(f\"Quelle nicht gefunden: {quelle}\")\n        \n        self.ziel_basis.mkdir(parents=True, exist_ok=True)\n        self.config_datei = self.ziel_basis / \"backup_config.json\"\n        self.config = self._lade_config()\n    \n    def _lade_config(self):\n        \"\"\"L√§dt oder erstellt Konfiguration\"\"\"\n        if self.config_datei.exists():\n            return json.loads(self.config_datei.read_text())\n        else:\n            config = {\n                'backups': [],\n                'ignorierte_patterns': ['*.pyc', '__pycache__', '*.tmp', '.git'],\n                'max_backups': 5\n            }\n            self._speichere_config(config)\n            return config\n    \n    def _speichere_config(self, config):\n        \"\"\"Speichert Konfiguration\"\"\"\n        self.config_datei.write_text(json.dumps(config, indent=2))\n    \n    def erstelle_backup(self, typ='vollst√§ndig', kommentar=''):\n        \"\"\"\n        Erstellt ein Backup\n        \n        Args:\n            typ: 'vollst√§ndig' oder 'inkrementell'\n            kommentar: Optionaler Kommentar\n        \"\"\"\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_name = f\"backup_{timestamp}\"\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"üíæ ERSTELLE BACKUP\")\n        print(f\"{'='*60}\")\n        print(f\"Typ: {typ}\")\n        print(f\"Quelle: {self.quelle}\")\n        print(f\"Ziel: {backup_name}\")\n        \n        if typ == 'vollst√§ndig':\n            backup_pfad = self._vollst√§ndiges_backup(backup_name)\n        else:\n            backup_pfad = self._inkrementelles_backup(backup_name)\n        \n        # Metadaten speichern\n        meta = {\n            'timestamp': timestamp,\n            'typ': typ,\n            'kommentar': kommentar,\n            'pfad': str(backup_pfad),\n            'gr√∂√üe': self._ordner_gr√∂√üe(backup_pfad),\n            'dateien': sum(1 for _ in backup_pfad.rglob(\"*\") if _.is_file())\n        }\n        \n        self.config['backups'].append(meta)\n        self._speichere_config(self.config)\n        \n        # Alte Backups l√∂schen\n        self._aufr√§umen()\n        \n        print(f\"\\n‚úÖ Backup erstellt:\")\n        print(f\"   Dateien: {meta['dateien']}\")\n        print(f\"   Gr√∂√üe: {meta['gr√∂√üe'] / 1024 / 1024:.2f} MB\")\n        \n        return backup_pfad\n    \n    def _vollst√§ndiges_backup(self, name):\n        \"\"\"Erstellt vollst√§ndiges Backup\"\"\"\n        ziel = self.ziel_basis / name\n        \n        print(f\"\\nüì¶ Kopiere alle Dateien...\")\n        shutil.copytree(\n            self.quelle,\n            ziel,\n            ignore=shutil.ignore_patterns(*self.config['ignorierte_patterns'])\n        )\n        \n        return ziel\n    \n    def _inkrementelles_backup(self, name):\n        \"\"\"Erstellt inkrementelles Backup (nur ge√§nderte Dateien)\"\"\"\n        ziel = self.ziel_basis / name\n        ziel.mkdir()\n        \n        # Letztes Backup als Referenz\n        letztes = self._letztes_backup()\n        if not letztes:\n            print(\"‚ö†Ô∏è Kein vorheriges Backup - erstelle vollst√§ndiges Backup\")\n            return self._vollst√§ndiges_backup(name)\n        \n        letztes_pfad = Path(letztes['pfad'])\n        \n        print(f\"\\nüì¶ Kopiere nur ge√§nderte Dateien...\")\n        print(f\"   Referenz: {letztes_pfad.name}\")\n        \n        ge√§ndert = 0\n        neu = 0\n        \n        for datei in self.quelle.rglob(\"*\"):\n            if datei.is_file():\n                rel_pfad = datei.relative_to(self.quelle)\n                \n                # Pr√ºfe ob Datei ignoriert werden soll\n                if any(datei.match(p) for p in self.config['ignorierte_patterns']):\n                    continue\n                \n                alte_datei = letztes_pfad / rel_pfad\n                \n                # Neu oder ge√§ndert?\n                if not alte_datei.exists():\n                    neu += 1\n                    ziel_datei = ziel / rel_pfad\n                    ziel_datei.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy2(datei, ziel_datei)\n                \n                elif datei.stat().st_mtime > alte_datei.stat().st_mtime:\n                    ge√§ndert += 1\n                    ziel_datei = ziel / rel_pfad\n                    ziel_datei.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy2(datei, ziel_datei)\n        \n        print(f\"   Neue Dateien: {neu}\")\n        print(f\"   Ge√§nderte Dateien: {ge√§ndert}\")\n        \n        return ziel\n    \n    def _letztes_backup(self):\n        \"\"\"Gibt letztes Backup zur√ºck\"\"\"\n        if not self.config['backups']:\n            return None\n        return self.config['backups'][-1]\n    \n    def _ordner_gr√∂√üe(self, pfad):\n        \"\"\"Berechnet Ordner-Gr√∂√üe\"\"\"\n        return sum(f.stat().st_size for f in pfad.rglob(\"*\") if f.is_file())\n    \n    def _aufr√§umen(self):\n        \"\"\"L√∂scht alte Backups\"\"\"\n        max_backups = self.config['max_backups']\n        \n        if len(self.config['backups']) > max_backups:\n            zu_l√∂schen = self.config['backups'][:-max_backups]\n            \n            print(f\"\\nüßπ L√∂sche {len(zu_l√∂schen)} alte(s) Backup(s)...\")\n            \n            for backup in zu_l√∂schen:\n                pfad = Path(backup['pfad'])\n                if pfad.exists():\n                    shutil.rmtree(pfad)\n                    print(f\"   üóëÔ∏è {pfad.name}\")\n            \n            self.config['backups'] = self.config['backups'][-max_backups:]\n            self._speichere_config(self.config)\n    \n    def liste_backups(self):\n        \"\"\"Listet alle Backups auf\"\"\"\n        if not self.config['backups']:\n            print(\"üì≠ Keine Backups vorhanden\")\n            return\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"üìö BACKUP-LISTE\")\n        print(f\"{'='*60}\")\n        \n        for i, backup in enumerate(self.config['backups'], 1):\n            gr√∂√üe_mb = backup['gr√∂√üe'] / 1024 / 1024\n            print(f\"\\n{i}. {backup['timestamp']}\")\n            print(f\"   Typ: {backup['typ']}\")\n            print(f\"   Dateien: {backup['dateien']}\")\n            print(f\"   Gr√∂√üe: {gr√∂√üe_mb:.2f} MB\")\n            if backup['kommentar']:\n                print(f\"   Kommentar: {backup['kommentar']}\")\n    \n    def wiederherstellen(self, backup_index=-1, ziel=None):\n        \"\"\"\n        Stellt Backup wieder her\n        \n        Args:\n            backup_index: Index des Backups (-1 = letztes)\n            ziel: Ziel-Ordner (None = Original √ºberschreiben)\n        \"\"\"\n        if not self.config['backups']:\n            print(\"‚ùå Keine Backups vorhanden\")\n            return\n        \n        backup = self.config['backups'][backup_index]\n        quelle = Path(backup['pfad'])\n        \n        if not quelle.exists():\n            print(f\"‚ùå Backup nicht gefunden: {quelle}\")\n            return\n        \n        if ziel is None:\n            print(\"‚ö†Ô∏è WARNUNG: Original wird √ºberschrieben!\")\n            antwort = input(\"Fortfahren? (j/n): \")\n            if antwort.lower() != 'j':\n                print(\"‚ùå Abgebrochen\")\n                return\n            ziel = self.quelle\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"‚ôªÔ∏è WIEDERHERSTELLUNG\")\n        print(f\"{'='*60}\")\n        print(f\"Von: {quelle.name}\")\n        print(f\"Nach: {ziel}\")\n        \n        # Backup des aktuellen Zustands erstellen\n        if ziel == self.quelle:\n            print(\"\\nüíæ Erstelle Sicherheits-Backup...\")\n            self.erstelle_backup(typ='vollst√§ndig', kommentar='Vor Wiederherstellung')\n        \n        # Wiederherstellen\n        if Path(ziel).exists():\n            shutil.rmtree(ziel)\n        \n        shutil.copytree(quelle, ziel)\n        \n        print(f\"\\n‚úÖ Wiederherstellung abgeschlossen!\")\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"üíæ BACKUP-MANAGER\")\nprint(\"=\" * 60)\n\n# Test-Projekt erstellen\nprojekt = Path(\"mein_projekt\")\nprojekt.mkdir(exist_ok=True)\n\n(projekt / \"main.py\").write_text(\"print('Version 1')\")\n(projekt / \"config.json\").write_text('{\"version\": 1}')\n(projekt / \"README.md\").write_text(\"# Mein Projekt\")\n\n# Ordner mit tempor√§ren Dateien\ntemp = projekt / \"__pycache__\"\ntemp.mkdir(exist_ok=True)\n(temp / \"main.pyc\").write_text(\"compiled\")\n\nprint(f\"‚úÖ Test-Projekt erstellt\\n\")\n\n# Backup-Manager erstellen\nmanager = BackupManager(projekt, \"backups\")\n\n# Erstes vollst√§ndiges Backup\nmanager.erstelle_backup(typ='vollst√§ndig', kommentar='Initial')\n\n# Projekt √§ndern\nprint(f\"\\nüìù √Ñndere Projekt...\")\n(projekt / \"main.py\").write_text(\"print('Version 2')\")\n(projekt / \"neu.py\").write_text(\"print('neu')\")\n\n# Zweites Backup (inkrementell)\nmanager.erstelle_backup(typ='inkrementell', kommentar='Nach √Ñnderungen')\n\n# Liste anzeigen\nmanager.liste_backups()\n\n# Wiederherstellen (Simulation)\nprint(f\"\\n\" + \"=\"*60)\nprint(\"‚ôªÔ∏è WIEDERHERSTELLUNG (Simulation)\")\nprint(\"=\"*60)\nprint(\"Um wiederherzustellen: manager.wiederherstellen(-1)\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 7,
        "weekId": 3,
        "title": "Batch-Renamer (Glob & Massen-Operationen)",
        "duration": "10-15 Min",
        "task": {
          "title": "Batch-Renamer (Glob & Massen-Operationen)",
          "description": "Erstelle ein Tool zum Umbenennen vieler Dateien auf einmal!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Glob-Modul im Detail",
            "goal": "Glob-Patterns meistern",
            "why": "Glob ist perfekt f√ºr \"alle JPGs\" oder \"alle Dateien von gestern\"!",
            "code": "import glob\nfrom pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"üîç GLOB - PATTERN-MATCHING\")\nprint(\"=\" * 60)\n\n# Test-Struktur erstellen\nbasis = Path(\"test_glob_patterns\")\nbasis.mkdir(exist_ok=True)\n\n# Viele Test-Dateien\ndateien = [\n    \"foto_001.jpg\", \"foto_002.jpg\", \"foto_003.jpg\",\n    \"bild_2024_01.png\", \"bild_2024_02.png\",\n    \"dokument_01.pdf\", \"dokument_02.pdf\",\n    \"backup_20240115.zip\", \"backup_20240120.zip\",\n    \"script_v1.py\", \"script_v2.py\", \"script_final.py\",\n    \"IMG_001.JPG\", \"IMG_002.JPG\",  # Gro√übuchstaben\n]\n\nfor datei in dateien:\n    (basis / datei).write_text(f\"Inhalt: {datei}\")\n\n# Unterordner\n(basis / \"2024\").mkdir(exist_ok=True)\n(basis / \"2024\" / \"januar.txt\").write_text(\"januar\")\n\nprint(f\"‚úÖ {len(dateien) + 1} Test-Dateien erstellt\\n\")\n\n# GLOB-PATTERNS\n\n# 1. Alle Dateien mit Endung\nprint(\"üì∏ Alle .jpg Dateien (klein):\")\njpg_dateien = glob.glob(str(basis / \"*.jpg\"))\nfor datei in jpg_dateien:\n    print(f\"  - {Path(datei).name}\")\n\n# 2. Case-insensitive (gro√ü/klein egal)\nprint(\"\\nüì∏ Alle .jpg/.JPG Dateien (case-insensitive):\")\nalle_jpgs = glob.glob(str(basis / \"*.[jJ][pP][gG]\"))\nfor datei in alle_jpgs:\n    print(f\"  - {Path(datei).name}\")\n\n# Oder mit pathlib (automatisch case-insensitive auf Windows):\nfor datei in basis.glob(\"*.[jJ][pP][gG]\"):\n    print(f\"  - {datei.name}\")\n\n# 3. Dateien die mit bestimmtem Text beginnen\nprint(\"\\nüñºÔ∏è Alle 'foto_*' Dateien:\")\nfoto_dateien = glob.glob(str(basis / \"foto_*\"))\nfor datei in foto_dateien:\n    print(f\"  - {Path(datei).name}\")\n\n# 4. Dateien mit Zahlen im Namen\nprint(\"\\nüî¢ Dateien mit '_001' bis '_003':\")\nnummern = glob.glob(str(basis / \"*_00[123].*\"))\nfor datei in nummern:\n    print(f\"  - {Path(datei).name}\")\n\n# 5. Mehrere Patterns kombinieren\nprint(\"\\nüìÅ Alle Bilder (.jpg, .png):\")\nbilder = []\nfor pattern in [\"*.jpg\", \"*.JPG\", \"*.png\"]:\n    bilder.extend(glob.glob(str(basis / pattern)))\nfor datei in bilder:\n    print(f\"  - {Path(datei).name}\")\n\n# 6. Rekursiv (mit **)\nprint(\"\\nüîç Rekursive Suche (alle .txt):\")\ntxt_rekursiv = glob.glob(str(basis / \"**\" / \"*.txt\"), recursive=True)\nfor datei in txt_rekursiv:\n    rel = Path(datei).relative_to(basis)\n    print(f\"  - {rel}\")\n\n# 7. Wildcards\n# * = beliebig viele Zeichen\n# ? = genau ein Zeichen\n# [abc] = a, b oder c\n# [0-9] = Ziffer\n# [a-z] = Kleinbuchstabe\n\nprint(\"\\nüéØ Pattern mit ?:\")\n# Dateien mit genau 3 Zeichen nach _\ndrei_zeichen = glob.glob(str(basis / \"*_???.???\"))\nfor datei in drei_zeichen:\n    print(f\"  - {Path(datei).name}\")\n\nprint(\"\\nüéØ Pattern mit [0-9]:\")\nmit_zahlen = glob.glob(str(basis / \"*[0-9][0-9].*\"))\nfor datei in mit_zahlen:\n    print(f\"  - {Path(datei).name}\")\n\n# GLOB MIT PATHLIB (empfohlen!)\nprint(\"\\nüìÇ Mit Pathlib.glob():\")\nfor py_datei in basis.glob(\"script*.py\"):\n    print(f\"  üêç {py_datei.name}\")\n\n# Sortiert nach Datum\nprint(\"\\n‚è∞ Nach √Ñnderungsdatum sortiert:\")\nalle = list(basis.glob(\"*.*\"))\nsortiert = sorted(alle, key=lambda p: p.stat().st_mtime)\nfor datei in sortiert[:5]:\n    print(f\"  - {datei.name}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Batch-Umbenennen Grundlagen",
            "goal": "Viele Dateien auf einmal umbenennen",
            "why": "Manuell 100 Fotos umbenennen? Nein danke!",
            "code": "from pathlib import Path\nimport re\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"‚úèÔ∏è BATCH-UMBENENNEN\")\nprint(\"=\" * 60)\n\n# Test-Dateien\ntest = Path(\"test_rename\")\ntest.mkdir(exist_ok=True)\n\n# Unordentliche Dateinamen\ndateien = [\n    \"IMG_20240115_134521.jpg\",\n    \"IMG_20240115_134522.jpg\",\n    \"IMG_20240115_134523.jpg\",\n    \"DSC_001.jpg\",\n    \"DSC_002.jpg\",\n    \"photo (1).jpg\",\n    \"photo (2).jpg\",\n    \"Urlaubsfoto 2024.png\",\n]\n\nfor datei in dateien:\n    (test / datei).write_text(\"bild\")\n\nprint(f\"‚úÖ {len(dateien)} Dateien mit chaotischen Namen erstellt\\n\")\n\n# UMBENENNEN-STRATEGIEN\n\n# 1. Pr√§fix hinzuf√ºgen\nprint(\"üì∏ Strategie 1: Pr√§fix hinzuf√ºgen\")\npr√§fix = \"Urlaub_\"\n\nfor datei in test.glob(\"IMG_*.jpg\"):\n    neuer_name = pr√§fix + datei.name\n    neu = datei.parent / neuer_name\n    print(f\"  {datei.name} ‚Üí {neuer_name}\")\n    # datei.rename(neu)  # Auskommentiert f√ºr Demo\n\n# 2. Durchnummerieren\nprint(\"\\nüî¢ Strategie 2: Durchnummerieren\")\n\njpg_dateien = sorted(test.glob(\"*.jpg\"))\nfor i, datei in enumerate(jpg_dateien, start=1):\n    neuer_name = f\"foto_{i:03d}{datei.suffix}\"  # :03d = 3 Stellen mit f√ºhrenden Nullen\n    neu = datei.parent / neuer_name\n    print(f\"  {datei.name} ‚Üí {neuer_name}\")\n    # datei.rename(neu)\n\n# 3. Text ersetzen\nprint(\"\\n‚úÇÔ∏è Strategie 3: Text ersetzen\")\n\nfor datei in test.glob(\"*\"):\n    if datei.is_file():\n        neuer_name = datei.name.replace(\"IMG_\", \"Foto_\")\n        neuer_name = neuer_name.replace(\"DSC_\", \"Bild_\")\n        \n        if neuer_name != datei.name:\n            neu = datei.parent / neuer_name\n            print(f\"  {datei.name} ‚Üí {neuer_name}\")\n            # datei.rename(neu)\n\n# 4. Leerzeichen entfernen\nprint(\"\\nüöÄ Strategie 4: Leerzeichen entfernen\")\n\nfor datei in test.glob(\"*\"):\n    if datei.is_file() and \" \" in datei.name:\n        neuer_name = datei.name.replace(\" \", \"_\")\n        neu = datei.parent / neuer_name\n        print(f\"  {datei.name} ‚Üí {neuer_name}\")\n        # datei.rename(neu)\n\n# 5. Kleinbuchstaben\nprint(\"\\nüî§ Strategie 5: Alles Kleinbuchstaben\")\n\nfor datei in test.glob(\"*\"):\n    if datei.is_file():\n        neuer_name = datei.name.lower()\n        \n        if neuer_name != datei.name:\n            neu = datei.parent / neuer_name\n            print(f\"  {datei.name} ‚Üí {neuer_name}\")\n            # datei.rename(neu)\n\n# 6. Regex-basiert\nprint(\"\\nüéØ Strategie 6: Datum extrahieren (Regex)\")\n\nfor datei in test.glob(\"IMG_*.jpg\"):\n    # Suche Datum im Format YYYYMMDD\n    match = re.search(r'(\\d{8})', datei.name)\n    if match:\n        datum = match.group(1)\n        jahr = datum[:4]\n        monat = datum[4:6]\n        tag = datum[6:8]\n        \n        neuer_name = f\"{jahr}-{monat}-{tag}_{datei.stem[9:]}{datei.suffix}\"\n        print(f\"  {datei.name} ‚Üí {neuer_name}\")\n        # datei.rename(datei.parent / neuer_name)\n\n# 7. Endung √§ndern\nprint(\"\\nüîÑ Strategie 7: Endung √§ndern (.jpg ‚Üí .jpeg)\")\n\nfor datei in test.glob(\"*.jpg\"):\n    neuer_name = datei.stem + \".jpeg\"\n    neu = datei.parent / neuer_name\n    print(f\"  {datei.name} ‚Üí {neuer_name}\")\n    # datei.rename(neu)",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Sicheres Umbenennen",
            "goal": "Kollisionen und Fehler vermeiden",
            "why": "Was wenn neue Namen schon existieren? Oder ung√ºltige Zeichen?",
            "code": "from pathlib import Path\nimport re\nfrom datetime import datetime\n\nclass SichererRenamer:\n    \"\"\"Sicheres Umbenennen mit Kollisionserkennung\"\"\"\n    \n    # Zeichen die in Dateinamen problematisch sind\n    UNGUELTIGE_ZEICHEN = r'[<>:\"/\\\\|?*]'\n    \n    def __init__(self, trockenlauf=True):\n        self.trockenlauf = trockenlauf\n        self.√§nderungen = []\n    \n    def bereinige_name(self, name):\n        \"\"\"Entfernt ung√ºltige Zeichen\"\"\"\n        # Ersetze ung√ºltige Zeichen mit _\n        bereinigt = re.sub(self.UNGUELTIGE_ZEICHEN, '_', name)\n        \n        # Entferne mehrfache Unterstriche\n        bereinigt = re.sub(r'_+', '_', bereinigt)\n        \n        # Entferne _ am Anfang/Ende\n        bereinigt = bereinigt.strip('_')\n        \n        return bereinigt\n    \n    def pr√ºfe_kollision(self, pfad):\n        \"\"\"Pr√ºft ob Datei existiert und findet freien Namen\"\"\"\n        if not pfad.exists():\n            return pfad\n        \n        # Datei existiert - finde freien Namen\n        stamm = pfad.stem\n        suffix = pfad.suffix\n        parent = pfad.parent\n        \n        counter = 1\n        while True:\n            neuer_name = f\"{stamm}_{counter}{suffix}\"\n            neu = parent / neuer_name\n            \n            if not neu.exists():\n                return neu\n            \n            counter += 1\n            \n            if counter > 1000:  # Sicherheit\n                raise RuntimeError(\"Zu viele Kollisionen!\")\n    \n    def umbenennen(self, alt_pfad, neuer_name):\n        \"\"\"\n        Benennt Datei sicher um\n        \n        Returns:\n            Neuer Pfad oder None bei Fehler\n        \"\"\"\n        alt = Path(alt_pfad)\n        \n        if not alt.exists():\n            print(f\"‚ùå Datei existiert nicht: {alt}\")\n            return None\n        \n        # Namen bereinigen\n        bereinigter_name = self.bereinige_name(neuer_name)\n        \n        if bereinigter_name != neuer_name:\n            print(f\"‚ö†Ô∏è Name bereinigt: '{neuer_name}' ‚Üí '{bereinigter_name}'\")\n        \n        # Ziel-Pfad\n        neu = alt.parent / bereinigter_name\n        \n        # Kollision pr√ºfen\n        if neu.exists() and neu != alt:\n            print(f\"‚ö†Ô∏è Kollision: {bereinigter_name} existiert bereits\")\n            neu = self.pr√ºfe_kollision(neu)\n            print(f\"   Verwende stattdessen: {neu.name}\")\n        \n        # Umbenennen oder simulieren\n        if self.trockenlauf:\n            print(f\"üß™ [Trockenlauf] {alt.name} ‚Üí {neu.name}\")\n        else:\n            try:\n                alt.rename(neu)\n                print(f\"‚úÖ {alt.name} ‚Üí {neu.name}\")\n            except Exception as e:\n                print(f\"‚ùå Fehler: {e}\")\n                return None\n        \n        self.√§nderungen.append((str(alt), str(neu)))\n        return neu\n    \n    def batch_umbenennen(self, dateien, name_funktion):\n        \"\"\"\n        Benennt mehrere Dateien um\n        \n        Args:\n            dateien: Liste von Pfaden\n            name_funktion: Funktion die (pfad, index) ‚Üí neuer_name\n        \"\"\"\n        erfolge = 0\n        fehler = 0\n        \n        for i, datei in enumerate(dateien):\n            neuer_name = name_funktion(datei, i)\n            \n            if self.umbenennen(datei, neuer_name):\n                erfolge += 1\n            else:\n                fehler += 1\n        \n        return erfolge, fehler\n    \n    def r√ºckg√§ngig(self):\n        \"\"\"Macht alle √Ñnderungen r√ºckg√§ngig\"\"\"\n        if self.trockenlauf:\n            print(\"‚ö†Ô∏è War nur Trockenlauf - nichts r√ºckg√§ngig zu machen\")\n            return\n        \n        print(f\"\\n‚ôªÔ∏è Mache {len(self.√§nderungen)} √Ñnderungen r√ºckg√§ngig...\")\n        \n        for neu, alt in reversed(self.√§nderungen):\n            neu_pfad = Path(neu)\n            alt_pfad = Path(alt)\n            \n            if neu_pfad.exists():\n                try:\n                    neu_pfad.rename(alt_pfad)\n                    print(f\"‚úÖ {neu_pfad.name} ‚Üí {alt_pfad.name}\")\n                except Exception as e:\n                    print(f\"‚ùå Fehler: {e}\")\n        \n        self.√§nderungen = []\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üõ°Ô∏è SICHERES UMBENENNEN\")\nprint(\"=\" * 60)\n\n# Test-Dateien mit problematischen Namen\ntest = Path(\"test_sicher\")\ntest.mkdir(exist_ok=True)\n\nproblematische_namen = [\n    \"datei:mit:doppelpunkten.txt\",\n    \"datei<mit>klammern.txt\",\n    \"datei/mit/slashes.txt\",\n    \"normale_datei.txt\",\n    \"leerzeichen   mehrfach.txt\",\n]\n\nfor name in problematische_namen:\n    # Bereinige f√ºr Erstellung\n    sicherer_name = re.sub(r'[<>:\"/\\\\|?*]', '_', name)\n    (test / sicherer_name).write_text(\"test\")\n\n# Erstelle auch einige normale Dateien\nfor i in range(5):\n    (test / f\"foto{i}.jpg\").write_text(\"bild\")\n\nprint(f\"‚úÖ Test-Dateien erstellt\\n\")\n\n# Renamer erstellen (Trockenlauf!)\nrenamer = SichererRenamer(trockenlauf=True)\n\n# Test 1: Einzelne Datei\nprint(\"TEST 1: Einzelne Datei\")\nerste = list(test.glob(\"*.txt\"))[0]\nrenamer.umbenennen(erste, \"umbenannte_datei.txt\")\n\n# Test 2: Batch mit Nummerierung\nprint(\"\\nTEST 2: Batch-Nummerierung\")\nalle_jpg = sorted(test.glob(\"*.jpg\"))\n\ndef nummern_name(pfad, index):\n    return f\"bild_{index+1:03d}{pfad.suffix}\"\n\nerfolge, fehler = renamer.batch_umbenennen(alle_jpg, nummern_name)\nprint(f\"\\nüìä Erfolge: {erfolge}, Fehler: {fehler}\")\n\n# Test 3: Mit Kollision\nprint(\"\\nTEST 3: Kollisionserkennung\")\n(test / \"existiert.txt\").write_text(\"original\")\n(test / \"neu.txt\").write_text(\"alt\")\n\nrenamer.umbenennen(test / \"neu.txt\", \"existiert.txt\")\n\nprint(\"\\nüí° Das war ein Trockenlauf!\")\nprint(\"Setze trockenlauf=False um wirklich umzubenennen\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "Vollst√§ndiges Batch-Renamer Tool",
            "goal": "Production-Ready Tool mit GUI-√§hnlichen Features",
            "why": "Alle Konzepte in einem nutzbaren Tool!",
            "code": "from pathlib import Path\nimport re\nfrom datetime import datetime\nfrom collections import defaultdict\n\nclass BatchRenamer:\n    \"\"\"Vollst√§ndiges Batch-Umbenennen-Tool\"\"\"\n    \n    PRESETS = {\n        'nummerieren': lambda p, i: f\"{i+1:03d}_{p.stem}{p.suffix}\",\n        'datum': lambda p, i: f\"{datetime.now().strftime('%Y%m%d')}_{p.name}\",\n        'kleinbuchstaben': lambda p, i: p.name.lower(),\n        'keine_leerzeichen': lambda p, i: p.name.replace(' ', '_'),\n        'prefix': lambda p, i, prefix='': f\"{prefix}{p.name}\",\n        'suffix_vor_ext': lambda p, i, suffix='': f\"{p.stem}{suffix}{p.suffix}\",\n    }\n    \n    def __init__(self, ordner):\n        self.ordner = Path(ordner)\n        self.dateien = []\n        self.vorschau = []\n    \n    def dateien_laden(self, pattern=\"*\", rekursiv=False):\n        \"\"\"L√§dt Dateien nach Pattern\"\"\"\n        if rekursiv:\n            self.dateien = list(self.ordner.rglob(pattern))\n        else:\n            self.dateien = list(self.ordner.glob(pattern))\n        \n        # Nur Dateien, keine Ordner\n        self.dateien = [f for f in self.dateien if f.is_file()]\n        \n        print(f\"üìÅ {len(self.dateien)} Dateien geladen\")\n        return len(self.dateien)\n    \n    def vorschau_erstellen(self, name_funktion, **kwargs):\n        \"\"\"Erstellt Vorschau ohne umzubenennen\"\"\"\n        self.vorschau = []\n        \n        for i, datei in enumerate(self.dateien):\n            try:\n                if kwargs:\n                    neuer_name = name_funktion(datei, i, **kwargs)\n                else:\n                    neuer_name = name_funktion(datei, i)\n                \n                # Bereinige Namen\n                neuer_name = self._bereinige(neuer_name)\n                \n                neu_pfad = datei.parent / neuer_name\n                \n                self.vorschau.append({\n                    'alt': datei,\n                    'neu': neu_pfad,\n                    'alt_name': datei.name,\n                    'neu_name': neuer_name,\n                    'status': 'OK' if neu_pfad != datei else 'UNVER√ÑNDERT'\n                })\n            except Exception as e:\n                self.vorschau.append({\n                    'alt': datei,\n                    'neu': None,\n                    'alt_name': datei.name,\n                    'neu_name': None,\n                    'status': f'FEHLER: {e}'\n                })\n        \n        return self.vorschau\n    \n    def vorschau_anzeigen(self, max_zeilen=20):\n        \"\"\"Zeigt Vorschau\"\"\"\n        if not self.vorschau:\n            print(\"‚ö†Ô∏è Keine Vorschau vorhanden. Rufe vorschau_erstellen() auf\")\n            return\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"üëÅÔ∏è VORSCHAU ({len(self.vorschau)} Dateien)\")\n        print(f\"{'='*70}\")\n        \n        # Statistiken\n        status_count = defaultdict(int)\n        for item in self.vorschau:\n            status_count[item['status']] += 1\n        \n        print(f\"\\nStatus-√úbersicht:\")\n        for status, anzahl in status_count.items():\n            print(f\"  {status}: {anzahl}\")\n        \n        # Beispiele zeigen\n        print(f\"\\n{'Alt':<30} ‚Üí {'Neu':<30} Status\")\n        print(\"-\" * 70)\n        \n        for i, item in enumerate(self.vorschau[:max_zeilen]):\n            alt = item['alt_name']\n            neu = item['neu_name'] or '???'\n            status = item['status']\n            \n            # K√ºrzen wenn zu lang\n            if len(alt) > 28:\n                alt = alt[:25] + \"...\"\n            if len(neu) > 28:\n                neu = neu[:25] + \"...\"\n            \n            status_symbol = \"‚úÖ\" if status == \"OK\" else \"‚ö†Ô∏è\"\n            print(f\"{alt:<30} ‚Üí {neu:<30} {status_symbol}\")\n        \n        if len(self.vorschau) > max_zeilen:\n            print(f\"... und {len(self.vorschau) - max_zeilen} weitere\")\n    \n    def umbenennen(self, sicherheits_frage=True):\n        \"\"\"F√ºhrt Umbenennen durch\"\"\"\n        if not self.vorschau:\n            print(\"‚ùå Keine Vorschau vorhanden!\")\n            return 0, 0\n        \n        # Nur OK-Status umbenennen\n        zum_umbenennen = [item for item in self.vorschau if item['status'] == 'OK']\n        \n        if not zum_umbenennen:\n            print(\"‚ùå Keine Dateien zum Umbenennen!\")\n            return 0, 0\n        \n        if sicherheits_frage:\n            print(f\"\\n‚ö†Ô∏è {len(zum_umbenennen)} Dateien werden umbenannt!\")\n            antwort = input(\"Fortfahren? (j/n): \")\n            if antwort.lower() != 'j':\n                print(\"‚ùå Abgebrochen\")\n                return 0, 0\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"‚úèÔ∏è UMBENENNEN\")\n        print(f\"{'='*70}\")\n        \n        erfolge = 0\n        fehler = 0\n        \n        for item in zum_umbenennen:\n            try:\n                # Pr√ºfe Kollision\n                neu = item['neu']\n                if neu.exists() and neu != item['alt']:\n                    # Finde freien Namen\n                    counter = 1\n                    while True:\n                        test = item['neu'].parent / f\"{item['neu'].stem}_{counter}{item['neu'].suffix}\"\n                        if not test.exists():\n                            neu = test\n                            break\n                        counter += 1\n                \n                item['alt'].rename(neu)\n                print(f\"‚úÖ {item['alt_name']} ‚Üí {neu.name}\")\n                erfolge += 1\n                \n            except Exception as e:\n                print(f\"‚ùå {item['alt_name']}: {e}\")\n                fehler += 1\n        \n        print(f\"\\nüìä Erfolge: {erfolge}, Fehler: {fehler}\")\n        return erfolge, fehler\n    \n    def _bereinige(self, name):\n        \"\"\"Bereinigt Dateinamen\"\"\"\n        # Ung√ºltige Zeichen\n        name = re.sub(r'[<>:\"/\\\\|?*]', '_', name)\n        # Mehrfache Unterstriche\n        name = re.sub(r'_+', '_', name)\n        # Am Anfang/Ende\n        name = name.strip('_')\n        return name\n    \n    # === VORDEFINIERTE OPERATIONEN ===\n    \n    def nummerieren(self, start=1, stellen=3, pr√§fix='', suffix=''):\n        \"\"\"Nummeriert durch: pr√§fix_001_suffix.ext\"\"\"\n        def name_func(pfad, index):\n            nummer = f\"{start + index:0{stellen}d}\"\n            if pr√§fix and suffix:\n                return f\"{pr√§fix}_{nummer}_{suffix}{pfad.suffix}\"\n            elif pr√§fix:\n                return f\"{pr√§fix}_{nummer}{pfad.suffix}\"\n            elif suffix:\n                return f\"{nummer}_{suffix}{pfad.suffix}\"\n            else:\n                return f\"{nummer}{pfad.suffix}\"\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def text_ersetzen(self, suche, ersetze, regex=False):\n        \"\"\"Ersetzt Text in Dateinamen\"\"\"\n        def name_func(pfad, index):\n            if regex:\n                return re.sub(suche, ersetze, pfad.name)\n            else:\n                return pfad.name.replace(suche, ersetze)\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def pr√§fix_hinzuf√ºgen(self, pr√§fix):\n        \"\"\"F√ºgt Pr√§fix hinzu\"\"\"\n        def name_func(pfad, index):\n            return f\"{pr√§fix}{pfad.name}\"\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def suffix_hinzuf√ºgen(self, suffix):\n        \"\"\"F√ºgt Suffix vor Dateiendung hinzu\"\"\"\n        def name_func(pfad, index):\n            return f\"{pfad.stem}{suffix}{pfad.suffix}\"\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def kleinbuchstaben(self):\n        \"\"\"Alles Kleinbuchstaben\"\"\"\n        return self.vorschau_erstellen(lambda p, i: p.name.lower())\n    \n    def gro√übuchstaben(self):\n        \"\"\"Alles Gro√übuchstaben\"\"\"\n        return self.vorschau_erstellen(lambda p, i: p.name.upper())\n    \n    def leerzeichen_entfernen(self, ersetze_mit='_'):\n        \"\"\"Entfernt Leerzeichen\"\"\"\n        def name_func(pfad, index):\n            return pfad.name.replace(' ', ersetze_mit)\n        \n        return self.vorschau_erstellen(name_func)\n\n# === TESTEN ===\nprint(\"=\" * 70)\nprint(\"üéØ BATCH-RENAMER\")\nprint(\"=\" * 70)\n\n# Test-Dateien\ntest = Path(\"test_batch_renamer\")\ntest.mkdir(exist_ok=True)\n\ndateien = [\n    \"Urlaubsfoto 001.jpg\",\n    \"Urlaubsfoto 002.jpg\",\n    \"Urlaubsfoto 003.jpg\",\n    \"DSC_1234.jpg\",\n    \"DSC_1235.jpg\",\n    \"Dokument MIT LEERZEICHEN.pdf\",\n    \"alte_version.txt\",\n]\n\nfor datei in dateien:\n    (test / datei).write_text(\"test\")\n\nprint(f\"‚úÖ Test-Dateien erstellt\\n\")\n\n# Renamer erstellen\nrenamer = BatchRenamer(test)\n\n# Dateien laden\nrenamer.dateien_laden(\"*.jpg\")\n\n# Operation 1: Nummerieren\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 1: Nummerieren\")\nrenamer.nummerieren(start=1, stellen=3, pr√§fix=\"Urlaub\", suffix=\"2024\")\nrenamer.vorschau_anzeigen()\n\n# Operation 2: Pr√§fix\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 2: Pr√§fix hinzuf√ºgen\")\nrenamer.dateien_laden(\"*.jpg\")\nrenamer.pr√§fix_hinzuf√ºgen(\"2024_Sommer_\")\nrenamer.vorschau_anzeigen()\n\n# Operation 3: Text ersetzen\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 3: Text ersetzen\")\nrenamer.dateien_laden(\"DSC_*.jpg\")\nrenamer.text_ersetzen(\"DSC_\", \"Foto_\")\nrenamer.vorschau_anzeigen()\n\n# Operation 4: Leerzeichen entfernen\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 4: Leerzeichen entfernen\")\nrenamer.dateien_laden(\"*\")\nrenamer.leerzeichen_entfernen(ersetze_mit='_')\nrenamer.vorschau_anzeigen()\n\nprint(\"\\nüí° Alle Operationen waren Vorschauen!\")\nprint(\"Rufe renamer.umbenennen() auf um tats√§chlich umzubenennen\")",
            "checkpoint": ""
          }
        ]
      }
    ]
  },
  {
    "id": 4,
    "title": "Woche 4: Real-World Apps",
    "subtitle": "Real-World Apps",
    "description": "Praktische Anwendungen",
    "color": "green",
    "days": [
      {
        "id": 1,
        "weekId": 4,
        "title": "Konfigurations-Manager (JSON)",
        "duration": "10-15 Min",
        "task": {
          "title": "Konfigurations-Manager (JSON)",
          "description": "Lerne JSON kennen - das Standard-Format f√ºr Daten im Web!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "JSON Grundlagen",
            "goal": "Verstehen was JSON ist und wie man es nutzt",
            "why": "",
            "code": "import json\n\nprint(\"=\" * 60)\nprint(\"üìÑ JSON GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# PYTHON DATENSTRUKTUREN\nperson = {\n    \"name\": \"Anna Schmidt\",\n    \"alter\": 28,\n    \"stadt\": \"Berlin\",\n    \"hobbies\": [\"Lesen\", \"Wandern\", \"Programmieren\"],\n    \"aktiv\": True,\n    \"verheiratet\": False,\n    \"kinder\": None  # wird zu null in JSON\n}\n\n# PYTHON ‚Üí JSON (Serialisierung)\njson_string = json.dumps(person)  # dumps = dump string\nprint(\"\\nüì§ Python Dict ‚Üí JSON String:\")\nprint(json_string)\nprint(f\"Typ: {type(json_string)}\")  # str\n\n# Mit Formatierung (lesbar)\njson_formatiert = json.dumps(person, indent=2, ensure_ascii=False)\nprint(\"\\nüì§ Formatiertes JSON:\")\nprint(json_formatiert)\n\n# JSON ‚Üí PYTHON (Deserialisierung)\njson_text = '{\"name\": \"Max\", \"alter\": 35, \"hobbies\": [\"Sport\", \"Kochen\"]}'\nperson2 = json.loads(json_text)  # loads = load string\nprint(\"\\nüì• JSON String ‚Üí Python Dict:\")\nprint(person2)\nprint(f\"Typ: {type(person2)}\")  # dict\nprint(f\"Name: {person2['name']}\")\n\n# DATENTYP-MAPPING\nprint(\"\\nüîÑ Python ‚Üî JSON Datentypen:\")\nmapping = {\n    \"dict\": \"object\",\n    \"list\": \"array\",\n    \"str\": \"string\",\n    \"int/float\": \"number\",\n    \"True\": \"true\",\n    \"False\": \"false\",\n    \"None\": \"null\"\n}\n\nfor py, js in mapping.items():\n    print(f\"  {py:<15} ‚Üî {js}\")\n\n# VERSCHACHTELTE STRUKTUREN\nfirma = {\n    \"name\": \"TechCorp\",\n    \"mitarbeiter\": [\n        {\n            \"name\": \"Anna\",\n            \"position\": \"Developer\",\n            \"gehalt\": 60000\n        },\n        {\n            \"name\": \"Ben\",\n            \"position\": \"Designer\",\n            \"gehalt\": 55000\n        }\n    ],\n    \"standorte\": [\"Berlin\", \"M√ºnchen\", \"Hamburg\"]\n}\n\nprint(\"\\nüìä Verschachtelte Struktur:\")\nprint(json.dumps(firma, indent=2, ensure_ascii=False))",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "JSON Dateien lesen/schreiben",
            "goal": "JSON in Dateien speichern und laden",
            "why": "Perfekt f√ºr Konfigurationen und Daten-Austausch!",
            "code": "import json\nfrom pathlib import Path\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üíæ JSON DATEIEN\")\nprint(\"=\" * 60)\n\n# Daten vorbereiten\neinstellungen = {\n    \"app_name\": \"Meine App\",\n    \"version\": \"1.0.0\",\n    \"sprache\": \"de\",\n    \"theme\": \"dunkel\",\n    \"benachrichtigungen\": {\n        \"email\": True,\n        \"push\": False,\n        \"sound\": True\n    },\n    \"letzte_√§nderung\": \"2024-01-15\",\n    \"favoriten\": [\"Python\", \"JavaScript\", \"SQL\"]\n}\n\n# IN DATEI SCHREIBEN\nconfig_datei = Path(\"config.json\")\n\n# Methode 1: dump() - Direkt in Datei\nwith open(config_datei, \"w\", encoding=\"utf-8\") as f:\n    json.dump(einstellungen, f, indent=2, ensure_ascii=False)\n\nprint(f\"‚úÖ Gespeichert in: {config_datei}\")\n\n# AUS DATEI LESEN\n# Methode 1: load() - Direkt aus Datei\nwith open(config_datei, \"r\", encoding=\"utf-8\") as f:\n    geladene_config = json.load(f)\n\nprint(f\"\\nüìñ Geladen:\")\nprint(f\"App: {geladene_config['app_name']}\")\nprint(f\"Version: {geladene_config['version']}\")\nprint(f\"Email-Benachrichtigungen: {geladene_config['benachrichtigungen']['email']}\")\n\n# SCH√ñNER MIT PATHLIB\nconfig_pfad = Path(\"settings.json\")\n\n# Schreiben\nconfig_pfad.write_text(\n    json.dumps(einstellungen, indent=2, ensure_ascii=False),\n    encoding=\"utf-8\"\n)\nprint(f\"\\n‚úÖ Auch gespeichert in: {config_pfad}\")\n\n# Lesen\nconfig_text = config_pfad.read_text(encoding=\"utf-8\")\nconfig_dict = json.loads(config_text)\nprint(f\"üìñ Auch geladen: {config_dict['app_name']}\")\n\n# FEHLERBEHANDLUNG\nprint(\"\\n‚ö†Ô∏è Fehlerbehandlung:\")\n\nungueltig = '{\"name\": \"Test\", \"alter\": 30,}'  # Komma zu viel!\n\ntry:\n    daten = json.loads(ungueltig)\nexcept json.JSONDecodeError as e:\n    print(f\"‚ùå Ung√ºltiges JSON: {e}\")\n    print(f\"   Zeile {e.lineno}, Spalte {e.colno}\")\n\n# VERSCHIEDENE EINSTELLUNGEN\nbeispiel = {\n    \"text\": \"Hallo Welt\",\n    \"zahl\": 42,\n    \"liste\": [1, 2, 3]\n}\n\n# Kompakt (keine Leerzeichen)\nkompakt = json.dumps(beispiel, separators=(',', ':'))\nprint(f\"\\nüì¶ Kompakt: {kompakt}\")\n\n# Sortierte Keys\nsortiert = json.dumps(beispiel, indent=2, sort_keys=True)\nprint(f\"\\nüî§ Sortiert:\\n{sortiert}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Konfigurations-Manager",
            "goal": "Klasse zum Verwalten von App-Einstellungen",
            "why": "Professionelle Apps speichern Einstellungen in JSON!",
            "code": "import json\nfrom pathlib import Path\nfrom typing import Any, Dict\n\nclass ConfigManager:\n    \"\"\"Verwaltet App-Konfigurationen in JSON\"\"\"\n    \n    def __init__(self, config_datei=\"config.json\"):\n        self.config_datei = Path(config_datei)\n        self.config = {}\n        self.defaults = {}\n        \n        # Lade oder erstelle Config\n        if self.config_datei.exists():\n            self.laden()\n        else:\n            self.erstelle_standard_config()\n    \n    def erstelle_standard_config(self):\n        \"\"\"Erstellt Standard-Konfiguration\"\"\"\n        self.defaults = {\n            \"app\": {\n                \"name\": \"Meine App\",\n                \"version\": \"1.0.0\",\n                \"debug\": False\n            },\n            \"benutzer\": {\n                \"name\": \"\",\n                \"sprache\": \"de\",\n                \"theme\": \"hell\"\n            },\n            \"einstellungen\": {\n                \"auto_save\": True,\n                \"backup\": True,\n                \"max_dateien\": 100\n            }\n        }\n        \n        self.config = self.defaults.copy()\n        self.speichern()\n        print(f\"‚úÖ Standard-Config erstellt: {self.config_datei}\")\n    \n    def laden(self):\n        \"\"\"L√§dt Konfiguration aus Datei\"\"\"\n        try:\n            text = self.config_datei.read_text(encoding=\"utf-8\")\n            self.config = json.loads(text)\n            print(f\"‚úÖ Config geladen: {self.config_datei}\")\n            return True\n        except json.JSONDecodeError as e:\n            print(f\"‚ùå Fehler beim Laden: {e}\")\n            return False\n        except Exception as e:\n            print(f\"‚ùå Unerwarteter Fehler: {e}\")\n            return False\n    \n    def speichern(self):\n        \"\"\"Speichert Konfiguration in Datei\"\"\"\n        try:\n            text = json.dumps(\n                self.config,\n                indent=2,\n                ensure_ascii=False,\n                sort_keys=True\n            )\n            self.config_datei.write_text(text, encoding=\"utf-8\")\n            print(f\"‚úÖ Config gespeichert\")\n            return True\n        except Exception as e:\n            print(f\"‚ùå Fehler beim Speichern: {e}\")\n            return False\n    \n    def get(self, pfad: str, standard=None) -> Any:\n        \"\"\"\n        Holt Wert mit Punkt-Notation\n        \n        Beispiel: get(\"benutzer.name\")\n        \"\"\"\n        teile = pfad.split(\".\")\n        wert = self.config\n        \n        for teil in teile:\n            if isinstance(wert, dict) and teil in wert:\n                wert = wert[teil]\n            else:\n                return standard\n        \n        return wert\n    \n    def set(self, pfad: str, wert: Any, auto_save=True):\n        \"\"\"\n        Setzt Wert mit Punkt-Notation\n        \n        Beispiel: set(\"benutzer.name\", \"Anna\")\n        \"\"\"\n        teile = pfad.split(\".\")\n        ziel = self.config\n        \n        # Navigiere bis zum vorletzten Teil\n        for teil in teile[:-1]:\n            if teil not in ziel:\n                ziel[teil] = {}\n            ziel = ziel[teil]\n        \n        # Setze Wert\n        ziel[teile[-1]] = wert\n        \n        if auto_save:\n            self.speichern()\n    \n    def reset(self, pfad: str = None):\n        \"\"\"Setzt auf Standard zur√ºck\"\"\"\n        if pfad is None:\n            # Alles zur√ºcksetzen\n            self.config = self.defaults.copy()\n            self.speichern()\n            print(\"üîÑ Alle Einstellungen zur√ºckgesetzt\")\n        else:\n            # Einzelnen Wert zur√ºcksetzen\n            standard_wert = self._get_aus_dict(self.defaults, pfad)\n            if standard_wert is not None:\n                self.set(pfad, standard_wert)\n                print(f\"üîÑ '{pfad}' zur√ºckgesetzt\")\n    \n    def _get_aus_dict(self, dictionary, pfad):\n        \"\"\"Hilfsfunktion zum Navigieren in verschachtelten Dicts\"\"\"\n        teile = pfad.split(\".\")\n        wert = dictionary\n        \n        for teil in teile:\n            if isinstance(wert, dict) and teil in wert:\n                wert = wert[teil]\n            else:\n                return None\n        \n        return wert\n    \n    def zeige(self):\n        \"\"\"Zeigt gesamte Konfiguration\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"‚öôÔ∏è AKTUELLE KONFIGURATION\")\n        print(\"=\" * 60)\n        print(json.dumps(self.config, indent=2, ensure_ascii=False))\n    \n    def export(self, datei):\n        \"\"\"Exportiert Config in andere Datei\"\"\"\n        pfad = Path(datei)\n        pfad.write_text(\n            json.dumps(self.config, indent=2, ensure_ascii=False),\n            encoding=\"utf-8\"\n        )\n        print(f\"üì§ Exportiert nach: {datei}\")\n    \n    def import_from(self, datei):\n        \"\"\"Importiert Config aus anderer Datei\"\"\"\n        pfad = Path(datei)\n        if pfad.exists():\n            text = pfad.read_text(encoding=\"utf-8\")\n            self.config = json.loads(text)\n            self.speichern()\n            print(f\"üì• Importiert von: {datei}\")\n            return True\n        else:\n            print(f\"‚ùå Datei nicht gefunden: {datei}\")\n            return False\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 60)\nprint(\"‚öôÔ∏è KONFIGURATIONS-MANAGER\")\nprint(\"=\" * 60)\n\n# Manager erstellen\nconfig = ConfigManager(\"app_config.json\")\n\n# Werte auslesen\nprint(\"\\nüìñ Werte lesen:\")\nprint(f\"App-Name: {config.get('app.name')}\")\nprint(f\"Sprache: {config.get('benutzer.sprache')}\")\nprint(f\"Theme: {config.get('benutzer.theme')}\")\n\n# Werte setzen\nprint(\"\\n‚úèÔ∏è Werte √§ndern:\")\nconfig.set(\"benutzer.name\", \"Anna Schmidt\")\nconfig.set(\"benutzer.theme\", \"dunkel\")\nconfig.set(\"einstellungen.max_dateien\", 200)\n\n# Anzeigen\nconfig.zeige()\n\n# Neuen Wert hinzuf√ºgen\nprint(\"\\n‚ûï Neuen Wert hinzuf√ºgen:\")\nconfig.set(\"app.letzte_nutzung\", \"2024-01-15\")\n\n# Export\nprint(\"\\nüì§ Export/Import:\")\nconfig.export(\"backup_config.json\")\n\n# Reset einzelner Wert\nprint(\"\\nüîÑ Reset:\")\nconfig.reset(\"benutzer.theme\")\nprint(f\"Theme nach Reset: {config.get('benutzer.theme')}\")",
            "checkpoint": ""
          },
          {
            "number": 4,
            "title": "JSON mit Custom Objects",
            "goal": "Eigene Classes zu/von JSON konvertieren",
            "why": "Oft wollen wir komplexe Objekte speichern!",
            "code": "import json\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass Benutzer:\n    \"\"\"Benutzer-Klasse\"\"\"\n    \n    def __init__(self, name, email, erstellt=None):\n        self.name = name\n        self.email = email\n        self.erstellt = erstellt or datetime.now()\n    \n    def to_dict(self):\n        \"\"\"Konvertiert zu Dictionary\"\"\"\n        return {\n            \"name\": self.name,\n            \"email\": self.email,\n            \"erstellt\": self.erstellt.isoformat()  # Datum als String\n        }\n    \n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Erstellt aus Dictionary\"\"\"\n        return cls(\n            name=data[\"name\"],\n            email=data[\"email\"],\n            erstellt=datetime.fromisoformat(data[\"erstellt\"])\n        )\n    \n    def __str__(self):\n        return f\"Benutzer({self.name}, {self.email})\"\n\n# CUSTOM JSON ENCODER\nclass BenutzerEncoder(json.JSONEncoder):\n    \"\"\"Custom Encoder f√ºr Benutzer-Objekte\"\"\"\n    \n    def default(self, obj):\n        if isinstance(obj, Benutzer):\n            return obj.to_dict()\n        elif isinstance(obj, datetime):\n            return obj.isoformat()\n        \n        # F√ºr andere Typen: Standard-Verhalten\n        return super().default(obj)\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üéØ CUSTOM OBJECTS IN JSON\")\nprint(\"=\" * 60)\n\n# Benutzer erstellen\nuser1 = Benutzer(\"Anna\", \"anna@example.com\")\nuser2 = Benutzer(\"Max\", \"max@example.com\")\n\n# Zu JSON mit Custom Encoder\nbenutzer_liste = [user1, user2]\n\njson_string = json.dumps(\n    benutzer_liste,\n    cls=BenutzerEncoder,  # Unser Custom Encoder\n    indent=2\n)\n\nprint(\"\\nüì§ Benutzer ‚Üí JSON:\")\nprint(json_string)\n\n# Speichern\nPath(\"benutzer.json\").write_text(json_string, encoding=\"utf-8\")\nprint(\"\\n‚úÖ In benutzer.json gespeichert\")\n\n# Laden\njson_text = Path(\"benutzer.json\").read_text(encoding=\"utf-8\")\nbenutzer_daten = json.loads(json_text)\n\n# Zur√ºck zu Objekten\ngeladene_benutzer = [Benutzer.from_dict(data) for data in benutzer_daten]\n\nprint(\"\\nüì• JSON ‚Üí Benutzer:\")\nfor user in geladene_benutzer:\n    print(f\"  {user}\")\n    print(f\"    Erstellt: {user.erstellt}\")\n\n# EINFACHERE VARIANTE: dataclasses\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Produkt:\n    \"\"\"Produkt mit dataclass\"\"\"\n    name: str\n    preis: float\n    lagerbestand: int\n\n# Dataclass zu Dict (eingebaut!)\nprodukt = Produkt(\"Laptop\", 999.99, 5)\nprodukt_dict = asdict(produkt)\n\nprint(f\"\\nüì¶ Dataclass ‚Üí Dict:\")\nprint(produkt_dict)\n\n# Zu JSON\nprodukt_json = json.dumps(produkt_dict, indent=2)\nprint(f\"\\nüì¶ Als JSON:\")\nprint(produkt_json)",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 2,
        "weekId": 4,
        "title": "Ausgaben-Tracker (CSV)",
        "duration": "10-15 Min",
        "task": {
          "title": "Ausgaben-Tracker (CSV)",
          "description": "Lerne CSV-Dateien zu verarbeiten - perfekt f√ºr Tabellen-Daten!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "CSV Grundlagen",
            "goal": "CSV lesen und schreiben verstehen",
            "why": "",
            "code": "import csv\nfrom pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"üìä CSV GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# CSV SCHREIBEN\ndaten = [\n    [\"Name\", \"Alter\", \"Stadt\"],  # Header\n    [\"Anna\", 28, \"Berlin\"],\n    [\"Max\", 35, \"M√ºnchen\"],\n    [\"Lisa\", 42, \"Hamburg\"]\n]\n\ncsv_datei = Path(\"personen.csv\")\n\n# Methode 1: Mit csv.writer\nwith open(csv_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f)\n    writer.writerows(daten)  # Alle Zeilen auf einmal\n\nprint(f\"‚úÖ CSV erstellt: {csv_datei}\")\n\n# Datei anzeigen\nprint(f\"\\nüìÑ Inhalt:\")\nprint(csv_datei.read_text(encoding=\"utf-8\"))\n\n# CSV LESEN\n# Methode 1: Mit csv.reader\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.reader(f)\n    \n    print(\"üìñ Gelesen mit reader:\")\n    for zeile in reader:\n        print(f\"  {zeile}\")\n\n# Methode 2: Mit DictReader (besser!)\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    \n    print(\"\\nüìñ Gelesen mit DictReader:\")\n    for zeile in reader:\n        # Jede Zeile ist ein Dict!\n        print(f\"  Name: {zeile['Name']}, Alter: {zeile['Alter']}, Stadt: {zeile['Stadt']}\")\n\n# VERSCHIEDENE TRENNZEICHEN\n# Standardm√§√üig: Komma\n# Aber kann auch sein: Semikolon, Tab, Pipe\n\n# Semicolon-separated\ndaten_semi = [\n    [\"Produkt\", \"Preis\", \"Menge\"],\n    [\"Laptop\", \"999.99\", \"5\"],\n    [\"Maus\", \"19.99\", \"50\"]\n]\n\nsemi_datei = Path(\"produkte.csv\")\n\nwith open(semi_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f, delimiter=\";\")  # Semikolon!\n    writer.writerows(daten_semi)\n\nprint(f\"\\n‚úÖ CSV mit Semikolon: {semi_datei}\")\nprint(semi_datei.read_text())\n\n# Lesen mit Semikolon\nwith open(semi_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f, delimiter=\";\")\n    \n    for zeile in reader:\n        print(f\"  {zeile['Produkt']}: {zeile['Preis']}‚Ç¨\")\n\n# QUOTING (Anf√ºhrungszeichen)\n# Wichtig wenn Werte Kommas enthalten!\n\ndaten_mit_kommas = [\n    [\"Name\", \"Adresse\", \"Notiz\"],\n    [\"Anna\", \"Hauptstra√üe 1, 10115 Berlin\", \"Mag Pizza, Pasta\"],\n    [\"Max\", \"Bahnhofstr. 2, M√ºnchen\", \"Keine\"]\n]\n\nquoted_datei = Path(\"mit_kommas.csv\")\n\nwith open(quoted_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f, quoting=csv.QUOTE_MINIMAL)  # Nur wenn n√∂tig\n    writer.writerows(daten_mit_kommas)\n\nprint(f\"\\n‚úÖ CSV mit Kommas in Werten:\")\nprint(quoted_datei.read_text())",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "CSV mit DictWriter",
            "goal": "CSV mit Dictionary-Daten schreiben",
            "why": "Dicts sind lesbarer und flexibler!",
            "code": "import csv\nfrom pathlib import Path\nfrom datetime import datetime\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üìù CSV MIT DICTWRITER\")\nprint(\"=\" * 60)\n\n# Daten als Liste von Dicts\nmitarbeiter = [\n    {\"name\": \"Anna\", \"position\": \"Developer\", \"gehalt\": 60000, \"start\": \"2020-01-15\"},\n    {\"name\": \"Max\", \"position\": \"Designer\", \"gehalt\": 55000, \"start\": \"2019-06-01\"},\n    {\"name\": \"Lisa\", \"position\": \"Manager\", \"gehalt\": 70000, \"start\": \"2018-03-20\"}\n]\n\ncsv_datei = Path(\"mitarbeiter.csv\")\n\n# Mit DictWriter\nwith open(csv_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    # Spalten-Namen aus dem ersten Dict\n    fieldnames = [\"name\", \"position\", \"gehalt\", \"start\"]\n    \n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    \n    # Header schreiben\n    writer.writeheader()\n    \n    # Daten schreiben\n    writer.writerows(mitarbeiter)\n\nprint(f\"‚úÖ Mitarbeiter-CSV erstellt\")\nprint(csv_datei.read_text())\n\n# Lesen mit DictReader\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    \n    print(\"\\nüë• Mitarbeiter:\")\n    for person in reader:\n        print(f\"  {person['name']}: {person['position']} ({person['gehalt']}‚Ç¨)\")\n\n# EINZELNE ZEILEN HINZUF√úGEN (Append)\nneuer_mitarbeiter = {\n    \"name\": \"Tom\",\n    \"position\": \"Analyst\",\n    \"gehalt\": 52000,\n    \"start\": \"2024-01-01\"\n}\n\nwith open(csv_datei, \"a\", newline=\"\", encoding=\"utf-8\") as f:  # 'a' = append\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writerow(neuer_mitarbeiter)  # Einzelne Zeile\n\nprint(f\"\\n‚úÖ Neuer Mitarbeiter hinzugef√ºgt\")\n\n# Alle lesen\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    alle = list(reader)\n    print(f\"Jetzt {len(alle)} Mitarbeiter\")\n\n# FILTERN UND NEUE CSV ERSTELLEN\n# Nur Mitarbeiter mit Gehalt > 55000\nhohe_geh√§lter = [m for m in alle if int(m[\"gehalt\"]) > 55000]\n\ngefiltert_datei = Path(\"hohe_gehaelter.csv\")\n\nwith open(gefiltert_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writeheader()\n    writer.writerows(hohe_geh√§lter)\n\nprint(f\"\\nüí∞ Hohe Geh√§lter ({len(hohe_geh√§lter)} Mitarbeiter):\")\nprint(gefiltert_datei.read_text())",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Ausgaben-Tracker",
            "goal": "Praktisches Tool zum Tracken von Ausgaben",
            "why": "Real-World Anwendung von CSV!",
            "code": "import csv\nfrom pathlib import Path\nfrom datetime import datetime\nfrom collections import defaultdict\n\nclass AusgabenTracker:\n    \"\"\"Trackt Ausgaben in CSV\"\"\"\n    \n    KATEGORIEN = [\n        \"Lebensmittel\", \"Transport\", \"Wohnung\",\n        \"Unterhaltung\", \"Gesundheit\", \"Sonstiges\"\n    ]\n    \n    FIELDNAMES = [\"datum\", \"betrag\", \"kategorie\", \"beschreibung\", \"zahlungsart\"]\n    \n    def __init__(self, datei=\"ausgaben.csv\"):\n        self.datei = Path(datei)\n        \n        # Erstelle Datei wenn nicht vorhanden\n        if not self.datei.exists():\n            self._erstelle_datei()\n    \n    def _erstelle_datei(self):\n        \"\"\"Erstellt leere CSV mit Header\"\"\"\n        with open(self.datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.DictWriter(f, fieldnames=self.FIELDNAMES)\n            writer.writeheader()\n        print(f\"‚úÖ Neue Ausgaben-Datei erstellt: {self.datei}\")\n    \n    def ausgabe_hinzuf√ºgen(self, betrag, kategorie, beschreibung, zahlungsart=\"Bar\"):\n        \"\"\"F√ºgt neue Ausgabe hinzu\"\"\"\n        if kategorie not in self.KATEGORIEN:\n            print(f\"‚ö†Ô∏è Unbekannte Kategorie: {kategorie}\")\n            print(f\"Verf√ºgbar: {', '.join(self.KATEGORIEN)}\")\n            return False\n        \n        ausgabe = {\n            \"datum\": datetime.now().strftime(\"%Y-%m-%d\"),\n            \"betrag\": f\"{betrag:.2f}\",\n            \"kategorie\": kategorie,\n            \"beschreibung\": beschreibung,\n            \"zahlungsart\": zahlungsart\n        }\n        \n        with open(self.datei, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.DictWriter(f, fieldnames=self.FIELDNAMES)\n            writer.writerow(ausgabe)\n        \n        print(f\"‚úÖ Ausgabe hinzugef√ºgt: {betrag:.2f}‚Ç¨ - {beschreibung}\")\n        return True\n    \n    def alle_ausgaben(self):\n        \"\"\"Liest alle Ausgaben\"\"\"\n        with open(self.datei, \"r\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            return list(reader)\n    \n    def ausgaben_nach_kategorie(self, kategorie):\n        \"\"\"Filtert nach Kategorie\"\"\"\n        alle = self.alle_ausgaben()\n        return [a for a in alle if a[\"kategorie\"] == kategorie]\n    \n    def ausgaben_nach_monat(self, jahr, monat):\n        \"\"\"Filtert nach Monat\"\"\"\n        alle = self.alle_ausgaben()\n        monat_str = f\"{jahr}-{monat:02d}\"\n        return [a for a in alle if a[\"datum\"].startswith(monat_str)]\n    \n    def summe_gesamt(self):\n        \"\"\"Berechnet Gesamtsumme\"\"\"\n        alle = self.alle_ausgaben()\n        return sum(float(a[\"betrag\"]) for a in alle)\n    \n    def summe_nach_kategorie(self):\n        \"\"\"Summen pro Kategorie\"\"\"\n        alle = self.alle_ausgaben()\n        summen = defaultdict(float)\n        \n        for ausgabe in alle:\n            summen[ausgabe[\"kategorie\"]] += float(ausgabe[\"betrag\"])\n        \n        return dict(summen)\n    \n    def summe_nach_monat(self):\n        \"\"\"Summen pro Monat\"\"\"\n        alle = self.alle_ausgaben()\n        summen = defaultdict(float)\n        \n        for ausgabe in alle:\n            monat = ausgabe[\"datum\"][:7]  # YYYY-MM\n            summen[monat] += float(ausgabe[\"betrag\"])\n        \n        return dict(summen)\n    \n    def bericht(self):\n        \"\"\"Zeigt umfassenden Bericht\"\"\"\n        alle = self.alle_ausgaben()\n        \n        if not alle:\n            print(\"\\nüì≠ Keine Ausgaben vorhanden\")\n            return\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(\"üí∞ AUSGABEN-BERICHT\")\n        print(\"=\" * 70)\n        \n        # Gesamt\n        gesamt = self.summe_gesamt()\n        print(f\"\\nGesamtausgaben: {gesamt:.2f}‚Ç¨\")\n        print(f\"Anzahl Transaktionen: {len(alle)}\")\n        print(f\"Durchschnitt: {gesamt / len(alle):.2f}‚Ç¨\")\n        \n        # Nach Kategorie\n        print(f\"\\nüìä Nach Kategorie:\")\n        kat_summen = self.summe_nach_kategorie()\n        for kat in sorted(kat_summen, key=kat_summen.get, reverse=True):\n            betrag = kat_summen[kat]\n            prozent = (betrag / gesamt) * 100\n            print(f\"  {kat:<15} {betrag:>8.2f}‚Ç¨  ({prozent:>5.1f}%)\")\n        \n        # Nach Monat\n        print(f\"\\nüìÖ Nach Monat:\")\n        monat_summen = self.summe_nach_monat()\n        for monat in sorted(monat_summen.keys()):\n            print(f\"  {monat}: {monat_summen[monat]:.2f}‚Ç¨\")\n        \n        # Letzte 5 Ausgaben\n        print(f\"\\nüïê Letzte 5 Ausgaben:\")\n        for ausgabe in reversed(alle[-5:]):\n            print(f\"  {ausgabe['datum']} | {float(ausgabe['betrag']):>7.2f}‚Ç¨ | {ausgabe['kategorie']:<15} | {ausgabe['beschreibung']}\")\n    \n    def export_monat(self, jahr, monat, ziel_datei):\n        \"\"\"Exportiert einen Monat\"\"\"\n        ausgaben = self.ausgaben_nach_monat(jahr, monat)\n        \n        pfad = Path(ziel_datei)\n        with open(pfad, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.DictWriter(f, fieldnames=self.FIELDNAMES)\n            writer.writeheader()\n            writer.writerows(ausgaben)\n        \n        summe = sum(float(a[\"betrag\"]) for a in ausgaben)\n        print(f\"üì§ {len(ausgaben)} Ausgaben exportiert ({summe:.2f}‚Ç¨)\")\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 70)\nprint(\"üí∞ AUSGABEN-TRACKER\")\nprint(\"=\" * 70)\n\ntracker = AusgabenTracker(\"meine_ausgaben.csv\")\n\n# Ausgaben hinzuf√ºgen\nprint(\"\\n‚ûï F√ºge Ausgaben hinzu:\")\ntracker.ausgabe_hinzuf√ºgen(45.50, \"Lebensmittel\", \"Wocheneinkauf Supermarkt\")\ntracker.ausgabe_hinzuf√ºgen(12.00, \"Transport\", \"U-Bahn Monatskarte\", \"Karte\")\ntracker.ausgabe_hinzuf√ºgen(8.50, \"Unterhaltung\", \"Kino\", \"Bar\")\ntracker.ausgabe_hinzuf√ºgen(85.00, \"Lebensmittel\", \"Restaurant\", \"Karte\")\ntracker.ausgabe_hinzuf√ºgen(30.00, \"Gesundheit\", \"Apotheke\", \"Bar\")\n\n# Bericht\ntracker.bericht()\n\n# Nach Kategorie filtern\nprint(\"\\nüçî Nur Lebensmittel:\")\nlebensmittel = tracker.ausgaben_nach_kategorie(\"Lebensmittel\")\nfor ausgabe in lebensmittel:\n    print(f\"  {ausgabe['datum']}: {ausgabe['beschreibung']} - {ausgabe['betrag']}‚Ç¨\")",
            "checkpoint": ""
          }
        ]
      },
      {
        "id": 3,
        "weekId": 4,
        "title": "Geburtstags-Reminder (Datetime)",
        "duration": "10-15 Min",
        "task": {
          "title": "Geburtstags-Reminder (Datetime)",
          "description": "Meistere das Datetime-Modul f√ºr Datum- und Zeit-Operationen!",
          "goals": []
        },
        "steps": [
          {
            "number": 1,
            "title": "Datetime Grundlagen",
            "goal": "Mit Datum und Zeit arbeiten",
            "why": "Zeit-Daten sind in fast jeder App wichtig!",
            "code": "from datetime import datetime, date, time, timedelta\nimport time as time_module\n\nprint(\"=\" * 60)\nprint(\"‚è∞ DATETIME GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# AKTUELLES DATUM/ZEIT\njetzt = datetime.now()\nprint(f\"\\nüïê Jetzt: {jetzt}\")\nprint(f\"Typ: {type(jetzt)}\")\n\n# Komponenten\nprint(f\"\\nJahr: {jetzt.year}\")\nprint(f\"Monat: {jetzt.month}\")\nprint(f\"Tag: {jetzt.day}\")\nprint(f\"Stunde: {jetzt.hour}\")\nprint(f\"Minute: {jetzt.minute}\")\nprint(f\"Sekunde: {jetzt.second}\")\n\n# NUR DATUM\nheute = date.today()\nprint(f\"\\nüìÖ Heute: {heute}\")\nprint(f\"Wochentag: {heute.weekday()}\")  # 0=Montag, 6=Sonntag\nprint(f\"Wochentag (ISO): {heute.isoweekday()}\")  # 1=Montag, 7=Sonntag\n\nwochentage = [\"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \n              \"Freitag\", \"Samstag\", \"Sonntag\"]\nprint(f\"Heute ist {wochentage[heute.weekday()]}\")\n\n# NUR ZEIT\njetzt_zeit = datetime.now().time()\nprint(f\"\\nüïê Aktuelle Uhrzeit: {jetzt_zeit}\")\n\n# DATUM ERSTELLEN\ngeburtstag = date(1990, 5, 15)\nprint(f\"\\nüéÇ Geburtstag: {geburtstag}\")\n\n# DATETIME ERSTELLEN\ntermin = datetime(2024, 12, 24, 18, 30, 0)\nprint(f\"üìÖ Termin: {termin}\")\n\n# STRING ‚Üí DATETIME (Parsen)\ndatum_str = \"2024-01-15\"\ndatum = datetime.strptime(datum_str, \"%Y-%m-%d\")\nprint(f\"\\nüìù Geparsed: '{datum_str}' ‚Üí {datum}\")\n\ndatum_str2 = \"15.01.2024 14:30\"\ndatum2 = datetime.strptime(datum_str2, \"%d.%m.%Y %H:%M\")\nprint(f\"üìù Geparsed: '{datum_str2}' ‚Üí {datum2}\")\n\n# DATETIME ‚Üí STRING (Formatieren)\nformatiert = jetzt.strftime(\"%d.%m.%Y %H:%M:%S\")\nprint(f\"\\nüìù Formatiert: {formatiert}\")\n\n# Verschiedene Formate\nprint(\"\\nüìã Verschiedene Formate:\")\nprint(f\"Standard: {jetzt.strftime('%Y-%m-%d')}\")\nprint(f\"Deutsch: {jetzt.strftime('%d.%m.%Y')}\")\nprint(f\"US: {jetzt.strftime('%m/%d/%Y')}\")\nprint(f\"Voll: {jetzt.strftime('%A, %d. %B %Y %H:%M:%S')}\")\nprint(f\"ISO: {jetzt.isoformat()}\")\n\n# FORMAT-CODES √úBERSICHT\nprint(\"\\nüìñ Format-Codes:\")\ncodes = {\n    \"%Y\": \"Jahr (4-stellig)\",\n    \"%m\": \"Monat (01-12)\",\n    \"%d\": \"Tag (01-31)\",\n    \"%H\": \"Stunde (00-23)\",\n    \"%M\": \"Minute (00-59)\",\n    \"%S\": \"Sekunde (00-59)\",\n    \"%A\": \"Wochentag (ausgeschrieben)\",\n    \"%B\": \"Monat (ausgeschrieben)\",\n    \"%a\": \"Wochentag (kurz)\",\n    \"%b\": \"Monat (kurz)\"\n}\n\nfor code, beschreibung in codes.items():\n    print(f\"  {code}: {beschreibung}\")",
            "checkpoint": ""
          },
          {
            "number": 2,
            "title": "Zeitdifferenzen (Timedelta)",
            "goal": "Mit Zeitspannen rechnen",
            "why": "\"In 7 Tagen\", \"Vor 3 Stunden\" - das braucht timedelta!",
            "code": "from datetime import datetime, timedelta\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"‚è±Ô∏è TIMEDELTA - ZEITDIFFERENZEN\")\nprint(\"=\" * 60)\n\n# TIMEDELTA ERSTELLEN\nein_tag = timedelta(days=1)\neine_woche = timedelta(weeks=1)\nzwei_stunden = timedelta(hours=2)\ndrei√üig_minuten = timedelta(minutes=30)\n\nprint(\"\\nüìè Timedelta-Objekte:\")\nprint(f\"1 Tag: {ein_tag}\")\nprint(f\"1 Woche: {eine_woche}\")\nprint(f\"2 Stunden: {zwei_stunden}\")\n\n# RECHNEN MIT DATEN\nheute = datetime.now()\nmorgen = heute + ein_tag\ngestern = heute - ein_tag\nn√§chste_woche = heute + eine_woche\n\nprint(f\"\\n‚ûï‚ûñ Rechnen:\")\nprint(f\"Heute: {heute.strftime('%d.%m.%Y')}\")\nprint(f\"Morgen: {morgen.strftime('%d.%m.%Y')}\")\nprint(f\"Gestern: {gestern.strftime('%d.%m.%Y')}\")\nprint(f\"N√§chste Woche: {n√§chste_woche.strftime('%d.%m.%Y')}\")\n\n# DIFFERENZ ZWISCHEN DATEN\ngeburtstag = datetime(1990, 5, 15)\nalter_timedelta = heute - geburtstag\n\nprint(f\"\\nüéÇ Alter-Berechnung:\")\nprint(f\"Geburtstag: {geburtstag.strftime('%d.%m.%Y')}\")\nprint(f\"Differenz: {alter_timedelta.days} Tage\")\nprint(f\"Das sind {alter_timedelta.days // 365} Jahre\")\n\n# BIS ZUM N√ÑCHSTEN EREIGNIS\nweihnachten = datetime(2024, 12, 24)\nbis_weihnachten = weihnachten - heute\n\nif bis_weihnachten.days > 0:\n    print(f\"\\nüéÑ Bis Weihnachten:\")\n    print(f\"Noch {bis_weihnachten.days} Tage\")\n    wochen = bis_weihnachten.days // 7\n    print(f\"Das sind {wochen} Wochen\")\n\n# ARBEITSTAGE BERECHNEN\ndef arbeitstage_zwischen(start, ende):\n    \"\"\"Z√§hlt Arbeitstage (Mo-Fr) zwischen zwei Daten\"\"\"\n    tage = 0\n    aktuell = start\n    \n    while aktuell <= ende:\n        # 0-4 = Mo-Fr\n        if aktuell.weekday() < 5:\n            tage += 1\n        aktuell += timedelta(days=1)\n    \n    return tage\n\nstart = datetime(2024, 1, 1)\nende = datetime(2024, 1, 31)\narbeitstage = arbeitstage_zwischen(start, ende)\n\nprint(f\"\\nüíº Arbeitstage:\")\nprint(f\"Januar 2024: {arbeitstage} Arbeitstage\")\n\n# KOMPONENTEN VON TIMEDELTA\ndelta = timedelta(days=10, hours=5, minutes=30, seconds=15)\n\nprint(f\"\\nüìä Timedelta-Komponenten:\")\nprint(f\"Timedelta: {delta}\")\nprint(f\"Total Sekunden: {delta.total_seconds()}\")\nprint(f\"Tage: {delta.days}\")\nprint(f\"Sekunden (Rest): {delta.seconds}\")",
            "checkpoint": ""
          },
          {
            "number": 3,
            "title": "Geburtstags-Reminder System",
            "goal": "Praktisches Tool f√ºr Geburtstage",
            "why": "Kombiniert alle Datetime-Konzepte!",
            "code": "from datetime import datetime, timedelta\nimport json\nfrom pathlib import Path\n\nclass GeburtstagReminder:\n    \"\"\"Verwaltet Geburtstage und erinnert\"\"\"\n    \n    def __init__(self, datei=\"geburtstage.json\"):\n        self.datei = Path(datei)\n        self.geburtstage = {}\n        self.laden()\n    \n    def laden(self):\n        \"\"\"L√§dt Geburtstage aus JSON\"\"\"\n        if self.datei.exists():\n            text = self.datei.read_text(encoding=\"utf-8\")\n            self.geburtstage = json.loads(text)\n            print(f\"‚úÖ {len(self.geburtstage)} Geburtstage geladen\")\n        else:\n            print(\"‚ÑπÔ∏è Keine Geburtstage vorhanden\")\n    \n    def speichern(self):\n        \"\"\"Speichert Geburtstage\"\"\"\n        text = json.dumps(self.geburtstage, indent=2, ensure_ascii=False)\n        self.datei.write_text(text, encoding=\"utf-8\")\n    \n    def hinzuf√ºgen(self, name, datum_str):\n        \"\"\"\n        F√ºgt Geburtstag hinzu\n        \n        datum_str Format: \"YYYY-MM-DD\" oder \"DD.MM.YYYY\"\n        \"\"\"\n        try:\n            # Versuche verschiedene Formate\n            for fmt in [\"%Y-%m-%d\", \"%d.%m.%Y\"]:\n                try:\n                    datum = datetime.strptime(datum_str, fmt)\n                    break\n                except ValueError:\n                    continue\n            else:\n                print(f\"‚ùå Ung√ºltiges Datumsformat: {datum_str}\")\n                return False\n            \n            self.geburtstage[name] = datum.strftime(\"%Y-%m-%d\")\n            self.speichern()\n            print(f\"‚úÖ Geburtstag hinzugef√ºgt: {name} ({datum.strftime('%d.%m.%Y')})\")\n            return True\n            \n        except Exception as e:\n            print(f\"‚ùå Fehler: {e}\")\n            return False\n    \n    def entfernen(self, name):\n        \"\"\"Entfernt Geburtstag\"\"\"\n        if name in self.geburtstage:\n            del self.geburtstage[name]\n            self.speichern()\n            print(f\"üóëÔ∏è Geburtstag entfernt: {name}\")\n            return True\n        else:\n            print(f\"‚ùå Nicht gefunden: {name}\")\n            return False\n    \n    def n√§chster_geburtstag(self, name):\n        \"\"\"Berechnet n√§chsten Geburtstag einer Person\"\"\"\n        if name not in self.geburtstage:\n            return None\n        \n        geburtsdatum = datetime.strptime(self.geburtstage[name], \"%Y-%m-%d\")\n        heute = datetime.now()\n        \n        # N√§chster Geburtstag in diesem Jahr\n        n√§chster = geburtsdatum.replace(year=heute.year)\n        \n        # Wenn schon vorbei, n√§chstes Jahr\n        if n√§chster < heute:\n            n√§chster = geburtsdatum.replace(year=heute.year + 1)\n        \n        return n√§chster\n    \n    def alter(self, name):\n        \"\"\"Berechnet aktuelles Alter\"\"\"\n        if name not in self.geburtstage:\n            return None\n        \n        geburtsdatum = datetime.strptime(self.geburtstage[name], \"%Y-%m-%d\")\n        heute = datetime.now()\n        \n        alter = heute.year - geburtsdatum.year\n        \n        # Noch nicht Geburtstag gehabt dieses Jahr?\n        if (heute.month, heute.day) < (geburtsdatum.month, geburtsdatum.day):\n            alter -= 1\n        \n        return alter\n    \n    def bald_geburtstage(self, tage=30):\n        \"\"\"Findet Geburtstage in den n√§chsten N Tagen\"\"\"\n        heute = datetime.now()\n        grenze = heute + timedelta(days=tage)\n        \n        bald = []\n        \n        for name, datum_str in self.geburtstage.items():\n            n√§chster = self.n√§chster_geburtstag(name)\n            \n            if heute <= n√§chster <= grenze:\n                tage_bis = (n√§chster - heute).days\n                alter = self.alter(name) + 1  # Alter am Geburtstag\n                \n                bald.append({\n                    'name': name,\n                    'datum': n√§chster,\n                    'tage_bis': tage_bis,\n                    'alter': alter\n                })\n        \n        # Sortieren nach Datum\n        bald.sort(key=lambda x: x['datum'])\n        \n        return bald\n    \n    def heute_geburtstag(self):\n        \"\"\"Findet wer heute Geburtstag hat\"\"\"\n        heute = datetime.now()\n        \n        heute_liste = []\n        \n        for name, datum_str in self.geburtstage.items():\n            geburtsdatum = datetime.strptime(datum_str, \"%Y-%m-%d\")\n            \n            if (geburtsdatum.month, geburtsdatum.day) == (heute.month, heute.day):\n                alter = self.alter(name) + 1\n                heute_liste.append({\n                    'name': name,\n                    'alter': alter\n                })\n        \n        return heute_liste\n    \n    def √ºbersicht(self):\n        \"\"\"Zeigt alle Geburtstage\"\"\"\n        if not self.geburtstage:\n            print(\"\\nüì≠ Keine Geburtstage gespeichert\")\n            return\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(\"üéÇ GEBURTSTAGS-√úBERSICHT\")\n        print(\"=\" * 70)\n        \n        # Sortiert nach n√§chstem Geburtstag\n        personen = []\n        for name in self.geburtstage:\n            n√§chster = self.n√§chster_geburtstag(name)\n            tage_bis = (n√§chster - datetime.now()).days\n            alter = self.alter(name)\n            \n            personen.append({\n                'name': name,\n                'n√§chster': n√§chster,\n                'tage_bis': tage_bis,\n                'alter': alter\n            })\n        \n        personen.sort(key=lambda x: x['tage_bis'])\n        \n        print(f\"\\n{'Name':<20} {'Datum':<12} {'Alter':<6} {'In':<15}\")\n        print(\"-\" * 70)\n        \n        for p in personen:\n            datum_str = p['n√§chster'].strftime(\"%d.%m.%Y\")\n            \n            if p['tage_bis'] == 0:\n                bis_str = \"HEUTE! üéâ\"\n            elif p['tage_bis'] == 1:\n                bis_str = \"Morgen!\"\n            else:\n                bis_str = f\"{p['tage_bis']} Tagen\"\n            \n            print(f\"{p['name']:<20} {datum_str:<12} {p['alter']:<6} {bis_str:<15}\")\n    \n    def erinnerungen(self):\n        \"\"\"Zeigt aktuelle Erinnerungen\"\"\"\n        # Heute\n        heute = self.heute_geburtstag()\n        if heute:\n            print(\"\\nüéâ HEUTE GEBURTSTAG:\")\n            for person in heute:\n                print(f\"  üéÇ {person['name']} wird {person['alter']} Jahre alt!\")\n        \n        # Bald (n√§chste 7 Tage)\n        bald = self.bald_geburtstage(7)\n        if bald:\n            print(\"\\n‚è∞ DEMN√ÑCHST (n√§chste 7 Tage):\")\n            for person in bald:\n                if person['tage_bis'] > 0:  # Nicht heute (schon oben gezeigt)\n                    datum = person['datum'].strftime(\"%d.%m.\")\n                    print(f\"  üìÖ {person['name']}: {datum} (in {person['tage_bis']} Tagen, wird {person['alter']})\")\n        \n        if not heute and not bald:\n            print(\"\\n‚úÖ Keine Geburtstage in den n√§chsten 7 Tagen\")\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 70)\nprint(\"üéÇ GEBURTSTAGS-REMINDER\")\nprint(\"=\" * 70)\n\nreminder = GeburtstagReminder()\n\n# Geburtstage hinzuf√ºgen\nprint(\"\\n‚ûï F√ºge Geburtstage hinzu:\")\nreminder.hinzuf√ºgen(\"Anna\", \"1990-03-15\")\nreminder.hinzuf√ºgen(\"Max\", \"1985-07-22\")\nreminder.hinzuf√ºgen(\"Lisa\", \"1992-12-01\")\n\n# Einen nahen Geburtstag (f√ºr Demo)\nheute = datetime.now()\nmorgen = heute + timedelta(days=1)\nreminder.hinzuf√ºgen(\"Tom\", morgen.strftime(\"%Y-%m-%d\"))\n\n# √úbersicht\nreminder.√ºbersicht()\n\n# Erinnerungen\nreminder.erinnerungen()\n\n# Alter berechnen\nprint(f\"\\nüéÇ Anna ist {reminder.alter('Anna')} Jahre alt\")\n\n# N√§chster Geburtstag\nn√§chster = reminder.n√§chster_geburtstag(\"Anna\")\nprint(f\"N√§chster Geburtstag: {n√§chster.strftime('%d.%m.%Y')}\")",
            "checkpoint": ""
          }
        ]
      }
    ]
  }
]