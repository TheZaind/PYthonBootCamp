// ============================================
// COURSE DATA - VOLLSTÃ„NDIG AUS MARKDOWN EXTRAHIERT
// Alle 30 Tage mit detaillierten Schritten
// ============================================

const courseData = {
  weeks: [
    {
      id: 1,
      title: "Woche 1: Grundlagen",
      subtitle: "Die absoluten Grundlagen von Python",
      description: "Das Fundament fÃ¼r alles Weitere! Lerne Variablen, Schleifen, Bedingungen und Funktionen.",
      color: "orange",
      days: [
        {
                "id": 1,
                "weekId": 1,
                "title": "PersÃ¶nlicher Taschenrechner",
                "duration": "45-60 min",
                "task": {
                        "title": "PersÃ¶nlicher Taschenrechner",
                        "description": "Erstelle einen interaktiven Taschenrechner, der zwei Zahlen vom Benutzer entgegennimmt und verschiedene Berechnungen durchfÃ¼hrt.",
                        "goals": [
                                "Variablen: Speichern von Werten (`zahl1 = 5`)",
                                "Datentypen: Unterschied zwischen Text (String) und Zahlen (Float)",
                                "Input: Benutzer nach Eingaben fragen (`input()`)",
                                "Type Conversion: Text in Zahlen umwandeln (`float()`)",
                                "Operatoren: Alle 7 mathematischen Grundoperationen",
                                "F-Strings: Text mit Variablen kombinieren (`f\"...\"`)",
                                "Formatierung: Zahlen runden (`.2f`)"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Variablen verstehen und Input holen",
                                "goal": "Benutzer nach zwei Zahlen fragen und diese speichern",
                                "why": "Variablen sind wie beschriftete Boxen - sie speichern Informationen, die wir spÃ¤ter verwenden kÃ¶nnen. Der `input()` Befehl ist unsere Art, mit dem Benutzer zu kommunizieren.",
                                "instruction": "1. Ã–ffne einen neuen Python-File (z.B. `tag01_rechner.py`) 2. Schreibe den folgenden Code 3. Achte auf die Kommentare - sie erklÃ¤ren was passiert",
                                "code": "# Das 'input()' zeigt Text und wartet auf Eingabe des Benutzers\n# Was der Benutzer eingibt, wird als TEXT gespeichert\nzahl1_text = input(\"Gib die erste Zahl ein: \")\n\n# 'float()' wandelt den TEXT in eine ZAHL mit Komma um\n# Warum? Weil wir mit Zahlen rechnen wollen, nicht mit Text!\nzahl1 = float(zahl1_text)\n\n# Das gleiche fÃ¼r die zweite Zahl\nzahl2_text = input(\"Gib die zweite Zahl ein: \")\nzahl2 = float(zahl2_text)\n\n# Zur Kontrolle: Zeige was gespeichert wurde\nprint(f\"Du hast eingegeben: {zahl1} und {zahl2}\")",
                                "checkpoint": " FÃ¼hre den Code aus. Du solltest: 1. Nach der ersten Zahl gefragt werden (z.B. eingeben: `5.5`) 2. Nach der zweiten Zahl gefragt werden (z.B. eingeben: `3`) 3. Eine BestÃ¤tigung sehen: `Du hast eingegeben: 5.5 und 3.0`"
                        },
                        {
                                "number": 2,
                                "title": "Berechnungen durchfÃ¼hren",
                                "goal": "Mit den Zahlen verschiedene mathematische Operationen ausfÃ¼hren",
                                "why": "Operatoren (+, -, *, /) sind die grundlegenden Werkzeuge in Python. Jeder Operator hat eine spezifische Aufgabe.",
                                "instruction": "FÃ¼ge unter deinem bisherigen Code hinzu:",
                                "code": "# Grundrechenarten - jedes Ergebnis wird in einer neuen Variable gespeichert\nsumme = zahl1 + zahl2          # Addition: Zahlen zusammenzÃ¤hlen\ndifferenz = zahl1 - zahl2       # Subtraktion: Erste minus zweite Zahl\nprodukt = zahl1 * zahl2         # Multiplikation: Zahlen multiplizieren\nquotient = zahl1 / zahl2        # Division: Erste durch zweite Zahl teilen\n\n# Fortgeschrittene Operationen\npotenz = zahl1 ** zahl2         # ** bedeutet \"hoch\" (z.B. 2**3 = 2Ã—2Ã—2 = 8)\nrest = zahl1 % zahl2            # % gibt den Rest bei Division (z.B. 7%3 = 1)\nganzzahl_division = zahl1 // zahl2  # // teilt und rundet AB (z.B. 7//2 = 3)\n\n# Ausgabe aller Ergebnisse\nprint(\"\\n--- Ergebnisse ---\")\nprint(f\"Summe: {zahl1} + {zahl2} = {summe}\")\nprint(f\"Differenz: {zahl1} - {zahl2} = {differenz}\")\nprint(f\"Produkt: {zahl1} Ã— {zahl2} = {produkt}\")\nprint(f\"Quotient: {zahl1} Ã· {zahl2} = {quotient}\")\nprint(f\"Potenz: {zahl1} ^ {zahl2} = {potenz}\")\nprint(f\"Rest: {zahl1} % {zahl2} = {rest}\")\nprint(f\"Ganzzahl-Division: {zahl1} // {zahl2} = {ganzzahl_division}\")",
                                "checkpoint": " Teste mit den Zahlen `10` und `3`: - Summe sollte sein: `13.0` - Differenz: `7.0` - Produkt: `30.0` - Quotient: `3.333...` - Potenz: `1000.0` (10Ã—10Ã—10) - Rest: `1.0` (10Ã·3 = 3 Rest 1) - Ganzzahl-Division: `3.0`"
                        },
                        {
                                "number": 3,
                                "title": "Ergebnisse schÃ¶n formatieren",
                                "goal": "Zahlen auf 2 Nachkommastellen runden fÃ¼r bessere Lesbarkeit",
                                "why": "`3.333333333333` sieht unÃ¼bersichtlich aus. In echten Programmen formatieren wir Zahlen leserlich.",
                                "instruction": "Ersetze die print-Statements durch diese Version:",
                                "code": "# Das ':.2f' in den f-strings bedeutet: \"Zeige nur 2 Stellen nach dem Komma\"\n# f steht fÃ¼r \"float\" (Kommazahl)\nprint(\"\\n--- Ergebnisse (gerundet) ---\")\nprint(f\"Summe: {zahl1} + {zahl2} = {summe:.2f}\")\nprint(f\"Differenz: {zahl1} - {zahl2} = {differenz:.2f}\")\nprint(f\"Produkt: {zahl1} Ã— {zahl2} = {produkt:.2f}\")\nprint(f\"Quotient: {zahl1} Ã· {zahl2} = {quotient:.2f}\")\nprint(f\"Potenz: {zahl1} ^ {zahl2} = {potenz:.2f}\")\nprint(f\"Rest: {zahl1} % {zahl2} = {rest:.2f}\")\nprint(f\"Ganzzahl-Division: {zahl1} // {zahl2} = {ganzzahl_division:.2f}\")",
                                "checkpoint": " Jetzt sollte `10 Ã· 3` als `3.33` angezeigt werden statt `3.333333333333`"
                        }
                ]
        },
        {
                "id": 2,
                "weekId": 1,
                "title": "Namensgenerator",
                "duration": "45-60 min",
                "task": {
                        "title": "Namensgenerator",
                        "description": "Erstelle ein Programm, das aus Vor- und Nachnamen kreative Kombinationen und Informationen generiert.",
                        "goals": [
                                "Strings: Text-Datentyp und Konkatenation mit `+`",
                                "String-Methoden: `.upper()`, `.lower()`, `.title()`, `.count()`",
                                "Indexierung: Einzelne Zeichen mit `[0]`, `[-1]` zugreifen",
                                "Slicing: Teile eines Strings mit `[start:end]` extrahieren",
                                "len(): LÃ¤nge von Strings ermitteln",
                                "F-Strings: Elegante String-Formatierung"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "String-Basics und Input",
                                "goal": "Namen vom Benutzer holen und verstehen, was Strings sind",
                                "why": "Strings (Texte) sind einer der wichtigsten Datentypen. Fast jede App arbeitet mit Text - Namen, Adressen, Nachrichten usw.",
                                "instruction": "",
                                "code": "# Strings sind einfach Text in AnfÃ¼hrungszeichen\n# Anders als bei Zahlen brauchen wir KEIN float() - input() gibt bereits Text zurÃ¼ck\nvorname = input(\"Wie ist dein Vorname? \")\nnachname = input(\"Wie ist dein Nachname? \")\n\n# Strings kÃ¶nnen mit + verbunden werden (Konkatenation)\nvoller_name = vorname + \" \" + nachname  # Das + verbindet die Texte\nprint(f\"Hallo, {voller_name}!\")",
                                "checkpoint": " Bei Eingabe von \"Max\" und \"Mustermann\" sollte ausgegeben werden: `Hallo, Max Mustermann!`"
                        },
                        {
                                "number": 2,
                                "title": "String-Methoden anwenden",
                                "goal": "Text in GroÃŸbuchstaben, Kleinbuchstaben und Titelformat umwandeln",
                                "why": "Strings haben eingebaute Funktionen (Methoden), die uns viel Arbeit abnehmen. `.upper()`, `.lower()` usw. sind solche Helfer.",
                                "instruction": "",
                                "code": "# String-Methoden werden mit einem Punkt aufgerufen\n# Das Original bleibt unverÃ¤ndert - es wird eine NEUE Version erstellt\n\ngroÃŸbuchstaben = voller_name.upper()  # ALLES GROÃŸ\nkleinbuchstaben = voller_name.lower()  # alles klein\ntitel_format = voller_name.title()     # Jedes Wort GroÃŸ\n\nprint(\"\\n--- Verschiedene Schreibweisen ---\")\nprint(f\"GroÃŸbuchstaben: {groÃŸbuchstaben}\")\nprint(f\"Kleinbuchstaben: {kleinbuchstaben}\")\nprint(f\"Titel-Format: {titel_format}\")\n\n# Praktisches Beispiel: Initialen extrahieren\n# [0] bedeutet: \"Nimm den ersten Buchstaben\" (Python zÃ¤hlt ab 0!)\ninitialen = vorname[0] + nachname[0]\nprint(f\"Initialen: {initialen.upper()}\")  # Wir kÃ¶nnen Methoden auch direkt auf Ergebnisse anwenden",
                                "checkpoint": " - \"Max Mustermann\" â†’ GroÃŸbuchstaben: `MAX MUSTERMANN` - Initialen: `MM`"
                        },
                        {
                                "number": 3,
                                "title": "String-Informationen auslesen",
                                "goal": "LÃ¤nge ermitteln und einzelne Zeichen zugreifen",
                                "why": "Oft mÃ¼ssen wir wissen, wie lang ein Text ist (z.B. fÃ¼r Passwort-Validierung) oder bestimmte Teile extrahieren.",
                                "instruction": "",
                                "code": "# len() = length = LÃ¤nge: ZÃ¤hlt alle Zeichen inklusive Leerzeichen\nanzahl_buchstaben = len(voller_name)\nanzahl_vorname = len(vorname)\nanzahl_nachname = len(nachname)\n\nprint(\"\\n--- Namens-Statistiken ---\")\nprint(f\"Dein vollstÃ¤ndiger Name hat {anzahl_buchstaben} Zeichen\")\nprint(f\"Vorname: {anzahl_vorname} Buchstaben\")\nprint(f\"Nachname: {anzahl_nachname} Buchstaben\")\n\n# Indexierung: Mit [Zahl] greifen wir auf einzelne Zeichen zu\n# WICHTIG: Python zÃ¤hlt ab 0!\n# [0] = erstes Zeichen, [1] = zweites, usw.\n# [-1] = letztes Zeichen, [-2] = vorletztes, usw.\n\nerster_buchstabe = vorname[0]\nletzter_buchstabe = nachname[-1]  # Minus bedeutet: von hinten zÃ¤hlen\n\nprint(f\"\\nDein Vorname beginnt mit: {erster_buchstabe}\")\nprint(f\"Dein Nachname endet mit: {letzter_buchstabe}\")",
                                "checkpoint": " \"Max Mustermann\" hat 14 Zeichen (inklusive Leerzeichen!), beginnt mit `M`, endet mit `n`"
                        },
                        {
                                "number": 4,
                                "title": "Kreativer Namensgenerator",
                                "goal": "Lustige/kreative Kombinationen aus den Namen erstellen",
                                "why": "Hier kombinieren wir alles Gelernte zu etwas Unterhaltsamem - genau so entstehen echte Programme!",
                                "instruction": "",
                                "code": "# Slicing: [start:end] extrahiert einen Teil des Strings\n# [0:3] bedeutet: Von Position 0 bis (aber NICHT inklusive) 3\n# Also die ersten 3 Zeichen\n\nerste_haelfte_vor = vorname[0:len(vorname)//2]  # // teilt und rundet ab\nzweite_haelfte_nach = nachname[len(nachname)//2:]  # :] bedeutet: bis zum Ende\n\n# Kreiere einen \"Spitznamen\" aus den HÃ¤lften\nspitzname = erste_haelfte_vor + zweite_haelfte_nach\n\nprint(\"\\n--- Kreativer Namensgenerator ---\")\nprint(f\"Dein Spitzname kÃ¶nnte sein: {spitzname}\")\n\n# Umgekehrter Name\numgekehrt = nachname + \" \" + vorname\nprint(f\"In anderen Kulturen: {umgekehrt}\")\n\n# Name rÃ¼ckwÃ¤rts (mit Slicing [::-1] = von hinten nach vorne)\nrueckwaerts = voller_name[::-1]\nprint(f\"RÃ¼ckwÃ¤rts: {rueckwaerts}\")\n\n# Anzahl eines bestimmten Buchstabens\nbuchstabe = input(\"\\nWelcher Buchstabe interessiert dich? \").lower()\nanzahl = voller_name.lower().count(buchstabe)  # .count() zÃ¤hlt Vorkommen\nprint(f\"Der Buchstabe '{buchstabe}' kommt {anzahl}Ã— in deinem Namen vor\")",
                                "checkpoint": " Bei \"Max Mustermann\": - Spitzname: \"Maermann\" (Ma + ermann) - RÃ¼ckwÃ¤rts: \"nnamretsuM xaM\" - Der Buchstabe 'a' kommt 2Ã— vor"
                        }
                ]
        },
        {
                "id": 3,
                "weekId": 1,
                "title": "Einfacher Chatbot",
                "duration": "45-60 min",
                "task": {
                        "title": "Einfacher Chatbot",
                        "description": "Baue einen Chatbot, der auf verschiedene Benutzereingaben unterschiedlich reagiert.",
                        "goals": [
                                "If-Elif-Else: Entscheidungen im Code treffen",
                                "Vergleichsoperatoren: `==`, `!=`, `>`, `<`, `>=`, `<=`",
                                "Logische Operatoren: `and`, `or`, `not`",
                                "String-Operationen: `in` zum Suchen in Strings",
                                "Verschachtelte Bedingungen: If innerhalb von If",
                                "Type Conversion: `int()` fÃ¼r Ganzzahlen"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "If-Bedingungen verstehen",
                                "goal": "Programm soll verschiedene Wege gehen kÃ¶nnen, abhÃ¤ngig von der Eingabe",
                                "why": "In echten Programmen muss der Code Entscheidungen treffen kÃ¶nnen. \"Wenn der Benutzer X sagt, dann mache Y\" - das sind If-Bedingungen.",
                                "instruction": "",
                                "code": "print(\"ğŸ¤– Chatbot v1.0 - Ich kann auf deine Stimmung reagieren!\")\nprint(\"(Schreibe 'bye' um zu beenden)\\n\")\n\n# Eingabe vom Benutzer holen und in Kleinbuchstaben umwandeln\n# .lower() macht es egal, ob jemand \"GUT\", \"gut\" oder \"GuT\" schreibt\nstimmung = input(\"Wie geht es dir heute? \").lower()\n\n# IF-ELIF-ELSE ist wie eine Kaskade:\n# Python prÃ¼ft von oben nach unten, die ERSTE zutreffende Bedingung gewinnt\n\nif stimmung == \"gut\":  # == bedeutet: \"ist gleich\" (Vergleich, nicht Zuweisung!)\n    print(\"ğŸ˜Š Das freut mich! Weiter so!\")\n    \nelif stimmung == \"schlecht\":  # elif = else if = \"sonst wenn\"\n    print(\"ğŸ˜Ÿ Oh nein! Vielleicht hilft eine Pause?\")\n    \nelif stimmung == \"mÃ¼de\":\n    print(\"ğŸ˜´ Verstehe ich! Vielleicht einen Kaffee?\")\n    \nelse:  # else = \"in allen anderen FÃ¤llen\"\n    print(\"ğŸ¤” Interessant! ErzÃ¤hl mir mehr...\")",
                                "checkpoint": " - Eingabe \"gut\" â†’ ğŸ˜Š Reaktion - Eingabe \"schlecht\" â†’ ğŸ˜Ÿ Reaktion - Eingabe \"super\" â†’ ğŸ¤” Reaktion (weil nicht spezifisch abgefangen)"
                        },
                        {
                                "number": 2,
                                "title": "Mehrere Bedingungen kombinieren",
                                "goal": "Mit `or` und `and` mehrere MÃ¶glichkeiten abfangen",
                                "why": "Benutzer schreiben \"gut\", \"super\", \"toll\" - wir wollen nicht fÃ¼r jede Variante ein neues `elif` schreiben!",
                                "instruction": "",
                                "code": "# OR (oder): MINDESTENS EINE Bedingung muss wahr sein\n# AND (und): ALLE Bedingungen mÃ¼ssen wahr sein\n\nstimmung = input(\"Wie geht es dir heute? \").lower()\n\n# Mit 'or' fangen wir mehrere Varianten auf einmal ab\nif stimmung == \"gut\" or stimmung == \"super\" or stimmung == \"toll\":\n    print(\"ğŸ˜Š Fantastisch! Ich mag deine Energie!\")\n    \n# Alternativ: Mit 'in' prÃ¼fen, ob etwas in einer Liste ist (lernen wir in Tag 4)\nelif stimmung == \"schlecht\" or stimmung == \"mies\" or stimmung == \"Ã¼bel\":\n    print(\"ğŸ˜Ÿ Das tut mir leid. Morgen wird besser!\")\n    \n# Kombination: AND und OR zusammen (Klammern helfen bei Lesbarkeit)\nelif (stimmung == \"okay\" or stimmung == \"geht so\") and len(stimmung) < 10:\n    print(\"ğŸ˜ Naja, immerhin nicht schlecht!\")\n    \nelse:\n    print(\"ğŸ¤” Hmm, das kenne ich nicht. Sag mir mehr!\")",
                                "checkpoint": " - \"super\" oder \"toll\" â†’ gleiche Reaktion wie \"gut\" - \"okay\" â†’ mittlere Reaktion"
                        },
                        {
                                "number": 3,
                                "title": "Vergleichsoperatoren nutzen",
                                "goal": "Nicht nur auf Gleichheit, sondern auch grÃ¶ÃŸer/kleiner prÃ¼fen",
                                "why": "Oft wollen wir Bereiche prÃ¼fen: \"Ist die Zahl grÃ¶ÃŸer als 10?\", \"Ist der Text lÃ¤nger als 5 Zeichen?\"",
                                "instruction": "",
                                "code": "# Vergleichsoperatoren:\n# == gleich\n# != ungleich (nicht gleich)\n# > grÃ¶ÃŸer\n# < kleiner\n# >= grÃ¶ÃŸer oder gleich\n# <= kleiner oder gleich\n\nalter = int(input(\"Wie alt bist du? \"))  # int() wandelt in Ganzzahl um\n\nif alter < 13:\n    print(\"ğŸ§’ Du bist noch ein Kind!\")\nelif alter >= 13 and alter < 18:  # Bereich: 13 bis 17\n    print(\"ğŸ˜ Teenager-Jahre!\")\nelif alter >= 18 and alter < 65:\n    print(\"ğŸ’¼ Erwachsene/r im besten Alter!\")\nelse:  # 65 oder Ã¤lter\n    print(\"ğŸ‘´ Weisheit und Erfahrung!\")\n\n# Noch ein Beispiel: Namen-LÃ¤nge prÃ¼fen\nname = input(\"\\nWie heiÃŸt du? \")\nname_laenge = len(name)\n\nif name_laenge <= 3:\n    print(f\"Wow, {name} ist ein kurzer Name!\")\nelif name_laenge >= 10:\n    print(f\"{name} - das ist aber ein langer Name!\")\nelse:\n    print(f\"{name} ist ein schÃ¶ner Name!\")",
                                "checkpoint": " - Alter 15 â†’ \"Teenager-Jahre!\" - Name \"Max\" (3 Zeichen) â†’ \"kurzer Name\""
                        },
                        {
                                "number": 4,
                                "title": "VollstÃ¤ndiger Chatbot",
                                "goal": "Alle Konzepte zu einem interaktiven Chatbot kombinieren",
                                "why": "Jetzt setzen wir alles zusammen - das ist ein echtes Mini-Programm!",
                                "instruction": "",
                                "code": "print(\"=\" * 50)  # Trick: * wiederholt Strings! \"=\" * 50 = 50Ã— das = Zeichen\nprint(\"ğŸ¤– CHATBOT v2.0 - Dein digitaler Freund\")\nprint(\"=\" * 50)\n\n# BegrÃ¼ÃŸung\nname = input(\"\\nWie heiÃŸt du? \")\nprint(f\"Hallo {name}! SchÃ¶n dich kennenzulernen! ğŸ‘‹\")\n\n# Alter-Check\nalter = int(input(f\"Wie alt bist du, {name}? \"))\n\nif alter < 13:\n    emoji = \"ğŸ§’\"\n    kommentar = \"Cool, dass du schon programmieren lernst!\"\nelif alter < 18:\n    emoji = \"ğŸ˜\"\n    kommentar = \"Perfektes Alter, um zu coden!\"\nelif alter < 30:\n    emoji = \"ğŸ’ª\"\n    kommentar = \"In den besten Jahren!\"\nelse:\n    emoji = \"ğŸ§ \"\n    kommentar = \"Erfahrung ist Gold wert!\"\n\nprint(f\"{emoji} {kommentar}\")\n\n# Stimmungs-Check\nstimmung = input(f\"\\nWie fÃ¼hlst du dich heute, {name}? \").lower()\n\n# Verschachtelte Bedingungen: If INNERHALB von If\nif \"gut\" in stimmung or \"super\" in stimmung or \"toll\" in stimmung:\n    # 'in' prÃ¼ft ob ein Wort IM String vorkommt\n    # \"gut\" in \"sehr gut\" = True\n    print(\"ğŸ˜Š Das ist groÃŸartig!\")\n    \n    if alter < 18:\n        print(\"Jugend + gute Laune = unschlagbar! ğŸš€\")\n    else:\n        print(\"Positive Einstellung macht erfolgreich! â­\")\n        \nelif \"schlecht\" in stimmung or \"mies\" in stimmung:\n    print(\"ğŸ˜Ÿ Kopf hoch!\")\n    print(f\"Wusstest du, dass {name} ein toller Name ist? ğŸ’™\")\n    \nelse:\n    print(\"ğŸ¤” Danke fÃ¼rs Teilen!\")\n\n# Abschied\nprint(f\"\\nSchÃ¶n, dass wir geredet haben, {name}! Bis bald! ğŸ‘‹\")",
                                "checkpoint": " Teste verschiedene Kombinationen: - Verschiedene Altersgruppen - \"sehr gut\" sollte erkannt werden (wegen `in`) - JÃ¼ngere und Ã„ltere sollten unterschiedliche Kommentare bekommen"
                        }
                ]
        },
        {
                "id": 4,
                "weekId": 1,
                "title": "To-Do Liste (Konsole)",
                "duration": "45-60 min",
                "task": {
                        "title": "To-Do Liste (Konsole)",
                        "description": "Erstelle eine interaktive To-Do Liste, die Aufgaben speichern, anzeigen und lÃ¶schen kann.",
                        "goals": [
                                "Listen: Mehrere Werte in einer Variable `[]`",
                                "List-Methoden: `.append()`, `.insert()`, `.remove()`, `.pop()`",
                                "Indexierung: Zugriff auf Elemente mit `[0]`, `[1]`, usw.",
                                "len(): LÃ¤nge einer Liste ermitteln",
                                "in-Operator: PrÃ¼fen ob Element in Liste ist",
                                "range(): Zahlenfolgen erstellen",
                                ".isdigit(): PrÃ¼fen ob String eine Zahl ist"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Listen verstehen",
                                "goal": "Mehrere Werte in einer Variable speichern",
                                "why": "Eine Variable kann nur EINEN Wert speichern. Aber was, wenn wir 10 Aufgaben haben? Listen sind wie BehÃ¤lter fÃ¼r mehrere Werte!",
                                "instruction": "",
                                "code": "# Eine Liste wird mit eckigen Klammern [] erstellt\n# Sie kann mehrere Werte speichern - hier Strings (Texte)\n\naufgaben = []  # Leere Liste - wie ein leerer Einkaufskorb\n\n# Elemente zur Liste hinzufÃ¼gen mit .append()\n# append = anhÃ¤ngen (ans Ende der Liste)\naufgaben.append(\"Einkaufen gehen\")\naufgaben.append(\"Python lernen\")\naufgaben.append(\"Sport machen\")\n\nprint(\"Meine Aufgaben:\")\nprint(aufgaben)  # Zeigt die ganze Liste\n\n# Auf einzelne Elemente zugreifen - wie bei Strings mit [Index]\n# WICHTIG: Python zÃ¤hlt ab 0!\nerste_aufgabe = aufgaben[0]  # \"Einkaufen gehen\"\nzweite_aufgabe = aufgaben[1]  # \"Python lernen\"\n\nprint(f\"\\nErste Aufgabe: {erste_aufgabe}\")\nprint(f\"Zweite Aufgabe: {zweite_aufgabe}\")\n\n# Wie viele Aufgaben haben wir?\nanzahl = len(aufgaben)  # len() funktioniert auch bei Listen!\nprint(f\"\\nInsgesamt {anzahl} Aufgaben\")",
                                "checkpoint": " Du solltest sehen: ``` Meine Aufgaben: ['Einkaufen gehen', 'Python lernen', 'Sport machen']"
                        },
                        {
                                "number": 2,
                                "title": "Listen anzeigen und manipulieren",
                                "goal": "Listen-Methoden kennenlernen (hinzufÃ¼gen, lÃ¶schen, prÃ¼fen)",
                                "why": "Listen sind dynamisch - wir kÃ¶nnen jederzeit Elemente hinzufÃ¼gen oder entfernen. Das ist perfekt fÃ¼r To-Do Listen!",
                                "instruction": "",
                                "code": "aufgaben = []  # Starte mit leerer Liste\n\n# Methode 1: .append() - fÃ¼gt am Ende hinzu\naufgaben.append(\"Email checken\")\naufgaben.append(\"Kaffee trinken\")\n\nprint(\"Nach append:\")\nprint(aufgaben)  # ['Email checken', 'Kaffee trinken']\n\n# Methode 2: .insert(position, wert) - fÃ¼gt an bestimmter Stelle ein\naufgaben.insert(0, \"Aufwachen\")  # An Position 0 (also ganz vorne)\n\nprint(\"\\nNach insert:\")\nprint(aufgaben)  # ['Aufwachen', 'Email checken', 'Kaffee trinken']\n\n# Methode 3: .remove(wert) - lÃ¶scht ein bestimmtes Element\naufgaben.remove(\"Email checken\")\n\nprint(\"\\nNach remove:\")\nprint(aufgaben)  # ['Aufwachen', 'Kaffee trinken']\n\n# Methode 4: .pop() - entfernt das LETZTE Element (und gibt es zurÃ¼ck)\nletzte = aufgaben.pop()  # Entfernt \"Kaffee trinken\" und speichert es\n\nprint(f\"\\nEntfernt: {letzte}\")\nprint(f\"Ãœbrig: {aufgaben}\")  # ['Aufwachen']\n\n# Methode 5: PrÃ¼fen ob etwas in der Liste ist\nif \"Aufwachen\" in aufgaben:\n    print(\"\\n'Aufwachen' ist noch auf der Liste!\")",
                                "checkpoint": " Die Liste verÃ¤ndert sich mit jeder Operation. Am Ende bleibt nur noch \"Aufwachen\" Ã¼brig."
                        },
                        {
                                "number": 3,
                                "title": "Benutzerinteraktion einbauen",
                                "goal": "Der Benutzer kann interaktiv Aufgaben hinzufÃ¼gen",
                                "why": "Jetzt wird's praktisch! Der Benutzer bestimmt, was auf die Liste kommt.",
                                "instruction": "",
                                "code": "# Liste fÃ¼r unsere Aufgaben\ntodo_liste = []\n\nprint(\"ğŸ“ TO-DO LISTE\")\nprint(\"=\" * 40)\n\n# Der Benutzer kann mehrere Aufgaben hinzufÃ¼gen\n# Wir fragen einfach 3 Mal\nprint(\"\\nGib 3 Aufgaben ein:\")\n\n# Aufgabe 1\naufgabe1 = input(\"Aufgabe 1: \")\ntodo_liste.append(aufgabe1)  # Direkt zur Liste hinzufÃ¼gen\n\n# Aufgabe 2\naufgabe2 = input(\"Aufgabe 2: \")\ntodo_liste.append(aufgabe2)\n\n# Aufgabe 3\naufgabe3 = input(\"Aufgabe 3: \")\ntodo_liste.append(aufgabe3)\n\n# Liste anzeigen\nprint(\"\\n--- Deine Aufgaben ---\")\n# Mit Nummern anzeigen - manuell\nprint(f\"1. {todo_liste[0]}\")\nprint(f\"2. {todo_liste[1]}\")\nprint(f\"3. {todo_liste[2]}\")\n\nprint(f\"\\nInsgesamt: {len(todo_liste)} Aufgaben\")",
                                "checkpoint": " Nach Eingabe von 3 Aufgaben solltest du sie nummeriert sehen."
                        },
                        {
                                "number": 4,
                                "title": "Listen mit Bedingungen",
                                "goal": "Aufgaben lÃ¶schen basierend auf Benutzerentscheidung",
                                "why": "Kombination aus Listen und If-Bedingungen - so werden Programme mÃ¤chtig!",
                                "instruction": "",
                                "code": "todo_liste = []\n\nprint(\"ğŸ“ TO-DO LISTE v2.0\")\nprint(\"=\" * 40)\n\n# Aufgaben hinzufÃ¼gen\nprint(\"\\nFÃ¼ge Aufgaben hinzu (oder 'fertig' zum Beenden):\")\n\n# Erste Aufgabe\naufgabe = input(\"Aufgabe: \")\nif aufgabe != \"fertig\":  # Nur hinzufÃ¼gen, wenn nicht \"fertig\"\n    todo_liste.append(aufgabe)\n\n# Zweite Aufgabe\naufgabe = input(\"Aufgabe: \")\nif aufgabe != \"fertig\":\n    todo_liste.append(aufgabe)\n\n# Dritte Aufgabe\naufgabe = input(\"Aufgabe: \")\nif aufgabe != \"fertig\":\n    todo_liste.append(aufgabe)\n\n# Liste anzeigen\nif len(todo_liste) == 0:  # PrÃ¼fe ob Liste leer ist\n    print(\"\\nâŒ Keine Aufgaben vorhanden!\")\nelse:\n    print(f\"\\nâœ… Du hast {len(todo_liste)} Aufgaben:\")\n    \n    # Zeige nur so viele, wie tatsÃ¤chlich vorhanden sind\n    for i in range(len(todo_liste)):  # range() erstellt Zahlen von 0 bis len-1\n        print(f\"{i+1}. {todo_liste[i]}\")  # i+1 damit wir bei 1 starten, nicht 0\n    \n    # Aufgabe als erledigt markieren (= lÃ¶schen)\n    if len(todo_liste) > 0:\n        erledigt = input(\"\\nWelche Aufgabe hast du erledigt? (Nummer): \")\n        \n        # String in Zahl umwandeln und -1 (weil Python bei 0 zÃ¤hlt)\n        if erledigt.isdigit():  # PrÃ¼fe ob es eine Zahl ist\n            index = int(erledigt) - 1\n            \n            # PrÃ¼fe ob die Nummer gÃ¼ltig ist\n            if index >= 0 and index < len(todo_liste):\n                entfernt = todo_liste.pop(index)  # .pop(index) entfernt an Position\n                print(f\"âœ… '{entfernt}' wurde entfernt!\")\n                \n                # Zeige verbleibende Aufgaben\n                if len(todo_liste) > 0:\n                    print(f\"\\nVerbleibende Aufgaben: {len(todo_liste)}\")\n                    for i in range(len(todo_liste)):\n                        print(f\"{i+1}. {todo_liste[i]}\")\n                else:\n                    print(\"\\nğŸ‰ Alle Aufgaben erledigt!\")\n            else:\n                print(\"âŒ UngÃ¼ltige Nummer!\")\n        else:\n            print(\"âŒ Bitte eine Zahl eingeben!\")",
                                "checkpoint": " - FÃ¼ge 3 Aufgaben hinzu - WÃ¤hle Aufgabe \"2\" zum LÃ¶schen - Die mittlere Aufgabe sollte verschwinden, die anderen rutschen nach"
                        }
                ]
        },
        {
                "id": 5,
                "weekId": 1,
                "title": "Multiplikationstabelle Generator",
                "duration": "45-60 min",
                "task": {
                        "title": "Multiplikationstabelle Generator",
                        "description": "Erstelle ein Programm, das Multiplikationstabellen generiert - mit For-Schleifen!",
                        "goals": [
                                "For-Schleifen: Code wiederholen mit `for x in range()`",
                                "range(): Zahlenfolgen erstellen (start, stop, step)",
                                "Schleifen + Listen: Mit `for item in liste` Ã¼ber Listen iterieren",
                                "enumerate(): Index und Wert gleichzeitig bekommen",
                                "Verschachtelte Schleifen: Schleifen innerhalb von Schleifen",
                                "String-Formatierung: Zahlen ausrichten mit `{var:width}`",
                                "end=\"\": Zeilenumbruch bei print() verhindern"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "For-Schleife Grundlagen",
                                "goal": "Verstehen wie for-Schleifen funktionieren",
                                "why": "Stell dir vor, du willst 100 Zahlen ausgeben. WÃ¼rdest du 100Ã— `print()` schreiben? NEIN! Schleifen wiederholen Code automatisch.",
                                "instruction": "",
                                "code": "# For-Schleife = \"FÃœR jedes Element MACHE etwas\"\n# range(5) erstellt die Zahlen 0, 1, 2, 3, 4\n\nprint(\"ZÃ¤hlen von 0 bis 4:\")\nfor zahl in range(5):  # 'zahl' ist eine Variable, die jede Zahl nacheinander annimmt\n    print(zahl)  # Wird 5Ã— ausgefÃ¼hrt\n    \n# Das ist das gleiche wie:\n# print(0)\n# print(1)\n# print(2)\n# print(3)\n# print(4)\n\n# range() mit Start und Ende\nprint(\"\\nZÃ¤hlen von 1 bis 5:\")\nfor zahl in range(1, 6):  # Von 1 bis (aber NICHT inklusive) 6\n    print(zahl)\n\n# range() mit Schrittweite\nprint(\"\\nNur gerade Zahlen von 0 bis 10:\")\nfor zahl in range(0, 11, 2):  # Start bei 0, bis 11, in 2er-Schritten\n    print(zahl)  # 0, 2, 4, 6, 8, 10",
                                "checkpoint": " Du solltest sehen: - Erste Schleife: 0, 1, 2, 3, 4 - Zweite Schleife: 1, 2, 3, 4, 5 - Dritte Schleife: 0, 2, 4, 6, 8, 10"
                        },
                        {
                                "number": 2,
                                "title": "Listen durchlaufen",
                                "goal": "For-Schleifen mit Listen kombinieren",
                                "why": "Listen und Schleifen sind beste Freunde! Schleifen kÃ¶nnen jedes Element einer Liste durchgehen.",
                                "instruction": "",
                                "code": "# Liste erstellen\nfrÃ¼chte = [\"Apfel\", \"Banane\", \"Orange\", \"Erdbeere\"]\n\n# Methode 1: Direkt Ã¼ber die Elemente iterieren\nprint(\"Meine Lieblings-FrÃ¼chte:\")\nfor frucht in frÃ¼chte:  # 'frucht' nimmt nacheinander jeden Wert an\n    print(f\"- {frucht}\")\n\n# Methode 2: Mit Index (Position) arbeiten\nprint(\"\\nMit Nummern:\")\nfor i in range(len(frÃ¼chte)):  # len(frÃ¼chte) = 4, also range(4) = 0,1,2,3\n    print(f\"{i+1}. {frÃ¼chte[i]}\")  # i+1 damit wir bei 1 starten\n    \n# Methode 3: Beides gleichzeitig (Index UND Element)\nprint(\"\\nMit enumerate():\")\nfor index, frucht in enumerate(frÃ¼chte, start=1):  # enumerate gibt (Index, Wert) zurÃ¼ck\n    print(f\"{index}. {frucht}\")",
                                "checkpoint": " Alle drei Methoden zeigen die Liste mit Nummern. Die dritte (enumerate) ist am elegantesten!"
                        },
                        {
                                "number": 3,
                                "title": "Multiplikationstabelle bauen",
                                "goal": "Eine einfache Tabelle fÃ¼r eine Zahl erstellen",
                                "why": "Jetzt wird's praktisch - wir nutzen Schleifen fÃ¼r echte Berechnungen!",
                                "instruction": "",
                                "code": "print(\"ğŸ”¢ MULTIPLIKATIONSTABELLE\")\nprint(\"=\" * 40)\n\n# Benutzer wÃ¤hlt eine Zahl\nbasis = int(input(\"FÃ¼r welche Zahl mÃ¶chtest du die Tabelle? \"))\n\nprint(f\"\\nMultiplikationstabelle fÃ¼r {basis}:\")\nprint(\"-\" * 30)\n\n# Schleife von 1 bis 10\nfor i in range(1, 11):  # 1, 2, 3, ..., 10\n    ergebnis = basis * i  # Berechnung\n    print(f\"{basis} Ã— {i:2} = {ergebnis:3}\")  # :2 und :3 = rechtsbÃ¼ndig ausrichten\n    \n# ErklÃ¤rung der Formatierung:\n# {i:2} bedeutet: Nutze mindestens 2 Stellen (rechtsbÃ¼ndig)\n# So dass  1 als \" 1\" erscheint und alles schÃ¶n untereinander steht",
                                "checkpoint": " Bei Eingabe von `7`: ``` 7 Ã—  1 =   7 7 Ã—  2 =  14 7 Ã—  3 =  21 ... 7 Ã— 10 =  70 ``` Alle Zahlen sollten schÃ¶n ausgerichtet sein!"
                        },
                        {
                                "number": 4,
                                "title": "Verschachtelte Schleifen",
                                "goal": "Eine komplette Multiplikationstabelle (1Ã—1 bis 10Ã—10) erstellen",
                                "why": "Schleifen IN Schleifen sind mÃ¤chtig! Die Ã¤uÃŸere Schleife lÃ¤uft einmal durch, fÃ¼r JEDEN Durchlauf der Ã¤uÃŸeren lÃ¤uft die innere komplett durch.",
                                "instruction": "",
                                "code": "print(\"ğŸ”¢ KOMPLETTE MULTIPLIKATIONSTABELLE (1-10)\")\nprint(\"=\" * 60)\n\n# Ãœberschrift erstellen\nprint(\"     \", end=\"\")  # Leerraum am Anfang, 'end=\"\"' verhindert Zeilenumbruch\nfor i in range(1, 11):\n    print(f\"{i:4}\", end=\"\")  # Zahlen 1-10 als Spalten-Ãœberschrift\nprint()  # Zeilenumbruch\nprint(\"-\" * 60)\n\n# Ã„uÃŸere Schleife: Zeilen (1 bis 10)\nfor zeile in range(1, 11):\n    # Zeilen-Nummer ausgeben\n    print(f\"{zeile:2} | \", end=\"\")  # z.B. \" 1 | \"\n    \n    # Innere Schleife: Spalten (1 bis 10)\n    for spalte in range(1, 11):\n        ergebnis = zeile * spalte  # Die eigentliche Multiplikation\n        print(f\"{ergebnis:4}\", end=\"\")  # RechtsbÃ¼ndig mit 4 Zeichen\n    \n    print()  # Zeilenumbruch nach jeder Zeile\n\n# Wie es funktioniert:\n# zeile=1: 1Ã—1, 1Ã—2, 1Ã—3, ..., 1Ã—10  (innere Schleife lÃ¤uft 10Ã— durch)\n# zeile=2: 2Ã—1, 2Ã—2, 2Ã—3, ..., 2Ã—10  (innere Schleife lÃ¤uft 10Ã— durch)\n# ...\n# zeile=10: 10Ã—1, 10Ã—2, ..., 10Ã—10",
                                "checkpoint": " Du solltest eine komplette Tabelle sehen: ``` 1   2   3   4 ... 1 |    1   2   3   4 ... 2 |    2   4   6   8 ... 3 |    3   6   9  12 ... ... ```"
                        },
                        {
                                "number": 5,
                                "title": "Interaktiver Generator",
                                "goal": "Der Benutzer kann Start, Ende und Schrittweite wÃ¤hlen",
                                "why": "Jetzt kombinieren wir alles: Input, Bedingungen, Schleifen!",
                                "instruction": "",
                                "code": "print(\"ğŸ¯ MULTIPLIKATIONSTABELLE GENERATOR\")\nprint(\"=\" * 50)\n\n# Benutzer-Einstellungen\nstart = int(input(\"Start-Zahl: \"))\nende = int(input(\"End-Zahl: \"))\nschritte = int(input(\"Schrittweite (z.B. 2 fÃ¼r gerade Zahlen): \"))\n\n# Validierung (FehlerprÃ¼fung)\nif start > ende:\n    print(\"âŒ Start muss kleiner als Ende sein!\")\nelif schritte <= 0:\n    print(\"âŒ Schrittweite muss positiv sein!\")\nelse:\n    print(f\"\\nğŸ“Š Tabelle von {start} bis {ende} in {schritte}er-Schritten:\")\n    print(\"=\" * 50)\n    \n    # FÃ¼r jede Basis-Zahl\n    for basis in range(start, ende + 1, schritte):  # +1 weil Ende inklusiv sein soll\n        print(f\"\\nTabelle fÃ¼r {basis}:\")\n        print(\"-\" * 30)\n        \n        # FÃ¼r jeden Multiplikator\n        for multi in range(1, 11):\n            ergebnis = basis * multi\n            print(f\"{basis} Ã— {multi:2} = {ergebnis:4}\")\n        \n        # Kurze Pause zwischen Tabellen (optisch)\n        if basis != ende:  # Nicht nach der letzten Tabelle\n            print()\n\nprint(\"\\nâœ… Generator beendet!\")",
                                "checkpoint": " Teste mit verschiedenen Eingaben: - Start: 2, Ende: 6, Schritte: 2 â†’ Tabellen fÃ¼r 2, 4, 6 - Start: 5, Ende: 5, Schritte: 1 â†’ Nur eine Tabelle fÃ¼r 5"
                        }
                ]
        },
        {
                "id": 6,
                "weekId": 1,
                "title": "Zahlenratespiel",
                "duration": "45-60 min",
                "task": {
                        "title": "Zahlenratespiel",
                        "description": "Baue ein Spiel, bei dem der Computer eine Zufallszahl wÃ¤hlt und der Spieler sie erraten muss - mit While-Schleife!",
                        "goals": [
                                "While-Schleifen: Code wiederholen SOLANGE Bedingung wahr",
                                "Break: Schleife vorzeitig beenden",
                                "Continue: Zum nÃ¤chsten Durchlauf springen",
                                "Random-Modul: `import random`, `random.randint()`",
                                "Boolean-Variablen: True/False fÃ¼r Zustandsverfolgung",
                                "ZÃ¤hler: Versuche/Runden mitzÃ¤hlen",
                                "Verschachtelte While: Schleife in Schleife",
                                "+=, -=: Kurzformen fÃ¼r ErhÃ¶hen/Verringern"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "While-Schleife verstehen",
                                "goal": "Verstehen, wie while-Schleifen funktionieren (anders als for!)",
                                "why": "For-Schleifen laufen eine FESTE Anzahl durch. While-Schleifen laufen, SOLANGE eine Bedingung wahr ist. Perfekt fÃ¼r \"bis der Benutzer richtig rÃ¤t\"!",
                                "instruction": "",
                                "code": "# WHILE = SOLANGE (eine Bedingung wahr ist)\n\n# Beispiel 1: Von 1 bis 5 zÃ¤hlen\nzahl = 1  # Startwert\n\nwhile zahl <= 5:  # Solange zahl kleiner-gleich 5 ist\n    print(zahl)\n    zahl = zahl + 1  # WICHTIG: Wert erhÃ¶hen, sonst endlos!\n\n# Was passiert:\n# zahl=1: 1<=5? JA â†’ print(1), zahl wird 2\n# zahl=2: 2<=5? JA â†’ print(2), zahl wird 3\n# ...\n# zahl=6: 6<=5? NEIN â†’ Schleife stoppt\n\nprint(\"Schleife beendet!\")\n\n# Beispiel 2: Benutzer-Input in Schleife\nprint(\"\\n--- Passwort-Check ---\")\npasswort = \"\"  # Leerer String\n\nwhile passwort != \"geheim\":  # Solange Passwort NICHT \"geheim\" ist\n    passwort = input(\"Passwort eingeben: \")\n    \n    if passwort != \"geheim\":\n        print(\"âŒ Falsch! Versuch's nochmal.\")\n\nprint(\"âœ… Richtig! Zugang gewÃ¤hrt!\")",
                                "checkpoint": " - Erste Schleife: Zahlen 1 bis 5 - Zweite Schleife: LÃ¤uft bis \"geheim\" eingegeben wird"
                        },
                        {
                                "number": 2,
                                "title": "While mit ZÃ¤hler",
                                "goal": "Anzahl der Versuche mitzÃ¤hlen",
                                "why": "In Spielen wollen wir oft wissen \"Wie viele Versuche hat der Spieler gebraucht?\"",
                                "instruction": "",
                                "code": "import random  # Modul fÃ¼r Zufallszahlen - kommt mit Python mit!\n\nprint(\"ğŸ² ZUFALLSZAHL-DEMO\")\n\n# random.randint(a, b) gibt eine zufÃ¤llige Ganzzahl zwischen a und b zurÃ¼ck\nzufallszahl = random.randint(1, 10)  # Zahl zwischen 1 und 10\n\nprint(f\"Ich habe eine Zahl zwischen 1 und 10 gewÃ¤hlt.\")\nprint(\"Versuche sie zu erraten!\")\n\nversuch_nummer = 0  # ZÃ¤hler starten bei 0\ngeraten = False  # Boolean (Wahrheitswert): False oder True\n\nwhile not geraten:  # Solange NICHT geraten (= False)\n    versuch_nummer = versuch_nummer + 1  # ZÃ¤hler erhÃ¶hen (auch: versuch_nummer += 1)\n    \n    print(f\"\\nVersuch #{versuch_nummer}:\")\n    tipp = int(input(\"Deine Zahl: \"))\n    \n    if tipp == zufallszahl:\n        print(f\"ğŸ‰ RICHTIG! Die Zahl war {zufallszahl}!\")\n        print(f\"Du hast {versuch_nummer} Versuche gebraucht.\")\n        geraten = True  # Bedingung wird False â†’ Schleife stoppt\n    else:\n        print(\"âŒ Falsch!\")\n\n# Alternative Schreibweise: while True mit break\n# while True:  # Endlos-Schleife\n#     ...\n#     if bedingung:\n#         break  # Bricht die Schleife ab",
                                "checkpoint": " - Jeder Versuch wird nummeriert - Nach richtigem Tipp wird die Anzahl Versuche angezeigt - Schleife stoppt automatisch"
                        },
                        {
                                "number": 3,
                                "title": "Hinweise einbauen (heiÃŸ/kalt)",
                                "goal": "Dem Spieler helfen durch \"zu hoch\" / \"zu niedrig\"",
                                "why": "Das macht das Spiel interessanter und nutzt if-Bedingungen INNERHALB der Schleife!",
                                "instruction": "",
                                "code": "import random\n\nprint(\"ğŸ® ZAHLENRATESPIEL v2.0\")\nprint(\"=\" * 40)\n\n# Zufallszahl zwischen 1 und 100\ngeheimzahl = random.randint(1, 100)\n\nprint(\"Ich habe mir eine Zahl zwischen 1 und 100 ausgedacht.\")\nprint(\"Kannst du sie erraten?\\n\")\n\nversuche = 0\nmax_versuche = 7  # Limit fÃ¼r Spannung\n\nwhile versuche < max_versuche:\n    versuche += 1  # Kurzform fÃ¼r: versuche = versuche + 1\n    \n    verbleibend = max_versuche - versuche + 1\n    print(f\"--- Versuch {versuche}/{max_versuche} ---\")\n    \n    # Input mit Fehlerbehandlung (einfach)\n    eingabe = input(\"Dein Tipp: \")\n    \n    if not eingabe.isdigit():  # PrÃ¼fe ob es eine Zahl ist\n        print(\"âŒ Bitte eine Zahl eingeben!\")\n        versuche -= 1  # Dieser Versuch zÃ¤hlt nicht\n        continue  # Springe zum nÃ¤chsten Schleifendurchlauf\n    \n    tipp = int(eingabe)\n    \n    # PrÃ¼fung\n    if tipp < 1 or tipp > 100:\n        print(\"âŒ Zahl muss zwischen 1 und 100 sein!\")\n        versuche -= 1\n        \n    elif tipp == geheimzahl:\n        print(f\"\\nğŸ‰ğŸ‰ğŸ‰ GEWONNEN! ğŸ‰ğŸ‰ğŸ‰\")\n        print(f\"Die Zahl war {geheimzahl}!\")\n        print(f\"Du hast {versuche} Versuche gebraucht.\")\n        break  # Schleife sofort beenden\n        \n    elif tipp < geheimzahl:\n        unterschied = geheimzahl - tipp\n        \n        if unterschied > 20:\n            print(\"â„ï¸ EISKALT! Viel zu niedrig!\")\n        elif unterschied > 10:\n            print(\"ğŸ§Š Kalt! Zu niedrig.\")\n        else:\n            print(\"ğŸ”¥ Warm! Noch etwas hÃ¶her!\")\n            \n    else:  # tipp > geheimzahl\n        unterschied = tipp - geheimzahl\n        \n        if unterschied > 20:\n            print(\"ğŸ”¥ BRÃœTEND HEIáº! Viel zu hoch!\")\n        elif unterschied > 10:\n            print(\"â™¨ï¸ HeiÃŸ! Zu hoch.\")\n        else:\n            print(\"â„ï¸ KÃ¼hl! Etwas niedriger!\")\n    \n    # Wenn es der letzte Versuch war\n    if versuche == max_versuche and tipp != geheimzahl:\n        print(f\"\\nğŸ˜ VERLOREN! Die Zahl war {geheimzahl}.\")\n\nprint(\"\\n--- Spiel beendet ---\")",
                                "checkpoint": " - Teste mit absichtlich falschen Eingaben (Buchstaben, Zahlen Ã¼ber 100) - Die Hinweise sollten helfen, schneller zu raten - Nach 7 Versuchen oder richtigem Tipp stoppt das Spiel"
                        },
                        {
                                "number": 4,
                                "title": "Nochmal spielen?",
                                "goal": "Ã„uÃŸere Schleife fÃ¼r mehrere Runden",
                                "why": "While-Schleifen INNERHALB von While-Schleifen - fÃ¼r wiederholte Spiele!",
                                "instruction": "",
                                "code": "import random\n\ndef spiele_runde():\n    \"\"\"Eine Spielrunde - als Funktion fÃ¼r bessere Struktur\"\"\"\n    geheimzahl = random.randint(1, 100)\n    versuche = 0\n    max_versuche = 7\n    \n    while versuche < max_versuche:\n        versuche += 1\n        \n        print(f\"\\n--- Versuch {versuche}/{max_versuche} ---\")\n        eingabe = input(\"Dein Tipp (1-100): \")\n        \n        if not eingabe.isdigit():\n            print(\"âŒ Nur Zahlen!\")\n            versuche -= 1\n            continue\n        \n        tipp = int(eingabe)\n        \n        if tipp == geheimzahl:\n            print(f\"\\nğŸ‰ RICHTIG! Zahl war {geheimzahl}! ({versuche} Versuche)\")\n            return True  # Gewonnen\n        elif tipp < geheimzahl:\n            print(\"â¬†ï¸ Zu niedrig!\")\n        else:\n            print(\"â¬‡ï¸ Zu hoch!\")\n    \n    print(f\"\\nğŸ˜ Verloren! Zahl war {geheimzahl}.\")\n    return False  # Verloren\n\n# HAUPTPROGRAMM mit Ã¤uÃŸerer Schleife\nprint(\"ğŸ® ZAHLENRATESPIEL v3.0\")\nprint(\"=\" * 40)\n\nweiter_spielen = True\nrunden = 0\ngewonnen_gesamt = 0\n\nwhile weiter_spielen:\n    runden += 1\n    print(f\"\\n{'='*40}\")\n    print(f\"RUNDE {runden}\")\n    print(f\"{'='*40}\")\n    \n    # Spiele eine Runde\n    gewonnen = spiele_runde()\n    \n    if gewonnen:\n        gewonnen_gesamt += 1\n    \n    # Statistik\n    print(f\"\\nDeine Statistik: {gewonnen_gesamt}/{runden} gewonnen\")\n    \n    # Nochmal?\n    antwort = input(\"\\nNochmal spielen? (j/n): \").lower()\n    \n    if antwort != \"j\" and antwort != \"ja\":\n        weiter_spielen = False  # Ã„uÃŸere Schleife beenden\n\nprint(\"\\nğŸ‘‹ Danke fÃ¼rs Spielen!\")\nprint(f\"Endergebnis: {gewonnen_gesamt}/{runden} Runden gewonnen!\")",
                                "checkpoint": " - Mehrere Runden sollten spielbar sein - Statistik wird korrekt gefÃ¼hrt - Spiel endet bei Eingabe von \"n\""
                        }
                ]
        },
        {
                "id": 7,
                "weekId": 1,
                "title": "BMI-Rechner mit Funktionen",
                "duration": "45-60 min",
                "task": {
                        "title": "BMI-Rechner mit Funktionen",
                        "description": "Erstelle einen BMI-Rechner (Body Mass Index) mit wiederverwendbaren Funktionen.",
                        "goals": [
                                "Funktionen definieren: `def funktionsname():`",
                                "Parameter: Eingabe-Werte an Funktionen Ã¼bergeben",
                                "Return: Werte aus Funktionen zurÃ¼ckgeben",
                                "Docstrings: Funktionen dokumentieren mit `\"\"\"`",
                                "Mehrere RÃ¼ckgabewerte: Mit Tupel `return a, b`",
                                "Try-Except: Fehlerbehandlung (Basis)",
                                "Single Responsibility: Eine Funktion = eine Aufgabe",
                                "main(): Hauptfunktion als Einstiegspunkt"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Funktionen definieren",
                                "goal": "Verstehen, was Funktionen sind und warum wir sie brauchen",
                                "why": "Stell dir vor, du musst die gleiche Berechnung 10Ã— machen. WÃ¼rdest du den Code 10Ã— kopieren? NEIN! Funktionen sind wie Rezepte - einmal schreiben, beliebig oft verwenden!",
                                "instruction": "",
                                "code": "# Funktion DEFINIEREN mit 'def' (define = definieren)\n# Eine Funktion ist ein wiederverwendbarer Code-Block\n\ndef begruessung():  # Funktionsname mit ()\n    \"\"\"Das ist ein Docstring - erklÃ¤rt was die Funktion macht\"\"\"\n    print(\"Hallo!\")\n    print(\"Willkommen zum BMI-Rechner!\")\n\n# Funktion AUFRUFEN (sonst passiert nichts!)\nbegruessung()  # FÃ¼hrt den Code in der Funktion aus\n\nprint(\"\\n--- Nochmal ---\\n\")\n\nbegruessung()  # Kann beliebig oft aufgerufen werden!\n\n# Funktion mit PARAMETER (Eingabe-Werte)\ndef begruessung_mit_name(name):  # 'name' ist ein Parameter\n    \"\"\"BegrÃ¼ÃŸt eine Person mit ihrem Namen\"\"\"\n    print(f\"Hallo {name}!\")\n    print(\"Willkommen zum BMI-Rechner!\")\n\n# Beim Aufrufen mÃ¼ssen wir den Parameter Ã¼bergeben\nbegruessung_mit_name(\"Anna\")  # name = \"Anna\"\nbegruessung_mit_name(\"Max\")   # name = \"Max\"",
                                "checkpoint": " - \"Hallo!\" sollte mehrmals erscheinen - Personalisierte BegrÃ¼ÃŸungen fÃ¼r Anna und Max"
                        },
                        {
                                "number": 2,
                                "title": "Funktionen mit Return",
                                "goal": "Werte aus Funktionen zurÃ¼ckgeben",
                                "why": "Manchmal wollen wir nicht nur etwas AUSGEBEN (print), sondern ein ERGEBNIS zurÃ¼ckbekommen, um damit weiterzuarbeiten!",
                                "instruction": "",
                                "code": "# Funktion die etwas BERECHNET und zurÃ¼ckgibt\n\ndef addiere(a, b):  # Zwei Parameter\n    \"\"\"Addiert zwei Zahlen und gibt das Ergebnis zurÃ¼ck\"\"\"\n    summe = a + b\n    return summe  # RETURN schickt den Wert zurÃ¼ck an den Aufrufer\n    # Code nach 'return' wird NICHT mehr ausgefÃ¼hrt!\n\n# Das Ergebnis kÃ¶nnen wir speichern\nergebnis = addiere(5, 3)\nprint(f\"5 + 3 = {ergebnis}\")\n\n# Oder direkt verwenden\nprint(f\"10 + 20 = {addiere(10, 20)}\")\n\n# BMI-Berechnung als Funktion\ndef berechne_bmi(gewicht_kg, groesse_m):\n    \"\"\"\n    Berechnet den BMI (Body Mass Index)\n    \n    Formel: BMI = Gewicht / (GrÃ¶ÃŸeÂ²)\n    \n    Parameter:\n        gewicht_kg: Gewicht in Kilogramm\n        groesse_m: GrÃ¶ÃŸe in Metern\n    \n    RÃ¼ckgabe:\n        BMI als Float (Kommazahl)\n    \"\"\"\n    bmi = gewicht_kg / (groesse_m ** 2)  # ** 2 bedeutet \"hoch 2\" (Quadrat)\n    return bmi\n\n# Testen\nmein_bmi = berechne_bmi(70, 1.75)\nprint(f\"\\nBMI bei 70kg und 1.75m: {mein_bmi:.2f}\")\n\n# Mehrere Werte auf einmal zurÃ¼ckgeben (als Tupel)\ndef berechne_statistiken(gewicht, groesse):\n    \"\"\"Berechnet BMI und kategorisiert\"\"\"\n    bmi = gewicht / (groesse ** 2)\n    \n    if bmi < 18.5:\n        kategorie = \"Untergewicht\"\n    elif bmi < 25:\n        kategorie = \"Normalgewicht\"\n    elif bmi < 30:\n        kategorie = \"Ãœbergewicht\"\n    else:\n        kategorie = \"Adipositas\"\n    \n    return bmi, kategorie  # Gibt ZWEI Werte zurÃ¼ck!\n\n# Empfangen von mehreren Werten\nbmi_wert, kate = berechne_statistiken(70, 1.75)\nprint(f\"BMI: {bmi_wert:.2f}, Kategorie: {kate}\")",
                                "checkpoint": " - Additionen funktionieren - BMI wird korrekt berechnet (70kg, 1.75m â‰ˆ 22.86) - Kategorie sollte \"Normalgewicht\" sein"
                        },
                        {
                                "number": 3,
                                "title": "VollstÃ¤ndiger BMI-Rechner",
                                "goal": "Mehrere Funktionen zu einem Programm kombinieren",
                                "why": "Echte Programme bestehen aus VIELEN kleinen Funktionen, die zusammenarbeiten. Jede Funktion hat EINE klare Aufgabe.",
                                "instruction": "",
                                "code": "def hole_positive_zahl(prompt):\n    \"\"\"\n    Fragt nach einer positiven Zahl und validiert die Eingabe\n    \n    Parameter:\n        prompt: Der Text, der dem Benutzer angezeigt wird\n        \n    RÃ¼ckgabe:\n        Eine positive Zahl (float)\n    \"\"\"\n    while True:  # Endlosschleife bis gÃ¼ltige Eingabe\n        eingabe = input(prompt)\n        \n        # PrÃ¼fe ob es eine Zahl ist\n        try:  # Versuche\n            zahl = float(eingabe)\n            \n            if zahl <= 0:\n                print(\"âŒ Bitte eine positive Zahl eingeben!\")\n            else:\n                return zahl  # GÃ¼ltige Zahl â†’ zurÃ¼ckgeben und Funktion beenden\n                \n        except ValueError:  # Wenn float() fehlschlÃ¤gt\n            print(\"âŒ Bitte eine gÃ¼ltige Zahl eingeben!\")\n\ndef berechne_bmi(gewicht, groesse):\n    \"\"\"Berechnet BMI\"\"\"\n    return gewicht / (groesse ** 2)\n\ndef bestimme_kategorie(bmi):\n    \"\"\"Bestimmt die BMI-Kategorie nach WHO-Standard\"\"\"\n    if bmi < 16:\n        return \"Starkes Untergewicht\", \"ğŸš¨\"\n    elif bmi < 18.5:\n        return \"Untergewicht\", \"âš ï¸\"\n    elif bmi < 25:\n        return \"Normalgewicht\", \"âœ…\"\n    elif bmi < 30:\n        return \"Ãœbergewicht\", \"âš ï¸\"\n    elif bmi < 35:\n        return \"Adipositas Grad I\", \"ğŸš¨\"\n    elif bmi < 40:\n        return \"Adipositas Grad II\", \"ğŸš¨\"\n    else:\n        return \"Adipositas Grad III\", \"ğŸš¨\"\n\ndef zeige_bmi_tabelle():\n    \"\"\"Zeigt eine Ãœbersicht der BMI-Kategorien\"\"\"\n    print(\"\\nğŸ“Š BMI-Kategorien (WHO):\")\n    print(\"-\" * 40)\n    print(\"< 16.0    Starkes Untergewicht\")\n    print(\"16.0-18.4 Untergewicht\")\n    print(\"18.5-24.9 Normalgewicht âœ…\")\n    print(\"25.0-29.9 Ãœbergewicht\")\n    print(\"30.0-34.9 Adipositas Grad I\")\n    print(\"35.0-39.9 Adipositas Grad II\")\n    print(\"â‰¥ 40.0    Adipositas Grad III\")\n    print(\"-\" * 40)\n\n# HAUPTPROGRAMM\ndef main():\n    \"\"\"Hauptfunktion - startet das Programm\"\"\"\n    print(\"=\" * 50)\n    print(\"ğŸ’ª BMI-RECHNER (Body Mass Index)\")\n    print(\"=\" * 50)\n    \n    # Tabelle zeigen\n    zeige_bmi_tabelle()\n    \n    # Daten abfragen\n    print(\"\\nğŸ“ Bitte gib deine Daten ein:\")\n    gewicht = hole_positive_zahl(\"Gewicht in kg: \")\n    groesse = hole_positive_zahl(\"GrÃ¶ÃŸe in Metern (z.B. 1.75): \")\n    \n    # Berechnung\n    bmi = berechne_bmi(gewicht, groesse)\n    kategorie, emoji = bestimme_kategorie(bmi)\n    \n    # Ausgabe\n    print(\"\\n\" + \"=\" * 50)\n    print(\"ğŸ“Š DEIN ERGEBNIS\")\n    print(\"=\" * 50)\n    print(f\"Gewicht: {gewicht} kg\")\n    print(f\"GrÃ¶ÃŸe: {groesse} m\")\n    print(f\"\\nBMI: {bmi:.2f}\")\n    print(f\"Kategorie: {kategorie} {emoji}\")\n    print(\"=\" * 50)\n    \n    # Tipps\n    if bmi < 18.5:\n        print(\"\\nğŸ’¡ Tipp: Achte auf ausreichende Kalorienzufuhr!\")\n    elif bmi >= 25:\n        print(\"\\nğŸ’¡ Tipp: Mehr Bewegung und gesunde ErnÃ¤hrung helfen!\")\n    else:\n        print(\"\\nğŸ’¡ Weiter so! Dein BMI ist im gesunden Bereich.\")\n\n# Programm starten\nif __name__ == \"__main__\":  # Dieser Check ist Python-Konvention\n    main()  # Rufe die Hauptfunktion auf",
                                "checkpoint": " - UngÃ¼ltige Eingaben (Buchstaben, negative Zahlen) werden abgefangen - BMI wird korrekt berechnet - Kategorie wird richtig zugeordnet - Tipps erscheinen je nach Kategorie"
                        }
                ]
        },
      ]
    },
    {
      id: 2,
      title: "Woche 2: Datenstrukturen",
      subtitle: "Listen, Dictionaries & Dateien",
      description: "Fortgeschrittene Datenstrukturen und wie man mit Dateien arbeitet.",
      color: "purple",
      days: [
        {
                "id": 1,
                "weekId": 2,
                "title": "Kontaktverwaltung mit Dictionaries",
                "duration": "45-60 min",
                "task": {
                        "title": "Kontaktverwaltung mit Dictionaries",
                        "description": "Erstelle ein Programm zur Verwaltung von Kontakten mit Namen, Telefonnummern und E-Mails - mit Dictionaries!",
                        "goals": [
                                "Dictionaries: Key-Value Paare `{key: value}`",
                                "Dict-Methoden: `.get()`, `.pop()`, `.update()`, `.setdefault()`",
                                "Dict-Eigenschaften: `.keys()`, `.values()`, `.items()`",
                                "Listen von Dicts: Komplexe Datenstrukturen",
                                "Suchen & Filtern: Durch Dictionaries iterieren",
                                "Menu-System: BenutzergefÃ¼hrte Programme"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Dictionary-Grundlagen",
                                "goal": "Verstehen, was Dictionaries sind und wie sie sich von Listen unterscheiden",
                                "why": "Listen speichern Werte mit Zahlen (Index 0, 1, 2...). Dictionaries speichern Werte mit NAMEN (Keys). Perfekt fÃ¼r strukturierte Daten wie Kontakte!",
                                "instruction": "",
                                "code": "# LISTE: Zugriff Ã¼ber Index (Zahl)\nfarben = [\"rot\", \"grÃ¼n\", \"blau\"]\nprint(farben[0])  # \"rot\"\n\n# DICTIONARY: Zugriff Ã¼ber Key (Name)\n# Syntax: {key: value, key: value, ...}\nperson = {\n    \"name\": \"Anna Schmidt\",\n    \"alter\": 28,\n    \"stadt\": \"Berlin\",\n    \"beruf\": \"Entwicklerin\"\n}\n\n# Zugriff Ã¼ber Key\nprint(person[\"name\"])  # \"Anna Schmidt\"\nprint(person[\"alter\"])  # 28\n\n# Keys mÃ¼ssen eindeutig sein, Values kÃ¶nnen doppelt vorkommen\n# Keys sind meist Strings, kÃ¶nnen aber auch Zahlen oder Tupel sein\n\n# Neuen Key hinzufÃ¼gen\nperson[\"email\"] = \"anna@example.com\"\nprint(person)\n\n# Wert Ã¤ndern\nperson[\"alter\"] = 29\nprint(f\"Anna ist jetzt {person['alter']}\")\n\n# PrÃ¼fen ob Key existiert\nif \"telefon\" in person:\n    print(person[\"telefon\"])\nelse:\n    print(\"Telefonnummer nicht vorhanden\")\n\n# Alle Keys, Values, oder beides anzeigen\nprint(\"\\nAlle Keys:\", person.keys())\nprint(\"Alle Values:\", person.values())\nprint(\"Alle Paare:\", person.items())",
                                "checkpoint": " - Dictionary hat mehrere Eigenschaften zu einer Person - Neuer Key \"email\" wurde hinzugefÃ¼gt - \"telefon\" existiert nicht â†’ else-Block wird ausgefÃ¼hrt"
                        },
                        {
                                "number": 2,
                                "title": "Dictionary-Methoden",
                                "goal": "Mit Dictionary-Methoden arbeiten (get, pop, update...)",
                                "why": "Dictionaries haben eingebaute Funktionen, die das Arbeiten einfacher und sicherer machen!",
                                "instruction": "",
                                "code": "kontakt = {\n    \"name\": \"Max MÃ¼ller\",\n    \"tel\": \"0123-456789\",\n    \"email\": \"max@example.com\"\n}\n\n# .get(key, default) - Sicherer Zugriff (kein Fehler wenn Key fehlt)\n# Statt: kontakt[\"adresse\"] â†’ Fehler!\n# Besser:\nadresse = kontakt.get(\"adresse\", \"Nicht angegeben\")\nprint(f\"Adresse: {adresse}\")  # \"Nicht angegeben\"\n\n# .pop(key) - Entfernt einen Key und gibt den Wert zurÃ¼ck\nemail = kontakt.pop(\"email\")\nprint(f\"Entfernte Email: {email}\")\nprint(f\"Kontakt jetzt: {kontakt}\")  # email ist weg\n\n# .update() - Mehrere Keys auf einmal hinzufÃ¼gen/Ã¤ndern\nkontakt.update({\n    \"email\": \"max.mueller@example.com\",  # Wieder hinzufÃ¼gen (besser)\n    \"firma\": \"TechCorp\",\n    \"position\": \"Manager\"\n})\nprint(f\"\\nAktualisiert: {kontakt}\")\n\n# .setdefault(key, default) - FÃ¼gt Key nur hinzu wenn nicht vorhanden\nkontakt.setdefault(\"stadt\", \"MÃ¼nchen\")  # Wird hinzugefÃ¼gt\nkontakt.setdefault(\"name\", \"Anderer Name\")  # Wird NICHT Ã¼berschrieben!\nprint(f\"\\nMit setdefault: {kontakt}\")\n\n# .clear() - Alle EintrÃ¤ge lÃ¶schen\n# kontakt.clear()  # Macht Dictionary leer!\n\n# .copy() - Kopie erstellen\nbackup = kontakt.copy()\nbackup[\"name\"] = \"BACKUP\"\nprint(f\"\\nOriginal: {kontakt['name']}\")  # \"Max MÃ¼ller\" - unverÃ¤ndert!\nprint(f\"Kopie: {backup['name']}\")  # \"BACKUP\"",
                                "checkpoint": " - `.get()` verhindert Fehler bei fehlendem Key - `.pop()` entfernt und gibt gleichzeitig zurÃ¼ck - `.update()` Ã¤ndert mehrere Werte auf einmal - `.copy()` erstellt unabhÃ¤ngige Kopie"
                        },
                        {
                                "number": 3,
                                "title": "Liste von Dictionaries (Kontaktliste)",
                                "goal": "Mehrere Kontakte in einer Liste speichern",
                                "why": "Real-World-Anwendung! Eine Liste von Dictionaries ist wie eine einfache Datenbank.",
                                "instruction": "",
                                "code": "# Liste von Dictionaries - jedes Dict ist ein Kontakt\nkontakte = [\n    {\n        \"name\": \"Anna Schmidt\",\n        \"tel\": \"0123-111111\",\n        \"email\": \"anna@test.de\",\n        \"kategorie\": \"Freunde\"\n    },\n    {\n        \"name\": \"Ben MÃ¼ller\",\n        \"tel\": \"0123-222222\",\n        \"email\": \"ben@test.de\",\n        \"kategorie\": \"Familie\"\n    },\n    {\n        \"name\": \"Clara Neubert\",\n        \"tel\": \"0123-333333\",\n        \"email\": \"clara@test.de\",\n        \"kategorie\": \"Arbeit\"\n    }\n]\n\n# Alle Kontakte durchgehen\nprint(\"ğŸ“‡ ALLE KONTAKTE:\")\nprint(\"=\" * 50)\n\nfor kontakt in kontakte:  # Jedes Element ist ein Dictionary\n    print(f\"\\nğŸ‘¤ {kontakt['name']}\")\n    print(f\"   ğŸ“ {kontakt['tel']}\")\n    print(f\"   ğŸ“§ {kontakt['email']}\")\n    print(f\"   ğŸ·ï¸  {kontakt['kategorie']}\")\n\n# Spezifischen Kontakt suchen\nsuchname = \"Ben MÃ¼ller\"\ngefunden = False\n\nfor kontakt in kontakte:\n    if kontakt[\"name\"] == suchname:\n        print(f\"\\nâœ… Kontakt gefunden:\")\n        print(f\"   Telefon: {kontakt['tel']}\")\n        gefunden = True\n        break  # Stoppt die Schleife, wenn gefunden\n\nif not gefunden:\n    print(f\"âŒ {suchname} nicht gefunden\")\n\n# Filtern nach Kategorie\nprint(\"\\n\\nğŸ·ï¸  ARBEITSKONTAKTE:\")\nfor kontakt in kontakte:\n    if kontakt[\"kategorie\"] == \"Arbeit\":\n        print(f\"- {kontakt['name']}\")\n\n# Statistiken\nanzahl_gesamt = len(kontakte)\nkategorien = {}  # Dict fÃ¼r ZÃ¤hlung\n\nfor kontakt in kontakte:\n    kat = kontakt[\"kategorie\"]\n    if kat in kategorien:\n        kategorien[kat] += 1\n    else:\n        kategorien[kat] = 1\n\nprint(f\"\\nğŸ“Š Statistik: {anzahl_gesamt} Kontakte gesamt\")\nfor kat, anzahl in kategorien.items():\n    print(f\"   {kat}: {anzahl}\")",
                                "checkpoint": " - Alle 3 Kontakte werden schÃ¶n formatiert angezeigt - Suche nach \"Ben MÃ¼ller\" findet den Kontakt - Nur \"Clara Neubert\" wird bei Arbeitskontakten gezeigt - Statistik zÃ¤hlt Kontakte pro Kategorie"
                        },
                        {
                                "number": 4,
                                "title": "Interaktive Kontaktverwaltung",
                                "goal": "VollstÃ¤ndige App zum HinzufÃ¼gen, Anzeigen, Suchen und LÃ¶schen von Kontakten",
                                "why": "Hier kombinieren wir ALLES bisher Gelernte!",
                                "instruction": "",
                                "code": "def zeige_kontakte(kontakte):\n    \"\"\"Zeigt alle Kontakte Ã¼bersichtlich an\"\"\"\n    if len(kontakte) == 0:\n        print(\"\\nğŸ“­ Keine Kontakte vorhanden\")\n        return\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"ğŸ“‡ ALLE KONTAKTE\")\n    print(\"=\" * 60)\n    \n    for i, kontakt in enumerate(kontakte, start=1):\n        print(f\"\\n{i}. {kontakt['name']}\")\n        print(f\"   ğŸ“ {kontakt.get('tel', 'Keine Nummer')}\")\n        print(f\"   ğŸ“§ {kontakt.get('email', 'Keine Email')}\")\n        print(f\"   ğŸ·ï¸  {kontakt.get('kategorie', 'Keine Kategorie')}\")\n\ndef neuer_kontakt():\n    \"\"\"Erstellt einen neuen Kontakt durch Benutzereingabe\"\"\"\n    print(\"\\nâ• NEUER KONTAKT\")\n    print(\"-\" * 30)\n    \n    name = input(\"Name: \").strip()\n    if not name:\n        print(\"âŒ Name darf nicht leer sein!\")\n        return None\n    \n    tel = input(\"Telefon: \").strip()\n    email = input(\"Email: \").strip()\n    kategorie = input(\"Kategorie (Freunde/Familie/Arbeit): \").strip()\n    \n    # Dictionary erstellen und zurÃ¼ckgeben\n    return {\n        \"name\": name,\n        \"tel\": tel,\n        \"email\": email,\n        \"kategorie\": kategorie or \"Sonstige\"\n    }\n\ndef suche_kontakt(kontakte, suchbegriff):\n    \"\"\"Sucht nach Name oder Telefonnummer\"\"\"\n    gefundene = []\n    suchbegriff = suchbegriff.lower()\n    \n    for kontakt in kontakte:\n        # Suche in Name oder Telefon (case-insensitive)\n        if (suchbegriff in kontakt[\"name\"].lower() or\n            suchbegriff in kontakt.get(\"tel\", \"\")):\n            gefundene.append(kontakt)\n    \n    return gefundene\n\ndef loesche_kontakt(kontakte, index):\n    \"\"\"LÃ¶scht einen Kontakt an Position index\"\"\"\n    if 0 <= index < len(kontakte):\n        geloeschter = kontakte.pop(index)\n        print(f\"\\nâœ… '{geloeschter['name']}' wurde gelÃ¶scht\")\n        return True\n    else:\n        print(\"\\nâŒ UngÃ¼ltige Nummer!\")\n        return False\n\n# HAUPTPROGRAMM\ndef main():\n    # Startwerte\n    kontakte = [\n        {\"name\": \"Demo User\", \"tel\": \"0000-000000\", \"email\": \"demo@test.de\", \"kategorie\": \"Test\"}\n    ]\n    \n    while True:\n        print(\"\\n\" + \"=\" * 60)\n        print(\"ğŸ“± KONTAKTVERWALTUNG\")\n        print(\"=\" * 60)\n        print(\"1. Alle Kontakte anzeigen\")\n        print(\"2. Neuen Kontakt hinzufÃ¼gen\")\n        print(\"3. Kontakt suchen\")\n        print(\"4. Kontakt lÃ¶schen\")\n        print(\"5. Beenden\")\n        \n        wahl = input(\"\\nWÃ¤hle eine Option (1-5): \").strip()\n        \n        if wahl == \"1\":\n            zeige_kontakte(kontakte)\n            \n        elif wahl == \"2\":\n            neuer = neuer_kontakt()\n            if neuer:\n                kontakte.append(neuer)\n                print(f\"âœ… '{neuer['name']}' wurde hinzugefÃ¼gt!\")\n                \n        elif wahl == \"3\":\n            begriff = input(\"\\nSuchbegriff (Name oder Telefon): \").strip()\n            if begriff:\n                ergebnisse = suche_kontakt(kontakte, begriff)\n                if ergebnisse:\n                    print(f\"\\nğŸ” {len(ergebnisse)} Ergebnis(se) gefunden:\")\n                    for k in ergebnisse:\n                        print(f\"\\nğŸ‘¤ {k['name']}\")\n                        print(f\"   ğŸ“ {k.get('tel', 'N/A')}\")\n                        print(f\"   ğŸ“§ {k.get('email', 'N/A')}\")\n                else:\n                    print(\"\\nâŒ Keine Kontakte gefunden\")\n                    \n        elif wahl == \"4\":\n            zeige_kontakte(kontakte)\n            if len(kontakte) > 0:\n                try:\n                    nummer = int(input(\"\\nKontakt-Nummer zum LÃ¶schen: \"))\n                    loesche_kontakt(kontakte, nummer - 1)\n                except ValueError:\n                    print(\"âŒ Bitte eine gÃ¼ltige Nummer eingeben!\")\n                    \n        elif wahl == \"5\":\n            print(\"\\nğŸ‘‹ Auf Wiedersehen!\")\n            break\n            \n        else:\n            print(\"\\nâŒ UngÃ¼ltige Wahl! Bitte 1-5 wÃ¤hlen.\")\n\nif __name__ == \"__main__\":\n    main()",
                                "checkpoint": " - MenÃ¼ wird angezeigt mit 5 Optionen - Kontakte kÃ¶nnen hinzugefÃ¼gt, gesucht, angezeigt und gelÃ¶scht werden - Fehlerbehandlung fÃ¼r ungÃ¼ltige Eingaben - Programm lÃ¤uft bis der Benutzer \"5\" wÃ¤hlt"
                        }
                ]
        },
        {
                "id": 2,
                "weekId": 2,
                "title": "Lotto-Zahlen Generator (Tupel & Sets)",
                "duration": "45-60 min",
                "task": {
                        "title": "Lotto-Zahlen Generator (Tupel & Sets)",
                        "description": "Erstelle einen Lotto-Zahlen Generator und lerne dabei Tupel und Sets kennen!",
                        "goals": [
                                "Tupel: UnverÃ¤nderliche Listen `(1, 2, 3)`",
                                "Tupel Unpacking: `a, b = (1, 2)`",
                                "Sets: Eindeutige Werte `{1, 2, 3}`",
                                "Set-Operationen: Union `|`, Intersection `&`, Difference `-`",
                                "Duplikate entfernen: `set(liste)`",
                                "Wann was: Liste (geordnet, verÃ¤nderlich), Tupel (geordnet, unverÃ¤nderlich), Set (ungeordnet, eindeutig)"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Tupel verstehen",
                                "goal": "Verstehen was Tupel sind und wann man sie nutzt",
                                "why": "Tupel sind wie Listen, aber UNVERÃ„NDERLICH. Perfekt fÃ¼r Daten, die nicht geÃ¤ndert werden sollen (z.B. Koordinaten, Datum, Farben).",
                                "instruction": "",
                                "code": "# LISTE: VerÃ¤nderbar (mutable)\nliste = [1, 2, 3]\nliste[0] = 99  # Funktioniert\nprint(liste)  # [99, 2, 3]\n\n# TUPEL: UnverÃ¤nderlich (immutable)\n# Erstellt mit runden Klammern ()\ntupel = (1, 2, 3)\n# tupel[0] = 99  # FEHLER! Tupel kann nicht geÃ¤ndert werden\n\nprint(tupel)  # (1, 2, 3)\n\n# Warum Tupel?\n# 1. Sicherheit: Daten kÃ¶nnen nicht versehentlich geÃ¤ndert werden\n# 2. Performance: Tupel sind schneller als Listen\n# 3. Als Dict-Keys: Tupel kÃ¶nnen Keys sein, Listen nicht\n\n# Tupel erstellen\nkoordinaten = (52.52, 13.40)  # Latitude, Longitude\nrgb_farbe = (255, 128, 0)     # Rot, GrÃ¼n, Blau\ndatum = (2024, 2, 12)         # Jahr, Monat, Tag\n\n# Tupel unpacking - super praktisch!\nlat, lon = koordinaten\nprint(f\"Breitengrad: {lat}, LÃ¤ngengrad: {lon}\")\n\njahr, monat, tag = datum\nprint(f\"Datum: {tag}.{monat}.{jahr}\")\n\n# Tupel mit einem Element (braucht Komma!)\neinzeln = (42,)  # Mit Komma = Tupel\n# nicht_tupel = (42)  # Ohne Komma = nur die Zahl in Klammern\n\n# Tupel-Methoden (nur 2!)\nzahlen = (1, 2, 3, 2, 2, 4)\nprint(f\"Die 2 kommt {zahlen.count(2)}Ã— vor\")  # count() zÃ¤hlt\nprint(f\"Die 3 ist an Position {zahlen.index(3)}\")  # index() findet Position\n\n# Tupel in Funktionen (hÃ¤ufig fÃ¼r mehrere RÃ¼ckgabewerte)\ndef min_max(zahlen_liste):\n    \"\"\"Gibt kleinste und grÃ¶ÃŸte Zahl als Tupel zurÃ¼ck\"\"\"\n    return (min(zahlen_liste), max(zahlen_liste))\n\nminimum, maximum = min_max([5, 2, 9, 1, 7])\nprint(f\"Min: {minimum}, Max: {maximum}\")",
                                "checkpoint": " - Tupel kÃ¶nnen erstellt, aber nicht geÃ¤ndert werden - Unpacking funktioniert elegant - count() und index() sind die einzigen Tupel-Methoden"
                        },
                        {
                                "number": 2,
                                "title": "Sets verstehen",
                                "goal": "Sets kennenlernen - ungeordnete Sammlungen EINZIGARTIGER Werte",
                                "why": "Sets sind perfekt wenn du:",
                                "instruction": "",
                                "code": "# SET: Ungeordnete Sammlung von EINZIGARTIGEN Werten\n# Erstellt mit geschweiften Klammern {} (wie Dict, aber ohne Keys)\n\n# Liste mit Duplikaten\nliste = [1, 2, 2, 3, 3, 3, 4, 5, 5]\nprint(f\"Liste: {liste}\")\n\n# In Set umwandeln â†’ Duplikate verschwinden!\nunique_set = set(liste)\nprint(f\"Set: {unique_set}\")  # {1, 2, 3, 4, 5}\n\n# ZurÃ¼ck in Liste\nunique_liste = list(unique_set)\nprint(f\"Eindeutige Liste: {unique_liste}\")\n\n# Set direkt erstellen\nfarben = {\"rot\", \"grÃ¼n\", \"blau\", \"rot\"}  # \"rot\" doppelt wird ignoriert\nprint(f\"Farben: {farben}\")  # Nur einmal \"rot\"\n\n# Leeres Set (ACHTUNG: {} ist ein leeres Dict!)\nleeres_set = set()  # Richtig\n# nicht_set = {}  # Das ist ein Dict!\n\n# Set-Operationen\nset1 = {1, 2, 3, 4, 5}\nset2 = {4, 5, 6, 7, 8}\n\n# Vereinigung (union): Alle Elemente aus beiden Sets\nvereinigung = set1 | set2  # oder: set1.union(set2)\nprint(f\"Vereinigung: {vereinigung}\")  # {1,2,3,4,5,6,7,8}\n\n# Schnittmenge (intersection): Nur gemeinsame Elemente\nschnittmenge = set1 & set2  # oder: set1.intersection(set2)\nprint(f\"Schnittmenge: {schnittmenge}\")  # {4, 5}\n\n# Differenz: In set1 aber nicht in set2\ndifferenz = set1 - set2  # oder: set1.difference(set2)\nprint(f\"Differenz: {differenz}\")  # {1, 2, 3}\n\n# Symmetrische Differenz: In einem der Sets, aber nicht in beiden\nsym_diff = set1 ^ set2  # oder: set1.symmetric_difference(set2)\nprint(f\"Sym. Differenz: {sym_diff}\")  # {1,2,3,6,7,8}\n\n# Set-Methoden\nfarben = {\"rot\", \"grÃ¼n\", \"blau\"}\n\nfarben.add(\"gelb\")  # Einzelnes Element hinzufÃ¼gen\nprint(farben)\n\nfarben.remove(\"rot\")  # Element entfernen (Fehler wenn nicht vorhanden)\nprint(farben)\n\nfarben.discard(\"pink\")  # Entfernen (KEIN Fehler wenn nicht vorhanden)\n\n# Membership-Test (sehr schnell!)\nif \"grÃ¼n\" in farben:\n    print(\"GrÃ¼n ist dabei!\")\n\n# Sets sind ungeordnet! Keine Indexierung mÃ¶glich\n# farben[0]  # FEHLER! Sets haben keine Indizes",
                                "checkpoint": " - Duplikate werden automatisch entfernt - Set-Operationen (|, &, -, ^) funktionieren - Sets sind schneller fÃ¼r Membership-Tests als Listen"
                        },
                        {
                                "number": 3,
                                "title": "Lotto-Zahlen Generator (Sets in Aktion)",
                                "goal": "Einen echten Lotto-Generator bauen",
                                "why": "Lotto = eindeutige Zufallszahlen â†’ perfekt fÃ¼r Sets!",
                                "instruction": "",
                                "code": "import random\n\ndef generiere_lotto_zahlen(anzahl=6, minimum=1, maximum=49):\n    \"\"\"\n    Generiert eindeutige Lotto-Zahlen\n    \n    Parameter:\n        anzahl: Wie viele Zahlen (Standard: 6)\n        minimum: Kleinste Zahl (Standard: 1)\n        maximum: GrÃ¶ÃŸte Zahl (Standard: 49)\n    \n    RÃ¼ckgabe:\n        Sortierte Liste von eindeutigen Zahlen\n    \"\"\"\n    # Methode 1: Mit Set\n    zahlen = set()\n    \n    while len(zahlen) < anzahl:\n        neue_zahl = random.randint(minimum, maximum)\n        zahlen.add(neue_zahl)  # Set verhindert automatisch Duplikate\n    \n    # In sortierte Liste umwandeln\n    return sorted(list(zahlen))\n\n# Methode 2: Mit random.sample (einfacher!)\ndef generiere_lotto_zahlen_v2(anzahl=6, minimum=1, maximum=49):\n    \"\"\"Elegantere Variante mit random.sample\"\"\"\n    pool = range(minimum, maximum + 1)  # Alle mÃ¶glichen Zahlen\n    zahlen = random.sample(pool, anzahl)  # WÃ¤hlt anzahl Zahlen ohne Duplikate\n    return sorted(zahlen)\n\n# Testen\nprint(\"ğŸ° LOTTO-GENERATOR\")\nprint(\"=\" * 50)\n\nfor i in range(3):\n    zahlen = generiere_lotto_zahlen_v2()\n    print(f\"Ziehung {i+1}: {zahlen}\")\n\n# Verschiedene Lotto-Varianten\nprint(\"\\nğŸ“Š Internationale Lotto-Varianten:\")\nprint(f\"6 aus 49 (Deutschland): {generiere_lotto_zahlen_v2(6, 1, 49)}\")\nprint(f\"5 aus 50 (EuroJackpot): {generiere_lotto_zahlen_v2(5, 1, 50)}\")\nprint(f\"6 aus 45 (Ã–sterreich): {generiere_lotto_zahlen_v2(6, 1, 45)}\")\n\n# Statistik Ã¼ber viele Ziehungen\nprint(\"\\nğŸ“ˆ STATISTIK (1000 Ziehungen)\")\nhaeufigkeit = {}  # Dict zum ZÃ¤hlen\n\nfor _ in range(1000):\n    zahlen = generiere_lotto_zahlen_v2()\n    for zahl in zahlen:\n        haeufigkeit[zahl] = haeufigkeit.get(zahl, 0) + 1\n\n# Top 10 hÃ¤ufigste Zahlen\nsortiert = sorted(haeufigkeit.items(), key=lambda x: x[1], reverse=True)\nprint(\"Top 10 hÃ¤ufigste Zahlen:\")\nfor i, (zahl, anzahl) in enumerate(sortiert[:10], 1):\n    print(f\"{i}. Zahl {zahl}: {anzahl}Ã— gezogen\")",
                                "checkpoint": " - Lotto-Zahlen sind immer eindeutig - Verschiedene Lotto-Systeme funktionieren - Statistik zeigt HÃ¤ufigkeiten Ã¼ber viele Ziehungen"
                        },
                        {
                                "number": 4,
                                "title": "Interaktiver Lotto-Simulator",
                                "goal": "VollstÃ¤ndiger Lotto-Simulator mit Tipp-Abgabe und GewinnprÃ¼fung",
                                "why": "Kombiniert Sets, Tupel und alles Gelernte!",
                                "instruction": "",
                                "code": "import random\n\ndef hole_benutzer_tipp(anzahl=6, minimum=1, maximum=49):\n    \"\"\"LÃ¤sst Benutzer Lotto-Zahlen eingeben\"\"\"\n    print(f\"\\nğŸ“ Gib {anzahl} Zahlen zwischen {minimum} und {maximum} ein:\")\n    \n    tipp = set()  # Set verhindert Duplikate\n    \n    while len(tipp) < anzahl:\n        verbleibend = anzahl - len(tipp)\n        try:\n            eingabe = input(f\"Zahl {len(tipp)+1}/{anzahl}: \")\n            zahl = int(eingabe)\n            \n            if zahl < minimum or zahl > maximum:\n                print(f\"âŒ Zahl muss zwischen {minimum} und {maximum} sein!\")\n            elif zahl in tipp:\n                print(f\"âŒ {zahl} hast du schon gewÃ¤hlt!\")\n            else:\n                tipp.add(zahl)\n                print(f\"âœ… {zahl} gespeichert\")\n                \n        except ValueError:\n            print(\"âŒ Bitte eine gÃ¼ltige Zahl eingeben!\")\n    \n    return tipp\n\ndef pruefe_gewinn(tipp, ziehung):\n    \"\"\"\n    PrÃ¼ft wie viele Richtige der Spieler hat\n    \n    Returns:\n        Tupel (anzahl_richtige, richtige_zahlen)\n    \"\"\"\n    # Schnittmenge = gemeinsame Zahlen\n    richtige = tipp & ziehung  # oder: tipp.intersection(ziehung)\n    return (len(richtige), richtige)\n\ndef bestimme_gewinnklasse(anzahl_richtige, total=6):\n    \"\"\"Bestimmt Gewinnklasse basierend auf Richtigen\"\"\"\n    gewinnklassen = {\n        6: (\"ğŸ‰ JACKPOT! 6 Richtige!\", \"ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°\"),\n        5: (\"ğŸŠ 5 Richtige!\", \"ğŸ’°ğŸ’°ğŸ’°ğŸ’°\"),\n        4: (\"ğŸ 4 Richtige!\", \"ğŸ’°ğŸ’°ğŸ’°\"),\n        3: (\"âœ¨ 3 Richtige!\", \"ğŸ’°ğŸ’°\"),\n        2: (\"ğŸ‘ 2 Richtige!\", \"ğŸ’°\"),\n        1: (\"ğŸ˜• 1 Richtige\", \"\"),\n        0: (\"ğŸ˜ 0 Richtige\", \"\")\n    }\n    return gewinnklassen.get(anzahl_richtige, (\"\", \"\"))\n\n# HAUPTPROGRAMM\ndef main():\n    print(\"=\" * 60)\n    print(\"ğŸ° LOTTO-SIMULATOR 6 aus 49\")\n    print(\"=\" * 60)\n    \n    # Spielmodus wÃ¤hlen\n    print(\"\\nWÃ¤hle Modus:\")\n    print(\"1. Ich gebe meine Zahlen ein\")\n    print(\"2. Zufallstipp generieren\")\n    \n    wahl = input(\"\\nModus (1/2): \").strip()\n    \n    if wahl == \"1\":\n        mein_tipp = hole_benutzer_tipp()\n    else:\n        mein_tipp = set(random.sample(range(1, 50), 6))\n        print(f\"\\nğŸ² Dein Zufallstipp: {sorted(mein_tipp)}\")\n    \n    input(\"\\nâ³ DrÃ¼cke Enter fÃ¼r die Ziehung...\")\n    \n    # Ziehung durchfÃ¼hren\n    ziehung = set(random.sample(range(1, 50), 6))\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"ğŸ± ZIEHUNG\")\n    print(\"=\" * 60)\n    print(f\"Gezogene Zahlen: {sorted(ziehung)}\")\n    print(f\"Dein Tipp:       {sorted(mein_tipp)}\")\n    \n    # Gewinn prÃ¼fen\n    anzahl, richtige = pruefe_gewinn(mein_tipp, ziehung)\n    titel, emoji = bestimme_gewinnklasse(anzahl)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"ğŸ“Š ERGEBNIS\")\n    print(\"=\" * 60)\n    \n    if anzahl > 0:\n        print(f\"Richtige Zahlen: {sorted(richtige)}\")\n    \n    print(f\"\\n{titel} {emoji}\")\n    print(f\"Du hattest {anzahl} von 6 Zahlen richtig!\")\n    \n    # Statistik\n    if anzahl >= 3:\n        print(\"\\nğŸ GlÃ¼ckwunsch, du hast gewonnen!\")\n    else:\n        print(\"\\nğŸ’ª Viel GlÃ¼ck beim nÃ¤chsten Mal!\")\n    \n    # Verpasste Zahlen\n    verpasst = mein_tipp - ziehung  # Differenz\n    if verpasst:\n        print(f\"\\nâŒ Diese deiner Zahlen wurden nicht gezogen: {sorted(verpasst)}\")\n    \n    falsche_gezogene = ziehung - mein_tipp\n    if falsche_gezogene:\n        print(f\"â• Diese gezogenen Zahlen hattest du nicht: {sorted(falsche_gezogene)}\")\n\nif __name__ == \"__main__\":\n    main()\n    \n    # Nochmal spielen?\n    while input(\"\\nğŸ”„ Nochmal spielen? (j/n): \").lower() == \"j\":\n        print(\"\\n\" * 2)\n        main()",
                                "checkpoint": " - Benutzer kann eigene Zahlen eingeben oder zufÃ¤llig wÃ¤hlen - Duplikate werden verhindert - GewinnprÃ¼fung mit Set-Operationen (Schnittmenge) - AusfÃ¼hrliche Statistik mit verpassten/falschen Zahlen"
                        }
                ]
        },
        {
                "id": 3,
                "weekId": 2,
                "title": "Datenfilter mit List Comprehensions",
                "duration": "45-60 min",
                "task": {
                        "title": "Datenfilter mit List Comprehensions",
                        "description": "Lerne List Comprehensions - eine elegante Python-Syntax fÃ¼r Listen-Transformationen!",
                        "goals": [
                                "List Comprehension: `[x for x in liste]`",
                                "Mit Filter: `[x for x in liste if bedingung]`",
                                "Mit If-Else: `[x if bed else y for x in liste]`",
                                "Verschachtelt: `[item for sublist in liste for item in sublist]`",
                                "Dict Comprehension: `{k: v for k, v in ...}`",
                                "Set Comprehension: `{x for x in liste}`",
                                "Generator Expressions: `(x for x in liste)` (Memory-effizient)"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "List Comprehension Basics",
                                "goal": "Verstehen wie List Comprehensions funktionieren",
                                "why": "List Comprehensions sind:",
                                "instruction": "",
                                "code": "# ALTE METHODE: For-Schleife\nzahlen = [1, 2, 3, 4, 5]\nquadrate = []\n\nfor zahl in zahlen:\n    quadrate.append(zahl ** 2)\n\nprint(f\"Mit For-Schleife: {quadrate}\")\n\n# NEUE METHODE: List Comprehension\n# Syntax: [ausdruck for element in liste]\nquadrate_lc = [zahl ** 2 for zahl in zahlen]\n\nprint(f\"Mit List Comprehension: {quadrate_lc}\")\n\n# Beide machen das Gleiche, aber List Comprehension ist:\n# - Eine Zeile statt 4\n# - Schneller\n# - Eleganter\n\n# Mehr Beispiele\n# Strings in GroÃŸbuchstaben\nnamen = [\"anna\", \"ben\", \"clara\"]\ngroÃŸ = [name.upper() for name in namen]\nprint(groÃŸ)  # ['ANNA', 'BEN', 'CLARA']\n\n# LÃ¤ngen von Strings\nlaengen = [len(name) for name in namen]\nprint(laengen)  # [4, 3, 5]\n\n# Erste Buchstaben\ninitialen = [name[0].upper() for name in namen]\nprint(initialen)  # ['A', 'B', 'C']\n\n# Mit range()\n# Gerade Zahlen von 0 bis 20\ngerade = [x for x in range(21) if x % 2 == 0]\nprint(gerade)  # [0, 2, 4, 6, ..., 20]\n\n# Zahlen verdoppeln\noriginal = [1, 2, 3, 4, 5]\nverdoppelt = [x * 2 for x in original]\nprint(verdoppelt)  # [2, 4, 6, 8, 10]",
                                "checkpoint": " - List Comprehensions erstellen neue Listen in einer Zeile - Syntax: `[ausdruck for element in liste]` - Funktioniert mit jeder iterierbaren Struktur"
                        },
                        {
                                "number": 2,
                                "title": "Conditional List Comprehensions",
                                "goal": "If-Bedingungen in List Comprehensions einbauen",
                                "why": "Oft wollen wir nur bestimmte Elemente filtern!",
                                "instruction": "",
                                "code": "zahlen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# FILTERN mit if (am Ende)\n# Syntax: [ausdruck for element in liste if bedingung]\n\n# Nur gerade Zahlen\ngerade = [x for x in zahlen if x % 2 == 0]\nprint(f\"Gerade: {gerade}\")  # [2, 4, 6, 8, 10]\n\n# Nur ungerade\nungerade = [x for x in zahlen if x % 2 != 0]\nprint(f\"Ungerade: {ungerade}\")  # [1, 3, 5, 7, 9]\n\n# Zahlen grÃ¶ÃŸer als 5\ngroÃŸ = [x for x in zahlen if x > 5]\nprint(f\"GrÃ¶ÃŸer als 5: {groÃŸ}\")  # [6, 7, 8, 9, 10]\n\n# Mit Transformation UND Filter\n# Quadrate der geraden Zahlen\ngerade_quadrate = [x ** 2 for x in zahlen if x % 2 == 0]\nprint(f\"Quadrate gerader Zahlen: {gerade_quadrate}\")  # [4, 16, 36, 64, 100]\n\n# IF-ELSE in List Comprehension (anderes Muster!)\n# Syntax: [ausdruck_wenn_wahr if bedingung else ausdruck_wenn_falsch for element in liste]\n\n# Gerade â†’ \"gerade\", Ungerade â†’ \"ungerade\"\nlabels = [\"gerade\" if x % 2 == 0 else \"ungerade\" for x in zahlen]\nprint(labels)\n\n# Positive â†’ Zahl, Negative â†’ 0\nzahlen_mit_negativen = [-2, -1, 0, 1, 2, 3]\nnur_positive = [x if x > 0 else 0 for x in zahlen_mit_negativen]\nprint(nur_positive)  # [0, 0, 0, 1, 2, 3]\n\n# Strings filtern\nworte = [\"Python\", \"Java\", \"C++\", \"JavaScript\", \"Ruby\"]\n\n# Nur Worte mit mehr als 4 Buchstaben\nlang = [wort for wort in worte if len(wort) > 4]\nprint(lang)  # ['Python', 'JavaScript']\n\n# Worte die 'a' enthalten\nmit_a = [wort for wort in worte if 'a' in wort.lower()]\nprint(mit_a)  # ['Java', 'JavaScript']\n\n# Praxisbeispiel: Zahlen aus gemischter Liste extrahieren\ngemischt = [1, \"Text\", 3.14, \"Hallo\", 42, None, 7]\nnur_zahlen = [x for x in gemischt if isinstance(x, (int, float))]\nprint(f\"Nur Zahlen: {nur_zahlen}\")  # [1, 3.14, 42, 7]",
                                "checkpoint": " - Filter mit `if` am Ende: `[x for x in liste if bedingung]` - If-Else fÃ¼r Transformation: `[x if bed else y for x in liste]` - Kombination mÃ¶glich: Transformation UND Filtern"
                        },
                        {
                                "number": 3,
                                "title": "Verschachtelte List Comprehensions",
                                "goal": "Mit 2D-Listen (Listen von Listen) arbeiten",
                                "why": "Matrix-Operationen, verschachtelte Daten verarbeiten",
                                "instruction": "",
                                "code": "# 2D-Liste (Matrix)\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# ALTE METHODE: Alle Zahlen in eine flache Liste\nflach = []\nfor zeile in matrix:\n    for zahl in zeile:\n        flach.append(zahl)\n\nprint(f\"Flach (for): {flach}\")\n\n# MIT LIST COMPREHENSION (Flatten)\n# Syntax: [element for zeile in matrix for element in zeile]\nflach_lc = [zahl for zeile in matrix for zahl in zeile]\nprint(f\"Flach (LC): {flach_lc}\")  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Matrix transponieren (Zeilen <-> Spalten)\n# Original:     Transponiert:\n# 1 2 3         1 4 7\n# 4 5 6    â†’    2 5 8\n# 7 8 9         3 6 9\n\ntransponiert = [[zeile[i] for zeile in matrix] for i in range(3)]\nprint(\"Transponiert:\")\nfor zeile in transponiert:\n    print(zeile)\n\n# Alle Zahlen verdoppeln\nverdoppelt = [[zahl * 2 for zahl in zeile] for zeile in matrix]\nprint(\"Verdoppelt:\")\nfor zeile in verdoppelt:\n    print(zeile)\n\n# Nur gerade Zahlen aus 2D-Liste\ngerade_2d = [[zahl for zahl in zeile if zahl % 2 == 0] for zeile in matrix]\nprint(\"Nur gerade:\")\nfor zeile in gerade_2d:\n    print(zeile)  # [[2], [4, 6], [8]]\n\n# Koordinaten generieren\n# Alle (x, y) Paare von (0,0) bis (2,2)\nkoordinaten = [(x, y) for x in range(3) for y in range(3)]\nprint(f\"Koordinaten: {koordinaten}\")\n# [(0,0), (0,1), (0,2), (1,0), (1,1), ...]\n\n# Multiplikationstabelle mit List Comprehension!\ntabelle = [[x * y for y in range(1, 11)] for x in range(1, 11)]\nprint(\"\\n1Ã—1 Tabelle (erste 5Ã—5):\")\nfor i in range(5):\n    print(tabelle[i][:5])  # Erste 5 Spalten",
                                "checkpoint": " - Verschachtelte Listen flatten: `[item for sublist in liste for item in sublist]` - 2D-Operationen mÃ¶glich - Matrix-Transformationen elegant"
                        },
                        {
                                "number": 4,
                                "title": "Dict & Set Comprehensions",
                                "goal": "Comprehensions fÃ¼r Dictionaries und Sets",
                                "why": "Nicht nur Listen - auch Dicts und Sets haben Comprehensions!",
                                "instruction": "",
                                "code": "# DICT COMPREHENSION\n# Syntax: {key: value for element in liste}\n\nzahlen = [1, 2, 3, 4, 5]\n\n# Zahl â†’ Quadrat\nquadrate_dict = {zahl: zahl ** 2 for zahl in zahlen}\nprint(f\"Quadrate Dict: {quadrate_dict}\")\n# {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n# Strings zu LÃ¤ngen\nworte = [\"Python\", \"Java\", \"C++\"]\nlaengen_dict = {wort: len(wort) for wort in worte}\nprint(f\"LÃ¤ngen: {laengen_dict}\")\n# {'Python': 6, 'Java': 4, 'C++': 3}\n\n# Mit Filter\n# Nur Worte lÃ¤nger als 3 Zeichen\nlang_dict = {wort: len(wort) for wort in worte if len(wort) > 3}\nprint(f\"Lange Worte: {lang_dict}\")\n\n# Dict umkehren (Keys <-> Values)\noriginal_dict = {'a': 1, 'b': 2, 'c': 3}\numgekehrt = {value: key for key, value in original_dict.items()}\nprint(f\"Umgekehrt: {umgekehrt}\")  # {1: 'a', 2: 'b', 3: 'c'}\n\n# SET COMPREHENSION\n# Syntax: {ausdruck for element in liste}\n\nzahlen = [1, 2, 2, 3, 3, 3, 4, 4, 5]\n\n# Duplikate entfernen und transformieren\nquadrate_set = {x ** 2 for x in zahlen}\nprint(f\"Quadrate Set: {quadrate_set}\")  # {1, 4, 9, 16, 25}\n\n# Erste Buchstaben (eindeutig)\nnamen = [\"Anna\", \"Anton\", \"Ben\", \"Berta\", \"Clara\"]\ninitialen_set = {name[0] for name in namen}\nprint(f\"Initialen: {initialen_set}\")  # {'A', 'B', 'C'}\n\n# Praxisbeispiel: Dateierweiterungen aus Dateinamen\ndateien = [\"foto.jpg\", \"dokument.pdf\", \"bild.jpg\", \"text.txt\", \"musik.mp3\", \"video.mp4\"]\n\n# Alle Erweiterungen (eindeutig)\nerweiterungen = {datei.split('.')[-1] for datei in dateien}\nprint(f\"Erweiterungen: {erweiterungen}\")  # {'jpg', 'pdf', 'txt', 'mp3', 'mp4'}\n\n# Gruppierung: Dict mit Listen als Values\n# Dateien nach Erweiterung gruppieren\nfrom collections import defaultdict\n\ngruppiert = defaultdict(list)\nfor datei in dateien:\n    ext = datei.split('.')[-1]\n    gruppiert[ext].append(datei)\n\nprint(\"\\nDateien nach Typ:\")\nfor ext, files in gruppiert.items():\n    print(f\"{ext}: {files}\")\n\n# Das Gleiche mit Dict Comprehension + List Comprehension\nerweiterungen_unique = {datei.split('.')[-1] for datei in dateien}\ngruppiert_lc = {\n    ext: [datei for datei in dateien if datei.endswith(ext)]\n    for ext in erweiterungen_unique\n}\nprint(\"\\nGruppiert (LC):\", gruppiert_lc)",
                                "checkpoint": " - Dict Comprehension: `{key: value for ...}` - Set Comprehension: `{value for ...}` - Beide unterstÃ¼tzen Filter und Transformation"
                        },
                        {
                                "number": 5,
                                "title": "Praxisprojekt - Dateianalyse Tool",
                                "goal": "Alle Comprehensions in einem echten Projekt kombinieren",
                                "why": "Zeigt wie man Comprehensions in der Praxis einsetzt!",
                                "instruction": "",
                                "code": "def analysiere_text(text):\n    \"\"\"\n    Analysiert einen Text mit List/Dict/Set Comprehensions\n    \n    Returns: Dict mit verschiedenen Statistiken\n    \"\"\"\n    # Worte extrahieren und normalisieren\n    import string\n    \n    # Alle Worte in Kleinbuchstaben, ohne Satzzeichen\n    worte = [\n        wort.strip(string.punctuation).lower()\n        for wort in text.split()\n        if wort.strip(string.punctuation)  # Leere Worte ignorieren\n    ]\n    \n    # Statistiken mit Comprehensions\n    stats = {\n        # Anzahl Worte\n        'gesamt': len(worte),\n        \n        # Eindeutige Worte (Set)\n        'eindeutig': len(set(worte)),\n        \n        # Durchschnittliche WortlÃ¤nge\n        'durchschnitt_laenge': sum(len(w) for w in worte) / len(worte) if worte else 0,\n        \n        # LÃ¤ngste Worte (Top 5)\n        'laengste': sorted(set(worte), key=len, reverse=True)[:5],\n        \n        # Wort-HÃ¤ufigkeiten (Dict Comprehension)\n        'haeufigkeiten': {\n            wort: worte.count(wort)\n            for wort in set(worte)\n        },\n        \n        # Worte nach LÃ¤nge gruppiert (Dict mit List Comprehension)\n        'nach_laenge': {\n            laenge: [w for w in set(worte) if len(w) == laenge]\n            for laenge in sorted(set(len(w) for w in worte))\n        },\n        \n        # Worte die mit Vokal beginnen\n        'mit_vokal': [w for w in set(worte) if w[0] in 'aeiou'],\n        \n        # Alle verwendeten Buchstaben (Set Comprehension)\n        'buchstaben': {char for wort in worte for char in wort}\n    }\n    \n    # Top 10 hÃ¤ufigste Worte\n    sortiert = sorted(\n        stats['haeufigkeiten'].items(),\n        key=lambda x: x[1],\n        reverse=True\n    )\n    stats['top10'] = sortiert[:10]\n    \n    return stats\n\n# Testen\nbeispiel_text = \"\"\"\nPython ist eine interpretierte, objektorientierte Programmiersprache.\nPython wurde entwickelt um Code lesbar zu machen. Python ist einfach\nzu lernen und sehr mÃ¤chtig. Python wird fÃ¼r Web-Entwicklung, Data Science,\nAutomatisierung und vieles mehr verwendet. Python ist toll!\n\"\"\"\n\nprint(\"ğŸ“Š TEXT-ANALYSE mit List Comprehensions\")\nprint(\"=\" * 60)\n\nstats = analysiere_text(beispiel_text)\n\nprint(f\"\\nğŸ“ Gesamt: {stats['gesamt']} Worte\")\nprint(f\"ğŸ”¤ Eindeutig: {stats['eindeutig']} verschiedene Worte\")\nprint(f\"ğŸ“ Durchschnittliche LÃ¤nge: {stats['durchschnitt_laenge']:.1f} Zeichen\")\n\nprint(f\"\\nğŸ“ˆ Top 10 hÃ¤ufigste Worte:\")\nfor i, (wort, anzahl) in enumerate(stats['top10'], 1):\n    print(f\"   {i}. '{wort}': {anzahl}Ã—\")\n\nprint(f\"\\nğŸ“ LÃ¤ngste Worte:\")\nfor wort in stats['laengste']:\n    print(f\"   - {wort} ({len(wort)} Zeichen)\")\n\nprint(f\"\\nğŸ”¤ Verwendete Buchstaben ({len(stats['buchstaben'])}):\")\nprint(f\"   {sorted(stats['buchstaben'])}\")\n\nprint(f\"\\nğŸ¯ Worte nach LÃ¤nge:\")\nfor laenge, worte_liste in sorted(stats['nach_laenge'].items())[:5]:  # Erste 5\n    print(f\"   {laenge} Zeichen: {', '.join(worte_liste[:5])}\")  # Max 5 Beispiele\n\n# Filterfunktion\ndef filtere_worte(text, min_laenge=4, mit_buchstabe=None):\n    \"\"\"Filtert Worte nach Kriterien\"\"\"\n    import string\n    \n    worte = [\n        wort.strip(string.punctuation).lower()\n        for wort in text.split()\n        if wort.strip(string.punctuation)\n    ]\n    \n    # Mehrere Filter kombinieren\n    gefiltert = [\n        wort for wort in set(worte)\n        if len(wort) >= min_laenge\n        and (mit_buchstabe is None or mit_buchstabe.lower() in wort)\n    ]\n    \n    return sorted(gefiltert)\n\nprint(\"\\n\\nğŸ” FILTER-BEISPIELE:\")\nprint(f\"Worte mit min. 6 Buchstaben: {filtere_worte(beispiel_text, min_laenge=6)}\")\nprint(f\"Worte mit 'y': {filtere_worte(beispiel_text, mit_buchstabe='y')}\")\nprint(f\"Lange Worte mit 't': {filtere_worte(beispiel_text, min_laenge=5, mit_buchstabe='t')}\")",
                                "checkpoint": " - Komplexe Datenanalyse mit Comprehensions - Mehrere Comprehension-Typen kombiniert - Verschachtelte Comprehensions fÃ¼r Gruppierung - Performance: Schneller als traditionelle Loops"
                        }
                ]
        },
        {
                "id": 4,
                "weekId": 2,
                "title": "Textdatei-Analyzer (Dateien Lesen)",
                "duration": "45-60 min",
                "task": {
                        "title": "Textdatei-Analyzer (Dateien Lesen)",
                        "description": "Lerne wie man Dateien Ã¶ffnet, liest und analysiert!",
                        "goals": [
                                "Dateien Ã¶ffnen: `with open(file, \"r\") as f:`",
                                "Lese-Methoden: `.read()`, `.readline()`, `.readlines()`, iterieren",
                                "Encoding: `encoding=\"utf-8\"` fÃ¼r Umlaute",
                                "Datei-Analyse: Statistiken, Suche, Filter",
                                "CSV-Parsing: Strukturierte Daten lesen",
                                "Regex: Pattern-Matching mit `re`",
                                "Error Handling: try/except fÃ¼r FileNotFoundError"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Dateien Ã¶ffnen und lesen",
                                "goal": "Grundlagen des Datei-Handlings verstehen",
                                "why": "Fast jedes Programm arbeitet mit Dateien - Configs, Logs, Daten. Das ist essentiell!",
                                "instruction": "",
                                "code": "# METHODE 1: open() und close() (alte Methode)\n# âš ï¸ Nicht empfohlen - wir mÃ¼ssen manuell close() aufrufen\n\ndatei = open(\"test.txt\", \"r\")  # \"r\" = read (lesen)\ninhalt = datei.read()  # Liest ALLES\ndatei.close()  # WICHTIG: Datei schlieÃŸen!\n\n# METHODE 2: with-Statement (EMPFOHLEN!)\n# SchlieÃŸt die Datei automatisch, auch bei Fehlern\n\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as datei:\n    inhalt = datei.read()\n    print(inhalt)\n# Hier ist die Datei automatisch geschlossen!\n\n# encoding=\"utf-8\" ist wichtig fÃ¼r Umlaute (Ã¤, Ã¶, Ã¼, ÃŸ)\n\n# VERSCHIEDENE LESE-METHODEN\n\n# 1. .read() - Liest ALLES als einen String\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    alles = f.read()\n    print(\"Gesamter Inhalt:\", alles)\n\n# 2. .readline() - Liest EINE Zeile\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    zeile1 = f.readline()  # Erste Zeile\n    zeile2 = f.readline()  # Zweite Zeile\n    print(\"Erste Zeile:\", zeile1)\n    print(\"Zweite Zeile:\", zeile2)\n\n# 3. .readlines() - Liest ALLE Zeilen in eine Liste\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    alle_zeilen = f.readlines()  # Liste von Strings\n    print(\"Alle Zeilen als Liste:\", alle_zeilen)\n\n# 4. Ãœber Datei iterieren (BESTE Methode fÃ¼r groÃŸe Dateien!)\nwith open(\"test.txt\", \"r\", encoding=\"utf-8\") as f:\n    for zeile in f:  # Zeile fÃ¼r Zeile\n        print(f\"Zeile: {zeile.strip()}\")  # .strip() entfernt \\n am Ende\n\n# Erstmal eine Test-Datei erstellen\ntestinhalt = \"\"\"Python ist toll!\nDies ist Zeile 2.\nUnd hier ist Zeile 3.\nUmlaute: Ã¤Ã¶Ã¼ÃŸ\nZahlen: 12345\"\"\"\n\nwith open(\"test.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(testinhalt)\n\nprint(\"âœ… test.txt wurde erstellt!\")",
                                "checkpoint": " - `with open()` ist die beste Methode - `.read()` fÃ¼r kleinen Dateien - Iterieren fÃ¼r groÃŸe Dateien - `encoding=\"utf-8\"` fÃ¼r Umlaute"
                        },
                        {
                                "number": 2,
                                "title": "Dateien analysieren",
                                "goal": "Informationen aus Dateien extrahieren",
                                "why": "Daten in Dateien verstehen und verarbeiten",
                                "instruction": "",
                                "code": "def analysiere_datei(dateiname):\n    \"\"\"\n    Analysiert eine Textdatei\n    \n    Returns: Dict mit Statistiken\n    \"\"\"\n    try:\n        with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n            zeilen = f.readlines()\n        \n        # Statistiken sammeln\n        stats = {\n            'zeilen': len(zeilen),\n            'zeichen': sum(len(zeile) for zeile in zeilen),\n            'worte': sum(len(zeile.split()) for zeile in zeilen),\n            'leere_zeilen': sum(1 for zeile in zeilen if zeile.strip() == \"\"),\n            'laengste_zeile': max(zeilen, key=len) if zeilen else \"\",\n            'kuerzeste_zeile': min([z for z in zeilen if z.strip()], key=len) if zeilen else \"\",\n        }\n        \n        # Durchschnitte\n        nicht_leere_zeilen = [z for z in zeilen if z.strip()]\n        if nicht_leere_zeilen:\n            stats['durchschnitt_zeichen'] = stats['zeichen'] / len(nicht_leere_zeilen)\n            stats['durchschnitt_worte'] = stats['worte'] / len(nicht_leere_zeilen)\n        \n        return stats\n        \n    except FileNotFoundError:\n        print(f\"âŒ Datei '{dateiname}' nicht gefunden!\")\n        return None\n    except Exception as e:\n        print(f\"âŒ Fehler beim Lesen: {e}\")\n        return None\n\n# Testen\nprint(\"ğŸ“Š DATEI-ANALYSE\")\nprint(\"=\" * 50)\n\nstats = analysiere_datei(\"test.txt\")\n\nif stats:\n    print(f\"ğŸ“„ Zeilen: {stats['zeilen']}\")\n    print(f\"ğŸ“ Worte: {stats['worte']}\")\n    print(f\"ğŸ”¤ Zeichen: {stats['zeichen']}\")\n    print(f\"â¬œ Leere Zeilen: {stats['leere_zeilen']}\")\n    \n    if 'durchschnitt_worte' in stats:\n        print(f\"ğŸ“Š Ã˜ Worte/Zeile: {stats['durchschnitt_worte']:.1f}\")\n        print(f\"ğŸ“Š Ã˜ Zeichen/Zeile: {stats['durchschnitt_zeichen']:.1f}\")\n    \n    print(f\"\\nğŸ“ LÃ¤ngste Zeile ({len(stats['laengste_zeile'])} Zeichen):\")\n    print(f\"   {stats['laengste_zeile'].strip()}\")",
                                "checkpoint": " - Dateien werden zeilenweise analysiert - Statistiken werden berechnet - Fehlerbehandlung mit try/except"
                        },
                        {
                                "number": 3,
                                "title": "Spezifische Daten extrahieren",
                                "goal": "Bestimmte Informationen aus Dateien filtern",
                                "why": "Oft brauchen wir nur Teile einer Datei",
                                "instruction": "",
                                "code": "def finde_zeilen_mit(dateiname, suchbegriff, case_sensitive=False):\n    \"\"\"\n    Findet alle Zeilen die einen Suchbegriff enthalten\n    \n    Parameters:\n        dateiname: Pfad zur Datei\n        suchbegriff: Was gesucht wird\n        case_sensitive: GroÃŸ-/Kleinschreibung beachten?\n    \n    Returns:\n        Liste von (zeilennummer, zeile) Tupeln\n    \"\"\"\n    ergebnisse = []\n    \n    try:\n        with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n            for nummer, zeile in enumerate(f, start=1):\n                # Case-insensitive suche if gewÃ¼nscht\n                zeile_check = zeile if case_sensitive else zeile.lower()\n                begriff_check = suchbegriff if case_sensitive else suchbegriff.lower()\n                \n                if begriff_check in zeile_check:\n                    ergebnisse.append((nummer, zeile.strip()))\n        \n        return ergebnisse\n        \n    except FileNotFoundError:\n        print(f\"âŒ Datei '{dateiname}' nicht gefunden!\")\n        return []\n\n# Test-Datei mit mehr Inhalt\nlog_inhalt = \"\"\"2024-01-15 10:23:45 INFO: Server gestartet\n2024-01-15 10:24:01 ERROR: Verbindung fehlgeschlagen\n2024-01-15 10:24:15 INFO: Neuversuch...\n2024-01-15 10:24:20 INFO: Verbindung hergestellt\n2024-01-15 10:25:00 WARNING: Hohe Auslastung\n2024-01-15 10:26:30 ERROR: Timeout\n2024-01-15 10:27:00 INFO: Server lÃ¤uft normal\"\"\"\n\nwith open(\"logfile.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(log_inhalt)\n\n# Alle ERROR-EintrÃ¤ge finden\nprint(\"ğŸ” Suche nach ERROR:\")\nerrors = finde_zeilen_mit(\"logfile.txt\", \"ERROR\")\nfor nummer, zeile in errors:\n    print(f\"  Zeile {nummer}: {zeile}\")\n\n# Alle INFO-EintrÃ¤ge\nprint(\"\\nğŸ” Suche nach INFO:\")\ninfos = finde_zeilen_mit(\"logfile.txt\", \"INFO\")\nprint(f\"  Gefunden: {len(infos)} INFO-EintrÃ¤ge\")\n\n# Filterfunktion fÃ¼r Logdateien\ndef analysiere_log(dateiname):\n    \"\"\"ZÃ¤hlt verschiedene Log-Level\"\"\"\n    level_count = {}\n    \n    with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n        for zeile in f:\n            # Extrahiere Log-Level (nach Datum/Zeit)\n            parts = zeile.split()\n            if len(parts) >= 3:\n                level = parts[2].rstrip(':')  # Entferne ':' am Ende\n                level_count[level] = level_count.get(level, 0) + 1\n    \n    return level_count\n\nprint(\"\\nğŸ“Š Log-Level Statistik:\")\nstats = analysiere_log(\"logfile.txt\")\nfor level, count in sorted(stats.items()):\n    print(f\"  {level}: {count}Ã—\")",
                                "checkpoint": " - Spezifische Zeilen kÃ¶nnen gefunden werden - enumerate() gibt Zeilennummern - Case-insensitive Suche mÃ¶glich"
                        },
                        {
                                "number": 4,
                                "title": "CSV-Ã„hnliche Daten parsen",
                                "goal": "Strukturierte Daten aus Textdateien lesen",
                                "why": "Viele Daten kommen als CSV/TSV (Komma/Tab-getrennt)",
                                "instruction": "",
                                "code": "# CSV-Daten (Comma Separated Values)\ncsv_daten = \"\"\"Name,Alter,Stadt,Beruf\nAnna Schmidt,28,Berlin,Entwicklerin\nMax MÃ¼ller,35,MÃ¼nchen,Designer\nLisa Weber,42,Hamburg,Managerin\nTom Klein,31,KÃ¶ln,Analyst\"\"\"\n\nwith open(\"personen.csv\", \"w\", encoding=\"utf-8\") as f:\n    f.write(csv_daten)\n\ndef parse_csv(dateiname, delimiter=','):\n    \"\"\"\n    Parst eine CSV-Datei (einfache Version)\n    \n    Returns:\n        Liste von Dicts (ein Dict pro Zeile)\n    \"\"\"\n    daten = []\n    \n    with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n        zeilen = f.readlines()\n        \n        if not zeilen:\n            return daten\n        \n        # Erste Zeile = Spalten-Namen\n        header = zeilen[0].strip().split(delimiter)\n        \n        # Rest = Daten\n        for zeile in zeilen[1:]:\n            if zeile.strip():  # Ignoriere leere Zeilen\n                werte = zeile.strip().split(delimiter)\n                \n                # Dict erstellen: {spaltenname: wert}\n                eintrag = {\n                    header[i]: werte[i]\n                    for i in range(len(header))\n                    if i < len(werte)\n                }\n                \n                daten.append(eintrag)\n    \n    return daten\n\n# CSV einlesen\nprint(\"ğŸ“‹ CSV-DATEN\")\nprint(\"=\" * 50)\n\npersonen = parse_csv(\"personen.csv\")\n\nfor person in personen:\n    print(f\"\\nğŸ‘¤ {person['Name']}\")\n    print(f\"   Alter: {person['Alter']}\")\n    print(f\"   Stadt: {person['Stadt']}\")\n    print(f\"   Beruf: {person['Beruf']}\")\n\n# Daten filtern und analysieren\nprint(\"\\nğŸ“Š AUSWERTUNGEN:\")\n\n# Durchschnittsalter\nalter_liste = [int(p['Alter']) for p in personen]\ndurchschnitt = sum(alter_liste) / len(alter_liste)\nprint(f\"Durchschnittsalter: {durchschnitt:.1f} Jahre\")\n\n# Personen aus Berlin\nberliner = [p for p in personen if p['Stadt'] == 'Berlin']\nprint(f\"Personen aus Berlin: {len(berliner)}\")\n\n# StÃ¤dte-Verteilung\nstaedte = {}\nfor person in personen:\n    stadt = person['Stadt']\n    staedte[stadt] = staedte.get(stadt, 0) + 1\n\nprint(\"\\nPersonen pro Stadt:\")\nfor stadt, anzahl in sorted(staedte.items()):\n    print(f\"  {stadt}: {anzahl}\")",
                                "checkpoint": " - CSV-Dateien kÃ¶nnen geparst werden - Header-Zeile wird als Spalten-Namen verwendet - Daten werden als Liste von Dicts gespeichert"
                        },
                        {
                                "number": 5,
                                "title": "GroÃŸes Projekt - Logfile-Analyzer",
                                "goal": "VollstÃ¤ndiger Datei-Analyzer mit allen Features",
                                "why": "Real-World Anwendung aller gelernten Konzepte!",
                                "instruction": "",
                                "code": "import re\nfrom datetime import datetime\nfrom collections import Counter\n\nclass LogAnalyzer:\n    \"\"\"Analysiert Logdateien\"\"\"\n    \n    def __init__(self, dateiname):\n        self.dateiname = dateiname\n        self.zeilen = []\n        self.lade_datei()\n    \n    def lade_datei(self):\n        \"\"\"LÃ¤dt die Logdatei\"\"\"\n        try:\n            with open(self.dateiname, \"r\", encoding=\"utf-8\") as f:\n                self.zeilen = f.readlines()\n            print(f\"âœ… {len(self.zeilen)} Zeilen geladen\")\n        except FileNotFoundError:\n            print(f\"âŒ Datei '{self.dateiname}' nicht gefunden!\")\n            self.zeilen = []\n    \n    def zaehle_level(self):\n        \"\"\"ZÃ¤hlt verschiedene Log-Levels\"\"\"\n        levels = []\n        \n        for zeile in self.zeilen:\n            # Suche nach ERROR, WARNING, INFO, etc.\n            match = re.search(r'(ERROR|WARNING|INFO|DEBUG)', zeile)\n            if match:\n                levels.append(match.group(1))\n        \n        return Counter(levels)\n    \n    def finde_errors(self):\n        \"\"\"Findet alle ERROR-Zeilen\"\"\"\n        errors = []\n        \n        for nummer, zeile in enumerate(self.zeilen, start=1):\n            if 'ERROR' in zeile:\n                errors.append((nummer, zeile.strip()))\n        \n        return errors\n    \n    def zeitanalyse(self):\n        \"\"\"Analysiert Zeitstempel\"\"\"\n        zeiten = []\n        \n        for zeile in self.zeilen:\n            # Suche nach Datum/Zeit Pattern: YYYY-MM-DD HH:MM:SS\n            match = re.search(r'(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})', zeile)\n            if match:\n                try:\n                    zeit = datetime.strptime(match.group(1), '%Y-%m-%d %H:%M:%S')\n                    zeiten.append(zeit)\n                except ValueError:\n                    pass\n        \n        if not zeiten:\n            return None\n        \n        return {\n            'erste': min(zeiten),\n            'letzte': max(zeiten),\n            'dauer': max(zeiten) - min(zeiten),\n            'anzahl': len(zeiten)\n        }\n    \n    def statistiken(self):\n        \"\"\"Erstellt umfassende Statistiken\"\"\"\n        return {\n            'zeilen_gesamt': len(self.zeilen),\n            'zeichen_gesamt': sum(len(z) for z in self.zeilen),\n            'durchschnitt_zeichen': sum(len(z) for z in self.zeilen) / len(self.zeilen) if self.zeilen else 0,\n            'level_counts': self.zaehle_level(),\n            'errors': len(self.finde_errors()),\n            'zeit_info': self.zeitanalyse()\n        }\n    \n    def report(self):\n        \"\"\"Erstellt einen ausfÃ¼hrlichen Report\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"ğŸ“Š LOG-ANALYSE: {self.dateiname}\")\n        print(\"=\" * 60)\n        \n        stats = self.statistiken()\n        \n        print(f\"\\nğŸ“„ Allgemein:\")\n        print(f\"   Zeilen: {stats['zeilen_gesamt']}\")\n        print(f\"   Zeichen: {stats['zeichen_gesamt']}\")\n        print(f\"   Ã˜ Zeichen/Zeile: {stats['durchschnitt_zeichen']:.1f}\")\n        \n        print(f\"\\nğŸ“Š Log-Levels:\")\n        for level, count in stats['level_counts'].most_common():\n            prozent = (count / stats['zeilen_gesamt']) * 100\n            print(f\"   {level}: {count}Ã— ({prozent:.1f}%)\")\n        \n        if stats['errors'] > 0:\n            print(f\"\\nâŒ Errors: {stats['errors']}\")\n            print(\"   Erste 3 Errors:\")\n            for nummer, zeile in self.finde_errors()[:3]:\n                print(f\"   Zeile {nummer}: {zeile[:60]}...\")\n        \n        if stats['zeit_info']:\n            zi = stats['zeit_info']\n            print(f\"\\nâ° Zeitraum:\")\n            print(f\"   Von: {zi['erste']}\")\n            print(f\"   Bis: {zi['letzte']}\")\n            print(f\"   Dauer: {zi['dauer']}\")\n\n# Testen\nanalyzer = LogAnalyzer(\"logfile.txt\")\nanalyzer.report()\n\n# Suche nach spezifischen Patterns\ndef suche_pattern(dateiname, pattern):\n    \"\"\"Sucht nach Regex-Pattern in Datei\"\"\"\n    treffer = []\n    \n    with open(dateiname, \"r\", encoding=\"utf-8\") as f:\n        for nummer, zeile in enumerate(f, start=1):\n            if re.search(pattern, zeile):\n                treffer.append((nummer, zeile.strip()))\n    \n    return treffer\n\nprint(\"\\n\\nğŸ” Pattern-Suche:\")\n# Suche nach Zeitangaben\nzeitangaben = suche_pattern(\"logfile.txt\", r'\\d{2}:\\d{2}:\\d{2}')\nprint(f\"Zeilen mit Zeitangaben: {len(zeitangaben)}\")\n\n# Suche nach IP-Adressen (falls vorhanden)\nips = suche_pattern(\"logfile.txt\", r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}')\nprint(f\"Zeilen mit IP-Adressen: {len(ips)}\")",
                                "checkpoint": " - Klasse fÃ¼r Logfile-Analyse erstellt - Mehrere Analyse-Methoden - Regex fÃ¼r Pattern-Matching - Zeitstempel-Analyse - Umfassender Report"
                        }
                ]
        },
        {
                "id": 5,
                "weekId": 2,
                "title": "Notiz-App (Dateien Schreiben)",
                "duration": "45-60 min",
                "task": {
                        "title": "Notiz-App (Dateien Schreiben)",
                        "description": "Erstelle eine Notiz-App die Notizen in Dateien speichert und verwaltet!",
                        "goals": [
                                "Schreib-Modi: `\"w\"` (write), `\"a\"` (append), `\"x\"` (exclusive)",
                                "Schreib-Methoden: `.write()`, `.writelines()`",
                                "Formatierung: Strukturierte Daten speichern",
                                "Dateiverwaltung: Erstellen, Lesen, LÃ¶schen",
                                "os-Modul: Verzeichnisse und Pfade",
                                "CRUD: Create, Read, Update, Delete Operationen",
                                "Persistenz: Daten Ã¼ber Programm-Ende hinaus speichern"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "In Dateien schreiben - Grundlagen",
                                "goal": "Verstehen wie man Daten in Dateien schreibt",
                                "why": "Daten persistent speichern ist essentiell - sonst sind sie nach Programmende weg!",
                                "instruction": "",
                                "code": "# SCHREIB-MODI:\n# \"w\" = write (schreiben) - ÃœBERSCHREIBT existierende Datei!\n# \"a\" = append (anhÃ¤ngen) - FÃ¼gt am Ende hinzu\n# \"x\" = exclusive create - Erstellt neue Datei, Fehler wenn existiert\n\n# Methode 1: write() - Schreibt einen String\nwith open(\"notiz.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Das ist meine erste Notiz.\\n\")\n    f.write(\"Und hier ist die zweite Zeile.\\n\")\n    # \\n am Ende fÃ¼r Zeilenumbruch!\n\nprint(\"âœ… notiz.txt erstellt!\")\n\n# Methode 2: writelines() - Schreibt eine Liste von Strings\nzeilen = [\n    \"Zeile 1\\n\",\n    \"Zeile 2\\n\",\n    \"Zeile 3\\n\"\n]\n\nwith open(\"liste.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.writelines(zeilen)\n\n# Methode 3: Append-Modus (a) - FÃ¼gt hinzu ohne zu Ã¼berschreiben\nwith open(\"notiz.txt\", \"a\", encoding=\"utf-8\") as f:\n    f.write(\"Diese Zeile wurde spÃ¤ter hinzugefÃ¼gt.\\n\")\n\n# Datei lesen um zu prÃ¼fen\nwith open(\"notiz.txt\", \"r\", encoding=\"utf-8\") as f:\n    print(\"Inhalt von notiz.txt:\")\n    print(f.read())\n\n# ACHTUNG: \"w\" ÃœBERSCHREIBT!\nwith open(\"notiz.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Der alte Inhalt ist weg!\\n\")\n\nwith open(\"notiz.txt\", \"r\", encoding=\"utf-8\") as f:\n    print(\"\\nNach Ãœberschreiben:\")\n    print(f.read())\n\n# Sicherer: PrÃ¼fen ob Datei existiert\nimport os\n\nif os.path.exists(\"wichtig.txt\"):\n    print(\"âš ï¸ Datei existiert bereits!\")\n    antwort = input(\"Ãœberschreiben? (j/n): \")\n    if antwort.lower() == \"j\":\n        with open(\"wichtig.txt\", \"w\", encoding=\"utf-8\") as f:\n            f.write(\"Neuer Inhalt\\n\")\nelse:\n    with open(\"wichtig.txt\", \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Erste Version\\n\")\n\n# x-Modus: Fehler wenn Datei existiert (extra sicher!)\ntry:\n    with open(\"neu.txt\", \"x\", encoding=\"utf-8\") as f:\n        f.write(\"Diese Datei ist garantiert neu!\\n\")\n    print(\"âœ… neu.txt erstellt\")\nexcept FileExistsError:\n    print(\"âŒ neu.txt existiert bereits!\")",
                                "checkpoint": " - `\"w\"` Ã¼berschreibt komplett - `\"a\"` fÃ¼gt am Ende hinzu - `\"x\"` erstellt nur neue Dateien - `\\n` fÃ¼r ZeilenumbrÃ¼che nicht vergessen!"
                        },
                        {
                                "number": 2,
                                "title": "Formatierte Daten schreiben",
                                "goal": "Strukturierte Daten in Dateien speichern",
                                "why": "Oft wollen wir Daten formatiert abspeichern (Listen, Dicts, etc.)",
                                "instruction": "",
                                "code": "from datetime import datetime\n\ndef schreibe_log_eintrag(nachricht, level=\"INFO\"):\n    \"\"\"Schreibt einen formatierten Log-Eintrag\"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    log_zeile = f\"[{timestamp}] {level}: {nachricht}\\n\"\n    \n    with open(\"app.log\", \"a\", encoding=\"utf-8\") as f:\n        f.write(log_zeile)\n\n# Testen\nschreibe_log_eintrag(\"Programm gestartet\")\nschreibe_log_eintrag(\"Verbindung fehlgeschlagen\", \"ERROR\")\nschreibe_log_eintrag(\"Neuversuch...\", \"WARNING\")\nschreibe_log_eintrag(\"Erfolgreich verbunden\")\n\n# Log anzeigen\nprint(\"ğŸ“‹ app.log:\")\nwith open(\"app.log\", \"r\", encoding=\"utf-8\") as f:\n    print(f.read())\n\n# Daten als CSV schreiben\ndef schreibe_personen_csv(personen, dateiname=\"personen.csv\"):\n    \"\"\"\n    Schreibt Personen-Daten als CSV\n    \n    personen: Liste von Dicts mit name, alter, stadt\n    \"\"\"\n    with open(dateiname, \"w\", encoding=\"utf-8\") as f:\n        # Header\n        f.write(\"Name,Alter,Stadt\\n\")\n        \n        # Daten\n        for person in personen:\n            zeile = f\"{person['name']},{person['alter']},{person['stadt']}\\n\"\n            f.write(zeile)\n\n# Test-Daten\npersonen_liste = [\n    {\"name\": \"Anna\", \"alter\": 28, \"stadt\": \"Berlin\"},\n    {\"name\": \"Ben\", \"alter\": 35, \"stadt\": \"MÃ¼nchen\"},\n    {\"name\": \"Clara\", \"alter\": 42, \"stadt\": \"Hamburg\"}\n]\n\nschreibe_personen_csv(personen_liste)\nprint(\"\\nâœ… personen.csv erstellt!\")\n\n# CSV wieder lesen zur Kontrolle\nwith open(\"personen.csv\", \"r\", encoding=\"utf-8\") as f:\n    print(f.read())\n\n# Tabellen-Format schreiben\ndef schreibe_tabelle(daten, spalten, dateiname=\"tabelle.txt\"):\n    \"\"\"\n    Schreibt Daten als formatierte Tabelle\n    \n    daten: Liste von Dicts\n    spalten: Liste von Spalten-Namen\n    \"\"\"\n    with open(dateiname, \"w\", encoding=\"utf-8\") as f:\n        # Spalten-Breiten berechnen\n        breiten = {}\n        for spalte in spalten:\n            max_breite = len(spalte)\n            for zeile in daten:\n                wert_laenge = len(str(zeile.get(spalte, \"\")))\n                max_breite = max(max_breite, wert_laenge)\n            breiten[spalte] = max_breite + 2  # +2 fÃ¼r Padding\n        \n        # Header\n        header = \" | \".join(spalte.ljust(breiten[spalte]) for spalte in spalten)\n        f.write(header + \"\\n\")\n        f.write(\"-\" * len(header) + \"\\n\")\n        \n        # Daten\n        for zeile in daten:\n            zeile_str = \" | \".join(\n                str(zeile.get(spalte, \"\")).ljust(breiten[spalte])\n                for spalte in spalten\n            )\n            f.write(zeile_str + \"\\n\")\n\n# Testen\nschreibe_tabelle(personen_liste, [\"name\", \"alter\", \"stadt\"], \"personen_tabelle.txt\")\nprint(\"\\nğŸ“Š personen_tabelle.txt:\")\nwith open(\"personen_tabelle.txt\", \"r\", encoding=\"utf-8\") as f:\n    print(f.read())",
                                "checkpoint": " - Zeitstempel in Logs - CSV-Format schreiben - Formatierte Tabellen erstellen - Daten strukturiert speichern"
                        },
                        {
                                "number": 3,
                                "title": "Notiz-App Kernfunktionen",
                                "goal": "CRUD-Operationen (Create, Read, Update, Delete) fÃ¼r Notizen",
                                "why": "Das sind die Basis-Operationen jeder Daten-App!",
                                "instruction": "",
                                "code": "import os\nfrom datetime import datetime\n\nclass NotizManager:\n    \"\"\"Verwaltet Notizen in Dateien\"\"\"\n    \n    def __init__(self, verzeichnis=\"notizen\"):\n        self.verzeichnis = verzeichnis\n        \n        # Verzeichnis erstellen falls nicht vorhanden\n        if not os.path.exists(verzeichnis):\n            os.makedirs(verzeichnis)\n            print(f\"âœ… Verzeichnis '{verzeichnis}' erstellt\")\n    \n    def erstelle_notiz(self, titel, inhalt):\n        \"\"\"Erstellt eine neue Notiz\"\"\"\n        # Dateiname aus Titel erstellen (sicher)\n        # Ersetze unsichere Zeichen\n        sicherer_titel = \"\".join(\n            c if c.isalnum() or c in (' ', '-', '_') else '_'\n            for c in titel\n        ).strip().replace(' ', '_')\n        \n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        dateiname = f\"{timestamp}_{sicherer_titel}.txt\"\n        dateipfad = os.path.join(self.verzeichnis, dateiname)\n        \n        with open(dateipfad, \"w\", encoding=\"utf-8\") as f:\n            f.write(f\"Titel: {titel}\\n\")\n            f.write(f\"Erstellt: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n            f.write(\"-\" * 50 + \"\\n\")\n            f.write(inhalt + \"\\n\")\n        \n        print(f\"âœ… Notiz '{titel}' gespeichert als {dateiname}\")\n        return dateipfad\n    \n    def liste_notizen(self):\n        \"\"\"Listet alle Notizen auf\"\"\"\n        dateien = [f for f in os.listdir(self.verzeichnis) if f.endswith('.txt')]\n        \n        if not dateien:\n            print(\"ğŸ“­ Keine Notizen vorhanden\")\n            return []\n        \n        notizen = []\n        for datei in sorted(dateien):\n            pfad = os.path.join(self.verzeichnis, datei)\n            with open(pfad, \"r\", encoding=\"utf-8\") as f:\n                erste_zeile = f.readline()\n                # Titel extrahieren\n                if erste_zeile.startswith(\"Titel: \"):\n                    titel = erste_zeile[7:].strip()\n                else:\n                    titel = datei\n                \n                notizen.append({\n                    'datei': datei,\n                    'pfad': pfad,\n                    'titel': titel\n                })\n        \n        return notizen\n    \n    def lese_notiz(self, dateiname):\n        \"\"\"Liest eine Notiz\"\"\"\n        pfad = os.path.join(self.verzeichnis, dateiname)\n        \n        try:\n            with open(pfad, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except FileNotFoundError:\n            print(f\"âŒ Notiz '{dateiname}' nicht gefunden!\")\n            return None\n    \n    def loesche_notiz(self, dateiname):\n        \"\"\"LÃ¶scht eine Notiz\"\"\"\n        pfad = os.path.join(self.verzeichnis, dateiname)\n        \n        try:\n            os.remove(pfad)\n            print(f\"ğŸ—‘ï¸ Notiz '{dateiname}' gelÃ¶scht\")\n            return True\n        except FileNotFoundError:\n            print(f\"âŒ Notiz '{dateiname}' nicht gefunden!\")\n            return False\n    \n    def suche_in_notizen(self, suchbegriff):\n        \"\"\"Sucht in allen Notizen\"\"\"\n        ergebnisse = []\n        \n        for notiz_info in self.liste_notizen():\n            inhalt = self.lese_notiz(notiz_info['datei'])\n            if inhalt and suchbegriff.lower() in inhalt.lower():\n                ergebnisse.append(notiz_info)\n        \n        return ergebnisse\n\n# Testen\nprint(\"ğŸ“ NOTIZ-MANAGER TEST\")\nprint(\"=\" * 60)\n\nmanager = NotizManager()\n\n# Notizen erstellen\nmanager.erstelle_notiz(\n    \"Einkaufsliste\",\n    \"- Milch\\n- Brot\\n- Eier\\n- KÃ¤se\"\n)\n\nmanager.erstelle_notiz(\n    \"Meeting Notizen\",\n    \"Teilnehmer: Anna, Ben, Clara\\nThema: Projekt-Update\\nNÃ¤chste Schritte: ...\"\n)\n\nmanager.erstelle_notiz(\n    \"Python Lernen\",\n    \"Heute gelernt:\\n- Dateien schreiben\\n- Notiz-App erstellen\"\n)\n\n# Alle Notizen auflisten\nprint(\"\\nğŸ“š Alle Notizen:\")\nfor i, notiz in enumerate(manager.liste_notizen(), 1):\n    print(f\"{i}. {notiz['titel']}\")\n\n# Notiz lesen\nprint(\"\\nğŸ“– Lese 'Einkaufsliste':\")\nnotizen = manager.liste_notizen()\nif notizen:\n    inhalt = manager.lese_notiz(notizen[0]['datei'])\n    print(inhalt)\n\n# Suchen\nprint(\"\\nğŸ” Suche nach 'Python':\")\nergebnisse = manager.suche_in_notizen(\"Python\")\nfor notiz in ergebnisse:\n    print(f\"  Gefunden in: {notiz['titel']}\")",
                                "checkpoint": " - Notizen werden als separate Dateien gespeichert - Dateinamen sind sicher (keine Sonderzeichen) - Timestamp fÃ¼r Sortierung - Such-Funktion durchsucht alle Notizen"
                        },
                        {
                                "number": 4,
                                "title": "Interaktive Notiz-App",
                                "goal": "VollstÃ¤ndige CLI-App mit Menu",
                                "why": "Kombiniert alles Gelernte zu einer nutzbaren Anwendung!",
                                "instruction": "",
                                "code": "def zeige_menu():\n    \"\"\"Zeigt das HauptmenÃ¼\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"ğŸ“ NOTIZ-APP\")\n    print(\"=\" * 60)\n    print(\"1. Neue Notiz erstellen\")\n    print(\"2. Alle Notizen anzeigen\")\n    print(\"3. Notiz lesen\")\n    print(\"4. Notiz lÃ¶schen\")\n    print(\"5. In Notizen suchen\")\n    print(\"6. Notiz bearbeiten\")\n    print(\"7. Statistiken\")\n    print(\"8. Beenden\")\n    print(\"=\" * 60)\n\ndef erstelle_notiz_interaktiv(manager):\n    \"\"\"Interaktive Notiz-Erstellung\"\"\"\n    print(\"\\nâ• NEUE NOTIZ\")\n    print(\"-\" * 40)\n    \n    titel = input(\"Titel: \").strip()\n    if not titel:\n        print(\"âŒ Titel darf nicht leer sein!\")\n        return\n    \n    print(\"Inhalt (Leerzeile + Enter zum Beenden):\")\n    zeilen = []\n    while True:\n        zeile = input()\n        if zeile == \"\":\n            break\n        zeilen.append(zeile)\n    \n    inhalt = \"\\n\".join(zeilen)\n    \n    if inhalt:\n        manager.erstelle_notiz(titel, inhalt)\n    else:\n        print(\"âŒ Notiz ohne Inhalt nicht gespeichert\")\n\ndef zeige_notizen(manager):\n    \"\"\"Zeigt alle Notizen mit Nummern\"\"\"\n    notizen = manager.liste_notizen()\n    \n    if not notizen:\n        return []\n    \n    print(\"\\nğŸ“š ALLE NOTIZEN:\")\n    print(\"-\" * 60)\n    for i, notiz in enumerate(notizen, 1):\n        print(f\"{i}. {notiz['titel']}\")\n    \n    return notizen\n\ndef lese_notiz_interaktiv(manager):\n    \"\"\"Liest eine ausgewÃ¤hlte Notiz\"\"\"\n    notizen = zeige_notizen(manager)\n    \n    if not notizen:\n        return\n    \n    try:\n        auswahl = int(input(\"\\nNotiz-Nummer: \"))\n        if 1 <= auswahl <= len(notizen):\n            notiz = notizen[auswahl - 1]\n            print(\"\\n\" + \"=\" * 60)\n            print(f\"ğŸ“– {notiz['titel']}\")\n            print(\"=\" * 60)\n            inhalt = manager.lese_notiz(notiz['datei'])\n            print(inhalt)\n        else:\n            print(\"âŒ UngÃ¼ltige Nummer!\")\n    except ValueError:\n        print(\"âŒ Bitte eine Zahl eingeben!\")\n\ndef loesche_notiz_interaktiv(manager):\n    \"\"\"LÃ¶scht eine ausgewÃ¤hlte Notiz\"\"\"\n    notizen = zeige_notizen(manager)\n    \n    if not notizen:\n        return\n    \n    try:\n        auswahl = int(input(\"\\nZu lÃ¶schende Notiz-Nummer: \"))\n        if 1 <= auswahl <= len(notizen):\n            notiz = notizen[auswahl - 1]\n            \n            bestaetigung = input(f\"'{notiz['titel']}' wirklich lÃ¶schen? (j/n): \")\n            if bestaetigung.lower() == 'j':\n                manager.loesche_notiz(notiz['datei'])\n        else:\n            print(\"âŒ UngÃ¼ltige Nummer!\")\n    except ValueError:\n        print(\"âŒ Bitte eine Zahl eingeben!\")\n\ndef suche_interaktiv(manager):\n    \"\"\"Sucht in Notizen\"\"\"\n    begriff = input(\"\\nğŸ” Suchbegriff: \").strip()\n    \n    if not begriff:\n        print(\"âŒ Suchbegriff darf nicht leer sein!\")\n        return\n    \n    ergebnisse = manager.suche_in_notizen(begriff)\n    \n    if ergebnisse:\n        print(f\"\\nâœ… {len(ergebnisse)} Ergebnis(se) gefunden:\")\n        for notiz in ergebnisse:\n            print(f\"  ğŸ“„ {notiz['titel']}\")\n    else:\n        print(\"âŒ Keine Ergebnisse gefunden\")\n\ndef bearbeite_notiz(manager):\n    \"\"\"Bearbeitet eine existierende Notiz\"\"\"\n    notizen = zeige_notizen(manager)\n    \n    if not notizen:\n        return\n    \n    try:\n        auswahl = int(input(\"\\nZu bearbeitende Notiz-Nummer: \"))\n        if 1 <= auswahl <= len(notizen):\n            notiz = notizen[auswahl - 1]\n            \n            # Aktuellen Inhalt zeigen\n            print(\"\\n\" + \"=\" * 60)\n            print(\"AKTUELLER INHALT:\")\n            print(\"=\" * 60)\n            alter_inhalt = manager.lese_notiz(notiz['datei'])\n            print(alter_inhalt)\n            \n            # Neuen Inhalt eingeben\n            print(\"\\n\" + \"=\" * 60)\n            print(\"NEUER INHALT (Leerzeile + Enter zum Beenden):\")\n            zeilen = []\n            while True:\n                zeile = input()\n                if zeile == \"\":\n                    break\n                zeilen.append(zeile)\n            \n            neuer_inhalt = \"\\n\".join(zeilen)\n            \n            if neuer_inhalt:\n                # Ãœberschreiben\n                pfad = notiz['pfad']\n                with open(pfad, \"w\", encoding=\"utf-8\") as f:\n                    f.write(f\"Titel: {notiz['titel']}\\n\")\n                    f.write(f\"Bearbeitet: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n                    f.write(\"-\" * 50 + \"\\n\")\n                    f.write(neuer_inhalt + \"\\n\")\n                \n                print(\"âœ… Notiz aktualisiert!\")\n            else:\n                print(\"âŒ Kein neuer Inhalt - Notiz nicht geÃ¤ndert\")\n        else:\n            print(\"âŒ UngÃ¼ltige Nummer!\")\n    except ValueError:\n        print(\"âŒ Bitte eine Zahl eingeben!\")\n\ndef zeige_statistiken(manager):\n    \"\"\"Zeigt Statistiken Ã¼ber alle Notizen\"\"\"\n    notizen = manager.liste_notizen()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"ğŸ“Š STATISTIKEN\")\n    print(\"=\" * 60)\n    \n    if not notizen:\n        print(\"Keine Notizen vorhanden\")\n        return\n    \n    # Anzahl\n    print(f\"Gesamt Notizen: {len(notizen)}\")\n    \n    # GesamtgrÃ¶ÃŸe\n    gesamt_zeichen = 0\n    gesamt_zeilen = 0\n    \n    for notiz in notizen:\n        inhalt = manager.lese_notiz(notiz['datei'])\n        if inhalt:\n            gesamt_zeichen += len(inhalt)\n            gesamt_zeilen += len(inhalt.splitlines())\n    \n    print(f\"Gesamt Zeichen: {gesamt_zeichen}\")\n    print(f\"Gesamt Zeilen: {gesamt_zeilen}\")\n    print(f\"Durchschnitt Zeichen/Notiz: {gesamt_zeichen // len(notizen)}\")\n    print(f\"Durchschnitt Zeilen/Notiz: {gesamt_zeilen // len(notizen)}\")\n\n# HAUPTPROGRAMM\ndef main():\n    manager = NotizManager()\n    \n    while True:\n        zeige_menu()\n        wahl = input(\"\\nWÃ¤hle eine Option (1-8): \").strip()\n        \n        if wahl == \"1\":\n            erstelle_notiz_interaktiv(manager)\n        \n        elif wahl == \"2\":\n            zeige_notizen(manager)\n            input(\"\\nDrÃ¼cke Enter zum Fortfahren...\")\n        \n        elif wahl == \"3\":\n            lese_notiz_interaktiv(manager)\n            input(\"\\nDrÃ¼cke Enter zum Fortfahren...\")\n        \n        elif wahl == \"4\":\n            loesche_notiz_interaktiv(manager)\n        \n        elif wahl == \"5\":\n            suche_interaktiv(manager)\n            input(\"\\nDrÃ¼cke Enter zum Fortfahren...\")\n        \n        elif wahl == \"6\":\n            bearbeite_notiz(manager)\n        \n        elif wahl == \"7\":\n            zeige_statistiken(manager)\n            input(\"\\nDrÃ¼cke Enter zum Fortfahren...\")\n        \n        elif wahl == \"8\":\n            print(\"\\nğŸ‘‹ Auf Wiedersehen!\")\n            break\n        \n        else:\n            print(\"âŒ UngÃ¼ltige Wahl! Bitte 1-8 wÃ¤hlen.\")\n\nif __name__ == \"__main__\":\n    main()",
                                "checkpoint": " - VollstÃ¤ndige CRUD-App (Create, Read, Update, Delete) - Menu-gesteuert - Fehlerbehandlung - Such- und Statistik-Funktionen - Benutzerfreundlich"
                        }
                ]
        },
        {
                "id": 6,
                "weekId": 2,
                "title": "Robuster Datei-Reader (Error Handling)",
                "duration": "45-60 min",
                "task": {
                        "title": "Robuster Datei-Reader (Error Handling)",
                        "description": "Lerne professionelles Error Handling - damit deine Programme nicht abstÃ¼rzen!",
                        "goals": [
                                "try-except: Fehler abfangen",
                                "except-Typen: Spezifische vs. generische Exceptions",
                                "else: LÃ¤uft nur bei Erfolg",
                                "finally: LÃ¤uft immer (Cleanup)",
                                "raise: Eigene Exceptions werfen",
                                "Custom Exceptions: Eigene Exception-Klassen",
                                "Exception-Hierarchie: Vererbung von Exceptions",
                                "Best Practices: Spezifisch fangen, informative Meldungen"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Try-Except Basics",
                                "goal": "Fehler abfangen statt abstÃ¼rzen",
                                "why": "Fehler passieren! Datei nicht gefunden, ungÃ¼ltige Eingabe, Netzwerk-Timeout... Gute Programme crashen nicht, sondern reagieren elegant.",
                                "instruction": "",
                                "code": "# OHNE ERROR HANDLING - Programm stÃ¼rzt ab!\nprint(\"Beispiel OHNE Error Handling:\")\ntry:\n    # Das wÃ¼rde das Programm crashen lassen:\n    # zahl = int(\"abc\")  # ValueError!\n    # datei = open(\"existiert_nicht.txt\")  # FileNotFoundError!\n    pass\nexcept:\n    pass\n\n# MIT TRY-EXCEPT - Programm lÃ¤uft weiter\nprint(\"\\nâœ… Beispiel MIT Error Handling:\")\n\ntry:\n    zahl = int(\"abc\")  # Wird Fehler verursachen\n    print(\"Das wird nie ausgefÃ¼hrt\")\nexcept:\n    print(\"âŒ Fehler beim Konvertieren!\")\n    print(\"Aber das Programm lÃ¤uft weiter!\")\n\nprint(\"Programm lÃ¤uft normal weiter...\\n\")\n\n# SPEZIFISCHE EXCEPTIONS - Besser!\n# Verschiedene Fehler unterschiedlich behandeln\n\ndef sichere_division(a, b):\n    \"\"\"Division mit Error Handling\"\"\"\n    try:\n        ergebnis = a / b\n        return ergebnis\n    except ZeroDivisionError:\n        print(\"âŒ Division durch 0 ist nicht erlaubt!\")\n        return None\n    except TypeError:\n        print(\"âŒ Nur Zahlen erlaubt!\")\n        return None\n\n# Testen\nprint(\"Division-Tests:\")\nprint(f\"10 / 2 = {sichere_division(10, 2)}\")\nprint(f\"10 / 0 = {sichere_division(10, 0)}\")\nprint(f\"10 / 'x' = {sichere_division(10, 'x')}\")\n\n# MEHRERE EXCEPTIONS GLEICHZEITIG\ndef lese_zahl_aus_datei(dateiname, zeile=0):\n    \"\"\"Liest eine Zahl aus einer Datei\"\"\"\n    try:\n        with open(dateiname, \"r\") as f:\n            zeilen = f.readlines()\n            zahl_str = zeilen[zeile].strip()\n            zahl = int(zahl_str)\n            return zahl\n    \n    except FileNotFoundError:\n        print(f\"âŒ Datei '{dateiname}' nicht gefunden!\")\n        return None\n    \n    except IndexError:\n        print(f\"âŒ Zeile {zeile} existiert nicht!\")\n        return None\n    \n    except ValueError:\n        print(f\"âŒ Keine gÃ¼ltige Zahl in Zeile {zeile}!\")\n        return None\n    \n    except Exception as e:  # FÃ¤ngt ALLE anderen Fehler\n        print(f\"âŒ Unerwarteter Fehler: {e}\")\n        return None\n\n# Test-Datei erstellen\nwith open(\"zahlen.txt\", \"w\") as f:\n    f.write(\"42\\n\")\n    f.write(\"123\\n\")\n    f.write(\"kein Zahl\\n\")\n\n# Testen\nprint(\"\\nDatei-Lese-Tests:\")\nprint(f\"Zeile 0: {lese_zahl_aus_datei('zahlen.txt', 0)}\")  # OK\nprint(f\"Zeile 2: {lese_zahl_aus_datei('zahlen.txt', 2)}\")  # ValueError\nprint(f\"Zeile 10: {lese_zahl_aus_datei('zahlen.txt', 10)}\")  # IndexError\nprint(f\"Falsche Datei: {lese_zahl_aus_datei('gibts_nicht.txt', 0)}\")  # FileNotFoundError\n\n# EXCEPTION-INFO SPEICHERN mit 'as'\ntry:\n    x = 10 / 0\nexcept ZeroDivisionError as fehler:\n    print(f\"\\nâŒ Fehler aufgetreten: {fehler}\")\n    print(f\"Fehlertyp: {type(fehler).__name__}\")",
                                "checkpoint": " - try-except fÃ¤ngt Fehler ab - Spezifische Exceptions fÃ¼r unterschiedliche Behandlung - `Exception as e` speichert Fehler-Info - Programm lÃ¤uft nach Fehler weiter"
                        },
                        {
                                "number": 2,
                                "title": "Else und Finally",
                                "goal": "Komplettes Try-Except-Else-Finally verstehen",
                                "why": "",
                                "instruction": "",
                                "code": "# KOMPLETTE STRUKTUR: try-except-else-finally\n\ndef verarbeite_datei(dateiname):\n    \"\"\"Zeigt alle 4 BlÃ¶cke\"\"\"\n    print(f\"\\nğŸ”§ Verarbeite '{dateiname}':\")\n    \n    try:\n        print(\"  1. TRY: Ã–ffne Datei...\")\n        with open(dateiname, \"r\") as f:\n            inhalt = f.read()\n        \n        print(\"  2. TRY: Datei erfolgreich gelesen!\")\n        \n        # Simulation: Verarbeitung kÃ¶nnte fehlschlagen\n        if len(inhalt) == 0:\n            raise ValueError(\"Datei ist leer!\")\n    \n    except FileNotFoundError:\n        print(\"  âŒ EXCEPT: Datei nicht gefunden!\")\n        return None\n    \n    except ValueError as e:\n        print(f\"  âŒ EXCEPT: {e}\")\n        return None\n    \n    else:\n        # LÃ¤uft nur wenn KEIN Exception in try!\n        print(\"  âœ… ELSE: Keine Fehler - verarbeite weiter...\")\n        zeilen_anzahl = len(inhalt.splitlines())\n        print(f\"  âœ… ELSE: {zeilen_anzahl} Zeilen gefunden\")\n        return inhalt\n    \n    finally:\n        # LÃ¤uft IMMER - egal ob Fehler oder nicht!\n        print(\"  ğŸ FINALLY: AufrÃ¤umen (lÃ¤uft immer!)\")\n\n# Test-Dateien\nwith open(\"vorhanden.txt\", \"w\") as f:\n    f.write(\"Zeile 1\\nZeile 2\\nZeile 3\\n\")\n\nwith open(\"leer.txt\", \"w\") as f:\n    pass  # Leere Datei\n\n# Tests\nverarbeite_datei(\"vorhanden.txt\")  # Erfolg â†’ else lÃ¤uft\nverarbeite_datei(\"leer.txt\")  # ValueError â†’ except lÃ¤uft  \nverarbeite_datei(\"gibts_nicht.txt\")  # FileNotFoundError â†’ except lÃ¤uft\n\n# PRAKTISCHES BEISPIEL: Datenbank-Ã¤hnlich\nclass DatenVerbindung:\n    \"\"\"Simuliert eine Datenbank-Verbindung\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.verbunden = False\n    \n    def verbinde(self):\n        print(f\"  ğŸ”Œ Verbinde mit '{self.name}'...\")\n        self.verbunden = True\n    \n    def trenne(self):\n        if self.verbunden:\n            print(f\"  ğŸ”Œ Trenne Verbindung zu '{self.name}'...\")\n            self.verbunden = False\n\ndef daten_abfragen(db_name, abfrage):\n    \"\"\"Fragt Daten ab - mit garantiertem Cleanup\"\"\"\n    db = DatenVerbindung(db_name)\n    \n    try:\n        db.verbinde()\n        \n        # Simulation: Abfrage kÃ¶nnte fehlschlagen\n        if \"fehler\" in abfrage.lower():\n            raise ValueError(\"UngÃ¼ltige Abfrage!\")\n        \n        print(f\"  âœ… Abfrage erfolgreich: '{abfrage}'\")\n        return f\"Ergebnis von '{abfrage}'\"\n    \n    except ValueError as e:\n        print(f\"  âŒ Abfrage-Fehler: {e}\")\n        return None\n    \n    finally:\n        # WICHTIG: Verbindung IMMER trennen!\n        db.trenne()\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"DATENBANK-BEISPIEL:\")\nprint(\"=\" * 60)\n\ndaten_abfragen(\"MeineDB\", \"SELECT * FROM users\")\ndaten_abfragen(\"MeineDB\", \"FEHLER-Abfrage\")  # Verursacht Fehler, aber trennt trotzdem!",
                                "checkpoint": " - **try:** Code der fehlschlagen kÃ¶nnte - **except:** Was bei Fehler passiert - **else:** LÃ¤uft nur bei Erfolg - **finally:** LÃ¤uft IMMER (wichtig fÃ¼r Cleanup!)"
                        },
                        {
                                "number": 3,
                                "title": "Eigene Exceptions",
                                "goal": "Custom Exceptions fÃ¼r spezielle FÃ¤lle",
                                "why": "Manchmal brauchen wir eigene Fehler-Typen fÃ¼r unsere App-Logik",
                                "instruction": "",
                                "code": "# EIGENE EXCEPTION-KLASSE\nclass AlterZuNiedrigError(Exception):\n    \"\"\"Fehler wenn Alter unter Minimum\"\"\"\n    pass\n\nclass AlterZuHochError(Exception):\n    \"\"\"Fehler wenn Alter Ã¼ber Maximum\"\"\"\n    pass\n\nclass UngueltigerNameError(Exception):\n    \"\"\"Fehler bei ungÃ¼ltigem Namen\"\"\"\n    pass\n\ndef registriere_benutzer(name, alter):\n    \"\"\"\n    Registriert Benutzer mit Validierung\n    \n    Raises:\n        UngueltigerNameError: Name zu kurz oder leer\n        AlterZuNiedrigError: Unter 13 Jahre\n        AlterZuHochError: Ãœber 120 Jahre\n    \"\"\"\n    # Name validieren\n    if not name or len(name) < 2:\n        raise UngueltigerNameError(\"Name muss mindestens 2 Zeichen haben!\")\n    \n    # Alter validieren\n    if alter < 13:\n        raise AlterZuNiedrigError(f\"Mindestalter ist 13 (angegeben: {alter})\")\n    \n    if alter > 120:\n        raise AlterZuHochError(f\"Maximalalter ist 120 (angegeben: {alter})\")\n    \n    # Alles OK\n    print(f\"âœ… Benutzer '{name}' ({alter}) registriert!\")\n    return {\"name\": name, \"alter\": alter}\n\n# Testen mit verschiedenen FÃ¤llen\ntest_faelle = [\n    (\"Anna\", 25),      # OK\n    (\"\", 30),          # UngueltigerNameError\n    (\"Ben\", 10),       # AlterZuNiedrigError\n    (\"Clara\", 150),    # AlterZuHochError\n    (\"Max\", 50),       # OK\n]\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"BENUTZER-REGISTRIERUNG:\")\nprint(\"=\" * 60)\n\nfor name, alter in test_faelle:\n    try:\n        registriere_benutzer(name, alter)\n    \n    except UngueltigerNameError as e:\n        print(f\"âŒ UngÃ¼ltiger Name: {e}\")\n    \n    except AlterZuNiedrigError as e:\n        print(f\"âŒ Zu jung: {e}\")\n    \n    except AlterZuHochError as e:\n        print(f\"âŒ Zu alt: {e}\")\n    \n    print()\n\n# EXCEPTION MIT ZUSÃ„TZLICHEN DATEN\nclass DateiZuGroÃŸError(Exception):\n    \"\"\"Fehler wenn Datei GrÃ¶ÃŸenlimit Ã¼berschreitet\"\"\"\n    \n    def __init__(self, dateiname, grÃ¶ÃŸe, limit):\n        self.dateiname = dateiname\n        self.grÃ¶ÃŸe = grÃ¶ÃŸe\n        self.limit = limit\n        \n        message = f\"Datei '{dateiname}' ({grÃ¶ÃŸe} MB) Ã¼berschreitet Limit von {limit} MB\"\n        super().__init__(message)\n\ndef lade_datei(dateiname, grÃ¶ÃŸe_mb, limit_mb=10):\n    \"\"\"LÃ¤dt Datei mit GrÃ¶ÃŸen-Check\"\"\"\n    if grÃ¶ÃŸe_mb > limit_mb:\n        raise DateiZuGroÃŸError(dateiname, grÃ¶ÃŸe_mb, limit_mb)\n    \n    print(f\"âœ… Datei '{dateiname}' ({grÃ¶ÃŸe_mb} MB) geladen\")\n\n# Testen\ntry:\n    lade_datei(\"klein.jpg\", 5)  # OK\n    lade_datei(\"groÃŸ.mp4\", 50)  # Fehler!\nexcept DateiZuGroÃŸError as e:\n    print(f\"âŒ {e}\")\n    print(f\"   Details: Datei={e.dateiname}, GrÃ¶ÃŸe={e.grÃ¶ÃŸe}, Limit={e.limit}\")",
                                "checkpoint": " - Eigene Exception-Klassen mit `class MyError(Exception)` - `raise` wirft Exceptions - Custom Exceptions kÃ¶nnen zusÃ¤tzliche Daten speichern - Macht Code selbstdokumentierend"
                        },
                        {
                                "number": 4,
                                "title": "Robuster Datei-Reader",
                                "goal": "Alle Error-Handling-Techniken in einer App kombinieren",
                                "why": "Real-World Beispiel mit umfassendem Error Handling",
                                "instruction": "",
                                "code": "import os\nfrom typing import Optional, List, Dict\n\nclass DateiLeseError(Exception):\n    \"\"\"Basis-Fehler fÃ¼r Datei-Lese-Probleme\"\"\"\n    pass\n\nclass DateiZuGroÃŸError(DateiLeseError):\n    \"\"\"Datei Ã¼berschreitet GrÃ¶ÃŸenlimit\"\"\"\n    pass\n\nclass UngueltigesFormatError(DateiLeseError):\n    \"\"\"Datei hat falsches Format\"\"\"\n    pass\n\nclass RobusterDateiReader:\n    \"\"\"Datei-Reader mit umfassendem Error Handling\"\"\"\n    \n    def __init__(self, max_grÃ¶ÃŸe_mb=10):\n        self.max_grÃ¶ÃŸe_mb = max_grÃ¶ÃŸe_mb\n        self.max_grÃ¶ÃŸe_bytes = max_grÃ¶ÃŸe_mb * 1024 * 1024\n    \n    def lese_datei(self, dateipfad: str, encoding='utf-8') -> Optional[str]:\n        \"\"\"\n        Liest Datei mit vollstÃ¤ndigem Error Handling\n        \n        Returns:\n            Datei-Inhalt oder None bei Fehler\n        \n        Raises:\n            Verschiedene DateiLeseError Varianten\n        \"\"\"\n        # 1. Existenz prÃ¼fen\n        if not os.path.exists(dateipfad):\n            raise FileNotFoundError(f\"Datei '{dateipfad}' existiert nicht!\")\n        \n        # 2. PrÃ¼fen ob es eine Datei ist (nicht Verzeichnis)\n        if not os.path.isfile(dateipfad):\n            raise IsADirectoryError(f\"'{dateipfad}' ist ein Verzeichnis, keine Datei!\")\n        \n        # 3. GrÃ¶ÃŸe prÃ¼fen\n        grÃ¶ÃŸe = os.path.getsize(dateipfad)\n        if grÃ¶ÃŸe > self.max_grÃ¶ÃŸe_bytes:\n            raise DateiZuGroÃŸError(\n                f\"Datei ist {grÃ¶ÃŸe / 1024 / 1024:.1f} MB, \"\n                f\"Maximum ist {self.max_grÃ¶ÃŸe_mb} MB\"\n            )\n        \n        # 4. Lesbar prÃ¼fen\n        if not os.access(dateipfad, os.R_OK):\n            raise PermissionError(f\"Keine Leseberechtigung fÃ¼r '{dateipfad}'!\")\n        \n        # 5. Lesen mit Error Handling\n        try:\n            with open(dateipfad, 'r', encoding=encoding) as f:\n                inhalt = f.read()\n            \n            return inhalt\n        \n        except UnicodeDecodeError as e:\n            raise UngueltigesFormatError(\n                f\"Datei kann nicht mit {encoding} gelesen werden. \"\n                f\"Versuche anderes Encoding?\"\n            )\n        \n        except Exception as e:\n            raise DateiLeseError(f\"Unerwarteter Fehler beim Lesen: {e}\")\n    \n    def lese_zeilen(self, dateipfad: str, max_zeilen: Optional[int] = None) -> List[str]:\n        \"\"\"Liest Datei zeilenweise\"\"\"\n        try:\n            inhalt = self.lese_datei(dateipfad)\n            zeilen = inhalt.splitlines()\n            \n            if max_zeilen:\n                zeilen = zeilen[:max_zeilen]\n            \n            return zeilen\n        \n        except DateiLeseError:\n            # Fehler weitergeben\n            raise\n        except Exception as e:\n            raise DateiLeseError(f\"Fehler beim Zeilen-Lesen: {e}\")\n    \n    def lese_json(self, dateipfad: str) -> Dict:\n        \"\"\"Liest JSON-Datei\"\"\"\n        import json\n        \n        try:\n            inhalt = self.lese_datei(dateipfad)\n            daten = json.loads(inhalt)\n            return daten\n        \n        except json.JSONDecodeError as e:\n            raise UngueltigesFormatError(f\"UngÃ¼ltiges JSON-Format: {e}\")\n        \n        except DateiLeseError:\n            raise\n    \n    def sichere_lesen_mit_fallback(\n        self,\n        dateipfad: str,\n        fallback_pfad: Optional[str] = None\n    ) -> str:\n        \"\"\"\n        Versucht Datei zu lesen, nutzt Fallback bei Fehler\n        \n        Returns:\n            Inhalt oder leerer String\n        \"\"\"\n        try:\n            return self.lese_datei(dateipfad)\n        \n        except FileNotFoundError:\n            if fallback_pfad:\n                print(f\"âš ï¸ Nutze Fallback: '{fallback_pfad}'\")\n                try:\n                    return self.lese_datei(fallback_pfad)\n                except Exception as e:\n                    print(f\"âŒ Fallback fehlgeschlagen: {e}\")\n            \n            return \"\"\n        \n        except Exception as e:\n            print(f\"âŒ Fehler: {e}\")\n            return \"\"\n\n# TESTEN\nprint(\"=\" * 60)\nprint(\"ğŸ”§ ROBUSTER DATEI-READER TEST\")\nprint(\"=\" * 60)\n\nreader = RobusterDateiReader(max_grÃ¶ÃŸe_mb=1)  # 1 MB Limit\n\n# Test-Dateien erstellen\nwith open(\"klein.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Das ist eine kleine Test-Datei.\\n\" * 10)\n\nwith open(\"groÃŸ.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"X\" * 2 * 1024 * 1024)  # 2 MB\n\nwith open(\"daten.json\", \"w\", encoding=\"utf-8\") as f:\n    f.write('{\"name\": \"Test\", \"wert\": 123}')\n\nwith open(\"kaputt.json\", \"w\", encoding=\"utf-8\") as f:\n    f.write('{name: kaputt}')  # UngÃ¼ltiges JSON\n\n# Test 1: Normales Lesen\nprint(\"\\n1ï¸âƒ£ Test: Normale Datei lesen\")\ntry:\n    inhalt = reader.lese_datei(\"klein.txt\")\n    print(f\"âœ… Gelesen: {len(inhalt)} Zeichen\")\nexcept Exception as e:\n    print(f\"âŒ {type(e).__name__}: {e}\")\n\n# Test 2: Datei zu groÃŸ\nprint(\"\\n2ï¸âƒ£ Test: Zu groÃŸe Datei\")\ntry:\n    inhalt = reader.lese_datei(\"groÃŸ.txt\")\nexcept DateiZuGroÃŸError as e:\n    print(f\"âŒ {type(e).__name__}: {e}\")\n\n# Test 3: Datei existiert nicht\nprint(\"\\n3ï¸âƒ£ Test: Nicht-existierende Datei\")\ntry:\n    inhalt = reader.lese_datei(\"gibts_nicht.txt\")\nexcept FileNotFoundError as e:\n    print(f\"âŒ {type(e).__name__}: {e}\")\n\n# Test 4: JSON lesen (OK)\nprint(\"\\n4ï¸âƒ£ Test: JSON lesen (gÃ¼ltig)\")\ntry:\n    daten = reader.lese_json(\"daten.json\")\n    print(f\"âœ… JSON geladen: {daten}\")\nexcept Exception as e:\n    print(f\"âŒ {type(e).__name__}: {e}\")\n\n# Test 5: JSON lesen (kaputt)\nprint(\"\\n5ï¸âƒ£ Test: JSON lesen (ungÃ¼ltig)\")\ntry:\n    daten = reader.lese_json(\"kaputt.json\")\nexcept UngueltigesFormatError as e:\n    print(f\"âŒ {type(e).__name__}: {e}\")\n\n# Test 6: Fallback\nprint(\"\\n6ï¸âƒ£ Test: Lesen mit Fallback\")\ninhalt = reader.sichere_lesen_mit_fallback(\n    \"nicht_da.txt\",\n    fallback_pfad=\"klein.txt\"\n)\nprint(f\"Resultat: {len(inhalt)} Zeichen geladen\")\n\n# Test 7: Zeilen lesen mit Limit\nprint(\"\\n7ï¸âƒ£ Test: Erste 5 Zeilen\")\ntry:\n    zeilen = reader.lese_zeilen(\"klein.txt\", max_zeilen=5)\n    print(f\"âœ… {len(zeilen)} Zeilen gelesen\")\n    for i, zeile in enumerate(zeilen, 1):\n        print(f\"   {i}. {zeile[:40]}...\")\nexcept Exception as e:\n    print(f\"âŒ {type(e).__name__}: {e}\")",
                                "checkpoint": " - Mehrschichtiges Error Handling - Custom Exception-Hierarchie - Validierung vor Datei-Operationen - Fallback-Mechanismen - Detaillierte Fehler-Informationen"
                        }
                ]
        },
        {
                "id": 7,
                "weekId": 2,
                "title": "Eigenes Tool-Modul (Module & Imports)",
                "duration": "45-60 min",
                "task": {
                        "title": "Eigenes Tool-Modul (Module & Imports)",
                        "description": "Lerne wie man eigene Module erstellt und Code organisiert!",
                        "goals": [
                                "Module: Jedes `.py` File ist ein Modul",
                                "Imports: `import`, `from...import`, `as`",
                                "Packages: Ordner mit `__init__.py`",
                                "`__name__`: Unterschied direkter Start vs. Import",
                                "`__all__`: Kontrolle Ã¼ber `import *`",
                                "Docstrings: Dokumentation fÃ¼r Module/Funktionen",
                                "Organisation: Code strukturieren und wiederverwenden",
                                "Best Practices: Ein Modul = Ein Zweck"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Module verstehen",
                                "goal": "Was sind Module und wie funktionieren Imports",
                                "why": "Module sind die Basis fÃ¼r Code-Organisation. Jedes `.py` File ist ein Modul!",
                                "instruction": "",
                                "code": "# Python hat 3 Arten von Modulen:\n\n# 1. BUILT-IN MODULE (kommen mit Python)\nimport math\nimport random\nimport datetime\n\nprint(\"Built-in Module:\")\nprint(f\"Pi = {math.pi}\")\nprint(f\"Zufallszahl: {random.randint(1, 10)}\")\nprint(f\"Heute: {datetime.date.today()}\")\n\n# 2. THIRD-PARTY MODULE (installiert mit pip)\n# Beispiele: requests, numpy, pandas\n# Installation: pip install requests\n\n# 3. EIGENE MODULE (deine .py Dateien!)\n\n# VERSCHIEDENE IMPORT-ARTEN:\n\n# Import 1: Ganzes Modul\nimport math\nergebnis = math.sqrt(16)\n\n# Import 2: Spezifische Funktionen\nfrom math import sqrt, pi\nergebnis = sqrt(16)  # Kein math. nÃ¶tig!\nprint(f\"Pi direkt: {pi}\")\n\n# Import 3: Alles importieren (âš ï¸ nicht empfohlen!)\nfrom math import *  # Importiert ALLES\n# Warum schlecht? Name-Konflikte mÃ¶glich!\n\n# Import 4: Mit Alias (Umbenennen)\nimport math as m\nergebnis = m.sqrt(16)\n\nfrom datetime import datetime as dt\njetzt = dt.now()\n\n# Import 5: Mehrere auf einmal\nfrom math import sqrt, ceil, floor, pi\n\n# MODULE PFAD\nimport sys\nprint(\"\\nModule werden gesucht in:\")\nfor pfad in sys.path:\n    print(f\"  - {pfad}\")\n\n# Aktuelles Verzeichnis ist immer dabei!",
                                "checkpoint": " - Jedes `.py` File ist ein Modul - `import modul` importiert ganzes Modul - `from modul import funktion` importiert Spezifisches - `as` benennt um - Module werden in `sys.path` gesucht"
                        },
                        {
                                "number": 2,
                                "title": "Eigenes Modul erstellen",
                                "goal": "Erstes eigenes Modul bauen",
                                "why": "Code wiederverwenden ohne Copy-Paste!",
                                "instruction": "",
                                "code": "# Erstelle neue Datei: rechner_utils.py\n\"\"\"\nRechner-Utilities - Hilfs-Funktionen fÃ¼r Berechnungen\n\nDieses Modul stellt nÃ¼tzliche Rechner-Funktionen bereit.\n\"\"\"\n\ndef addiere(a, b):\n    \"\"\"Addiert zwei Zahlen\"\"\"\n    return a + b\n\ndef subtrahiere(a, b):\n    \"\"\"Subtrahiert b von a\"\"\"\n    return a - b\n\ndef multipliziere(a, b):\n    \"\"\"Multipliziert zwei Zahlen\"\"\"\n    return a * b\n\ndef dividiere(a, b):\n    \"\"\"Dividiert a durch b (mit Error Handling)\"\"\"\n    try:\n        return a / b\n    except ZeroDivisionError:\n        print(\"âŒ Division durch 0!\")\n        return None\n\ndef potenz(basis, exponent):\n    \"\"\"Berechnet basis^exponent\"\"\"\n    return basis ** exponent\n\ndef ist_gerade(zahl):\n    \"\"\"PrÃ¼ft ob Zahl gerade ist\"\"\"\n    return zahl % 2 == 0\n\n# Modul-Variable\nVERSION = \"1.0.0\"\nAUTOR = \"Dein Name\"\n\n# Private Funktion (beginnt mit _)\ndef _interne_hilfsfunktion():\n    \"\"\"Sollte nicht von auÃŸen verwendet werden\"\"\"\n    return \"Nur fÃ¼r interne Nutzung\"\n\n# Wird nur ausgefÃ¼hrt wenn Modul direkt gestartet\nif __name__ == \"__main__\":\n    print(\"Rechner-Utils wird direkt ausgefÃ¼hrt (Test-Modus)\")\n    print(f\"Version: {VERSION}\")\n    print(f\"10 + 5 = {addiere(10, 5)}\")\n    print(f\"10 / 0 = {dividiere(10, 0)}\")\n# Haupt-Programm: main.py\n\n# Methode 1: Ganzes Modul\nimport rechner_utils\n\nprint(\"Mit import rechner_utils:\")\nprint(f\"5 + 3 = {rechner_utils.addiere(5, 3)}\")\nprint(f\"Version: {rechner_utils.VERSION}\")\n\n# Methode 2: Spezifische Funktionen\nfrom rechner_utils import addiere, multipliziere\n\nprint(\"\\nMit from rechner_utils import:\")\nprint(f\"5 + 3 = {addiere(5, 3)}\")\nprint(f\"5 * 3 = {multipliziere(5, 3)}\")\n\n# Methode 3: Mit Alias\nimport rechner_utils as ru\n\nprint(\"\\nMit Alias:\")\nprint(f\"10 ^ 2 = {ru.potenz(10, 2)}\")\n\n# Modul-Info\nprint(f\"\\nModul-Dokumentation:\")\nprint(rechner_utils.__doc__)\n\nprint(f\"\\nVerfÃ¼gbare Funktionen:\")\nfor name in dir(rechner_utils):\n    if not name.startswith('_'):  # Ignoriere private\n        print(f\"  - {name}\")",
                                "checkpoint": " - Eigenes Modul erstellt (`rechner_utils.py`) - Funktionen und Variablen exportiert - Docstrings fÃ¼r Dokumentation - `if __name__ == \"__main__\":` fÃ¼r Test-Code"
                        },
                        {
                                "number": 3,
                                "title": "Modul-Package erstellen",
                                "goal": "Mehrere Module in einem Package organisieren",
                                "why": "GrÃ¶ÃŸere Projekte brauchen Struktur!",
                                "instruction": "",
                                "code": "# PACKAGE-STRUKTUR erstellen:\n\"\"\"\nmein_projekt/\nâ”œâ”€â”€ __init__.py          (macht es zum Package)\nâ”œâ”€â”€ rechner.py\nâ”œâ”€â”€ text_utils.py\nâ””â”€â”€ datei_utils.py\n\"\"\"\n\n# 1. Erstelle Ordner: mein_projekt\n# 2. Erstelle __init__.py (kann leer sein)\n# 3. Erstelle die Module\n\"\"\"\nMein Projekt - Eine Sammlung nÃ¼tzlicher Tools\n\"\"\"\n\nVERSION = \"1.0.0\"\n\n# Was soll beim \"from mein_projekt import *\" importiert werden?\n__all__ = ['rechner', 'text_utils', 'datei_utils']\n\nprint(f\"ğŸ“¦ Mein Projekt v{VERSION} geladen\")\n\"\"\"Rechner-Modul\"\"\"\n\ndef addiere(a, b):\n    return a + b\n\ndef subtrahiere(a, b):\n    return a - b\n\"\"\"Text-Verarbeitungs-Tools\"\"\"\n\ndef in_groÃŸbuchstaben(text):\n    return text.upper()\n\ndef wort_anzahl(text):\n    return len(text.split())\n\ndef umkehren(text):\n    return text[::-1]\n\"\"\"Datei-Hilfs-Funktionen\"\"\"\n\ndef lese_datei(pfad):\n    with open(pfad, 'r', encoding='utf-8') as f:\n        return f.read()\n\ndef schreibe_datei(pfad, inhalt):\n    with open(pfad, 'w', encoding='utf-8') as f:\n        f.write(inhalt)\n\ndef datei_grÃ¶ÃŸe(pfad):\n    import os\n    return os.path.getsize(pfad)\n# Variante 1: Einzelne Module\nfrom mein_projekt import rechner\nfrom mein_projekt import text_utils\n\nprint(rechner.addiere(5, 3))\nprint(text_utils.in_groÃŸbuchstaben(\"hallo\"))\n\n# Variante 2: Spezifische Funktionen\nfrom mein_projekt.rechner import addiere\nfrom mein_projekt.text_utils import umkehren\n\nprint(addiere(10, 20))\nprint(umkehren(\"Python\"))\n\n# Variante 3: Ganzes Package\nimport mein_projekt\n\n# Dann: mein_projekt.rechner.addiere()",
                                "checkpoint": " - Package = Ordner mit `__init__.py` - Untermodule mit `.` trennen - `__init__.py` definiert Package-Level Code - `__all__` steuert `import *`"
                        },
                        {
                                "number": 4,
                                "title": "Praktisches Tool-Modul",
                                "goal": "VollstÃ¤ndiges, nÃ¼tzliches Utility-Modul",
                                "why": "Real-World Beispiel das du wiederverwenden kannst!",
                                "instruction": "",
                                "code": "\"\"\"\nString Tools - NÃ¼tzliche String-Operationen\n\nEin Sammlung hÃ¤ufig benÃ¶tigter String-Funktionen.\nAutor: [Dein Name]\nVersion: 1.0.0\n\"\"\"\n\nimport re\nfrom typing import List, Dict\n\n# ============================================================\n# VALIDIERUNG\n# ============================================================\n\ndef ist_email(text: str) -> bool:\n    \"\"\"\n    PrÃ¼ft ob String eine gÃ¼ltige E-Mail ist\n    \n    Args:\n        text: Zu prÃ¼fender String\n        \n    Returns:\n        True wenn gÃ¼ltige E-Mail, sonst False\n    \n    Examples:\n        >>> ist_email(\"test@example.com\")\n        True\n        >>> ist_email(\"nicht-gÃ¼ltig\")\n        False\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, text))\n\ndef ist_telefonnummer(text: str) -> bool:\n    \"\"\"PrÃ¼ft ob String eine deutsche Telefonnummer ist\"\"\"\n    # Vereinfachte PrÃ¼fung\n    pattern = r'^\\+?[\\d\\s\\-\\(\\)]{6,}$'\n    return bool(re.match(pattern, text))\n\ndef ist_url(text: str) -> bool:\n    \"\"\"PrÃ¼ft ob String eine URL ist\"\"\"\n    pattern = r'^https?://[^\\s]+'\n    return bool(re.match(pattern, text))\n\n# ============================================================\n# TRANSFORMATION\n# ============================================================\n\ndef zu_slug(text: str) -> str:\n    \"\"\"\n    Konvertiert Text zu URL-freundlichem Slug\n    \n    \"Hallo Welt!\" -> \"hallo-welt\"\n    \"\"\"\n    # Kleinbuchstaben\n    text = text.lower()\n    # Umlaute ersetzen\n    umlaute = {\n        'Ã¤': 'ae', 'Ã¶': 'oe', 'Ã¼': 'ue',\n        'ÃŸ': 'ss'\n    }\n    for alt, neu in umlaute.items():\n        text = text.replace(alt, neu)\n    \n    # Nur Buchstaben, Zahlen, Bindestriche\n    text = re.sub(r'[^a-z0-9\\-]', '-', text)\n    # Mehrfache Bindestriche reduzieren\n    text = re.sub(r'-+', '-', text)\n    # Bindestriche am Anfang/Ende entfernen\n    text = text.strip('-')\n    \n    return text\n\ndef kÃ¼rzen(text: str, max_lÃ¤nge: int, endung: str = \"...\") -> str:\n    \"\"\"\n    KÃ¼rzt Text auf maximale LÃ¤nge\n    \n    Args:\n        text: Zu kÃ¼rzender Text\n        max_lÃ¤nge: Maximale LÃ¤nge\n        endung: Was am Ende angefÃ¼gt wird\n    \"\"\"\n    if len(text) <= max_lÃ¤nge:\n        return text\n    \n    return text[:max_lÃ¤nge - len(endung)] + endung\n\ndef zentriere(text: str, breite: int, fÃ¼ll_zeichen: str = ' ') -> str:\n    \"\"\"Zentriert Text in gegebener Breite\"\"\"\n    if len(text) >= breite:\n        return text\n    \n    links = (breite - len(text)) // 2\n    rechts = breite - len(text) - links\n    \n    return fÃ¼ll_zeichen * links + text + fÃ¼ll_zeichen * rechts\n\n# ============================================================\n# EXTRAKTION\n# ============================================================\n\ndef extrahiere_emails(text: str) -> List[str]:\n    \"\"\"Findet alle E-Mail-Adressen in Text\"\"\"\n    pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    return re.findall(pattern, text)\n\ndef extrahiere_urls(text: str) -> List[str]:\n    \"\"\"Findet alle URLs in Text\"\"\"\n    pattern = r'https?://[^\\s]+'\n    return re.findall(pattern, text)\n\ndef extrahiere_hashtags(text: str) -> List[str]:\n    \"\"\"Findet alle Hashtags in Text\"\"\"\n    pattern = r'#\\w+'\n    return re.findall(pattern, text)\n\ndef extrahiere_zahlen(text: str) -> List[float]:\n    \"\"\"Findet alle Zahlen in Text\"\"\"\n    pattern = r'-?\\d+\\.?\\d*'\n    zahlen_str = re.findall(pattern, text)\n    return [float(z) for z in zahlen_str]\n\n# ============================================================\n# ANALYSE\n# ============================================================\n\ndef wort_hÃ¤ufigkeit(text: str) -> Dict[str, int]:\n    \"\"\"\n    ZÃ¤hlt HÃ¤ufigkeit jedes Wortes\n    \n    Returns:\n        Dictionary {wort: anzahl}\n    \"\"\"\n    # Worte extrahieren (nur Buchstaben)\n    worte = re.findall(r'\\b[a-zA-ZÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ]+\\b', text.lower())\n    \n    hÃ¤ufigkeit = {}\n    for wort in worte:\n        hÃ¤ufigkeit[wort] = hÃ¤ufigkeit.get(wort, 0) + 1\n    \n    return hÃ¤ufigkeit\n\ndef statistiken(text: str) -> Dict:\n    \"\"\"Umfassende Text-Statistiken\"\"\"\n    worte = text.split()\n    zeichen_ohne_leerzeichen = len(text.replace(' ', ''))\n    \n    return {\n        'zeichen': len(text),\n        'zeichen_ohne_leerzeichen': zeichen_ohne_leerzeichen,\n        'worte': len(worte),\n        'zeilen': len(text.splitlines()),\n        'sÃ¤tze': len(re.findall(r'[.!?]+', text)),\n        'durchschnitt_wortlÃ¤nge': sum(len(w) for w in worte) / len(worte) if worte else 0,\n        'lÃ¤ngste_wort': max(worte, key=len) if worte else \"\",\n    }\n\n# ============================================================\n# BEREINIGUNG\n# ============================================================\n\ndef entferne_html_tags(text: str) -> str:\n    \"\"\"Entfernt HTML-Tags aus Text\"\"\"\n    return re.sub(r'<[^>]+>', '', text)\n\ndef entferne_extra_leerzeichen(text: str) -> str:\n    \"\"\"Reduziert mehrfache Leerzeichen auf eines\"\"\"\n    return re.sub(r'\\s+', ' ', text).strip()\n\ndef entferne_sonderzeichen(text: str, behalte: str = '') -> str:\n    \"\"\"\n    Entfernt Sonderzeichen, behÃ¤lt nur Buchstaben, Zahlen und Leerzeichen\n    \n    Args:\n        text: Zu bereinigender Text\n        behalte: ZusÃ¤tzliche Zeichen die behalten werden sollen\n    \"\"\"\n    pattern = f'[^a-zA-Z0-9Ã¤Ã¶Ã¼Ã„Ã–ÃœÃŸ\\\\s{re.escape(behalte)}]'\n    return re.sub(pattern, '', text)\n\n# ============================================================\n# TEST / DEMO\n# ============================================================\n\nif __name__ == \"__main__\":\n    print(\"=\" * 60)\n    print(\"STRING TOOLS - DEMO\")\n    print(\"=\" * 60)\n    \n    # Validierung\n    print(\"\\nğŸ“§ VALIDIERUNG:\")\n    print(f\"ist_email('test@example.com'): {ist_email('test@example.com')}\")\n    print(f\"ist_email('nicht-gÃ¼ltig'): {ist_email('nicht-gÃ¼ltig')}\")\n    \n    # Transformation\n    print(\"\\nğŸ”„ TRANSFORMATION:\")\n    print(f\"zu_slug('Hallo Welt!'): {zu_slug('Hallo Welt!')}\")\n    print(f\"kÃ¼rzen('Langer Text...', 10): {kÃ¼rzen('Langer Text...', 10)}\")\n    print(f\"zentriere('Hallo', 20, '-'): {zentriere('Hallo', 20, '-')}\")\n    \n    # Extraktion\n    print(\"\\nğŸ” EXTRAKTION:\")\n    test_text = \"Kontakt: test@example.com oder https://example.com #Python #Lernen\"\n    print(f\"Text: {test_text}\")\n    print(f\"E-Mails: {extrahiere_emails(test_text)}\")\n    print(f\"URLs: {extrahiere_urls(test_text)}\")\n    print(f\"Hashtags: {extrahiere_hashtags(test_text)}\")\n    \n    # Analyse\n    print(\"\\nğŸ“Š ANALYSE:\")\n    beispiel = \"Python ist toll. Python macht SpaÃŸ. Ich lerne Python.\"\n    stats = statistiken(beispiel)\n    for key, value in stats.items():\n        if isinstance(value, float):\n            print(f\"{key}: {value:.2f}\")\n        else:\n            print(f\"{key}: {value}\")\n    \n    print(f\"\\nWort-HÃ¤ufigkeit:\")\n    for wort, anzahl in sorted(wort_hÃ¤ufigkeit(beispiel).items()):\n        print(f\"  '{wort}': {anzahl}Ã—\")\n# Hauptprogramm\nimport string_tools as st\n\nprint(\"ğŸ› ï¸ STRING TOOLS IN AKTION\")\nprint(\"=\" * 60)\n\n# Beispiel 1: E-Mail Validierung\nemails = [\"valid@test.com\", \"invalid\", \"another@example.org\"]\nprint(\"\\nE-Mail Validierung:\")\nfor email in emails:\n    status = \"âœ…\" if st.ist_email(email) else \"âŒ\"\n    print(f\"{status} {email}\")\n\n# Beispiel 2: URL-Slug erstellen\ntitel = \"Mein erster Blog-Post Ã¼ber Python!\"\nslug = st.zu_slug(titel)\nprint(f\"\\nTitel: {titel}\")\nprint(f\"Slug: {slug}\")\n\n# Beispiel 3: Text analysieren\ntext = \"\"\"\nPython ist eine moderne Programmiersprache. Python ist einfach zu lernen.\nViele Entwickler lieben Python. Python wird fÃ¼r AI, Web, und mehr genutzt.\n\"\"\"\n\nprint(\"\\nğŸ“Š Text-Analyse:\")\nstats = st.statistiken(text)\nfor key, value in stats.items():\n    print(f\"  {key}: {value if not isinstance(value, float) else f'{value:.2f}'}\")\n\n# Beispiel 4: Daten extrahieren\nkontakt_text = \"\"\"\nKontakt:\nE-Mail: info@firma.de\nAlternative: support@firma.com\nWebsite: https://firma.de\nFollow us #Python #Coding\n\"\"\"\n\nprint(\"\\nğŸ” Extrahierte Daten:\")\nprint(f\"E-Mails: {st.extrahiere_emails(kontakt_text)}\")\nprint(f\"URLs: {st.extrahiere_urls(kontakt_text)}\")\nprint(f\"Hashtags: {st.extrahiere_hashtags(kontakt_text)}\")",
                                "checkpoint": " - Umfassendes Utility-Modul erstellt - Kategorisierte Funktionen (Validierung, Transformation, etc.) - Docstrings fÃ¼r alle Funktionen - Test-Code mit `if __name__ == \"__main__\":` - Wiederverwendbar in anderen Projekten"
                        }
                ]
        },
      ]
    },
    {
      id: 3,
      title: "Woche 3: OOP & Module",
      subtitle: "Objektorientierte Programmierung",
      description: "Lerne Classes, Vererbung und wie man eigene Module erstellt.",
      color: "yellow",
      days: [
        {
                "id": 1,
                "weekId": 3,
                "title": "Bankkonto-Simulator (Classes Basics)",
                "duration": "45-60 min",
                "task": {
                        "title": "Bankkonto-Simulator (Classes Basics)",
                        "description": "Lerne Objektorientierte Programmierung (OOP) indem du ein Bankkonto-System erstellst!",
                        "goals": [
                                "Classes: Blaupausen fÃ¼r Objekte",
                                "`__init__`: Constructor",
                                "self: Referenz auf das Objekt",
                                "Attribute: Daten/Eigenschaften",
                                "Methoden: Funktionen des Objekts",
                                "Private Methoden: `_methode()`",
                                "Magic Methods: `__str__`, `__repr__`, etc.",
                                "Objekt-Interaktion: Objekte kÃ¶nnen miteinander arbeiten"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Was sind Classes?",
                                "goal": "Verstehen was Classes sind und warum wir sie brauchen",
                                "why": "",
                                "instruction": "",
                                "code": "# OHNE CLASSES (alte Methode):\n# Daten und Funktionen sind getrennt\n\nkonto_name = \"Max MÃ¼ller\"\nkonto_kontostand = 1000.0\nkonto_nummer = \"DE123456\"\n\ndef einzahlen_alt(betrag):\n    global konto_kontostand\n    konto_kontostand += betrag\n\ndef abheben_alt(betrag):\n    global konto_kontostand\n    if konto_kontostand >= betrag:\n        konto_kontostand -= betrag\n        return True\n    return False\n\n# Was wenn wir 100 Konten haben? ğŸ¤¯\n# konto1_name, konto1_kontostand, ...\n# konto2_name, konto2_kontostand, ...\n# Das wird schnell unÃ¼bersichtlich!\n\n# MIT CLASSES (neue, bessere Methode):\nclass Bankkonto:\n    \"\"\"Ein Bankkonto mit Name, Nummer und Kontostand\"\"\"\n    \n    # __init__ ist der CONSTRUCTOR - wird beim Erstellen aufgerufen\n    def __init__(self, inhaber, kontonummer):\n        \"\"\"Initialisiert ein neues Bankkonto\"\"\"\n        # self = das Objekt selbst\n        # self.variable = Attribut (Eigenschaft) des Objekts\n        self.inhaber = inhaber\n        self.kontonummer = kontonummer\n        self.kontostand = 0.0  # Startwert\n    \n    # Methoden (Funktionen die zum Objekt gehÃ¶ren)\n    def einzahlen(self, betrag):\n        \"\"\"Zahlt Geld ein\"\"\"\n        if betrag > 0:\n            self.kontostand += betrag\n            print(f\"âœ… {betrag}â‚¬ eingezahlt. Neuer Stand: {self.kontostand}â‚¬\")\n        else:\n            print(\"âŒ Betrag muss positiv sein!\")\n    \n    def abheben(self, betrag):\n        \"\"\"Hebt Geld ab\"\"\"\n        if betrag > 0:\n            if self.kontostand >= betrag:\n                self.kontostand -= betrag\n                print(f\"âœ… {betrag}â‚¬ abgehoben. Neuer Stand: {self.kontostand}â‚¬\")\n                return True\n            else:\n                print(f\"âŒ Nicht genug Geld! (Kontostand: {self.kontostand}â‚¬)\")\n                return False\n        else:\n            print(\"âŒ Betrag muss positiv sein!\")\n            return False\n    \n    def kontostand_anzeigen(self):\n        \"\"\"Zeigt den aktuellen Kontostand\"\"\"\n        print(f\"ğŸ’° Kontostand von {self.inhaber}: {self.kontostand}â‚¬\")\n\n# OBJEKTE ERSTELLEN (Instanzen der Klasse)\nprint(\"=\" * 60)\nprint(\"ğŸ¦ BANKKONTO-SYSTEM\")\nprint(\"=\" * 60)\n\n# Erstelle zwei verschiedene Konten\nkonto1 = Bankkonto(\"Anna Schmidt\", \"DE111111\")\nkonto2 = Bankkonto(\"Max MÃ¼ller\", \"DE222222\")\n\n# Jedes Konto hat eigene Daten!\nprint(\"\\nğŸ“ Konten erstellt:\")\nkonto1.kontostand_anzeigen()\nkonto2.kontostand_anzeigen()\n\n# Operationen auf konto1\nprint(\"\\nğŸ’³ Operationen auf Konto 1 (Anna):\")\nkonto1.einzahlen(500)\nkonto1.einzahlen(300)\nkonto1.abheben(200)\n\n# Operationen auf konto2\nprint(\"\\nğŸ’³ Operationen auf Konto 2 (Max):\")\nkonto2.einzahlen(1000)\nkonto2.abheben(1500)  # Zu viel!\nkonto2.abheben(500)\n\n# Finale KontostÃ¤nde\nprint(\"\\nğŸ“Š Finale KontostÃ¤nde:\")\nkonto1.kontostand_anzeigen()\nkonto2.kontostand_anzeigen()",
                                "checkpoint": " - Class = Bauplan fÃ¼r Objekte - `__init__` = Constructor (Initialisierung) - `self` = Referenz auf das Objekt selbst - Methoden = Funktionen die zu einem Objekt gehÃ¶ren - Jedes Objekt hat eigene Attribute!"
                        },
                        {
                                "number": 2,
                                "title": "Attribute und Methoden",
                                "goal": "Unterschied zwischen Attributen und Methoden verstehen",
                                "why": "",
                                "instruction": "",
                                "code": "class Auto:\n    \"\"\"ReprÃ¤sentiert ein Auto\"\"\"\n    \n    def __init__(self, marke, modell, baujahr):\n        # ATTRIBUTE (Daten/Eigenschaften)\n        self.marke = marke\n        self.modell = modell\n        self.baujahr = baujahr\n        self.kilometerstand = 0\n        self.tank_inhalt = 50  # Liter\n        self.tank_kapazitÃ¤t = 50\n    \n    # METHODEN (Verhalten/Funktionen)\n    \n    def fahren(self, kilometer):\n        \"\"\"FÃ¤hrt eine bestimmte Strecke\"\"\"\n        verbrauch_pro_km = 0.07  # 7 Liter/100km\n        benÃ¶tigt = kilometer * verbrauch_pro_km\n        \n        if benÃ¶tigt <= self.tank_inhalt:\n            self.kilometerstand += kilometer\n            self.tank_inhalt -= benÃ¶tigt\n            print(f\"ğŸš— {kilometer} km gefahren. Tank: {self.tank_inhalt:.1f}L\")\n        else:\n            print(f\"âŒ Nicht genug Sprit! Nur {self.tank_inhalt:.1f}L im Tank.\")\n    \n    def tanken(self, liter):\n        \"\"\"Tankt das Auto\"\"\"\n        platz = self.tank_kapazitÃ¤t - self.tank_inhalt\n        \n        if liter <= platz:\n            self.tank_inhalt += liter\n            print(f\"â›½ {liter}L getankt. Tank: {self.tank_inhalt:.1f}L\")\n        else:\n            self.tank_inhalt = self.tank_kapazitÃ¤t\n            print(f\"â›½ Tank voll! ({self.tank_kapazitÃ¤t}L)\")\n    \n    def info(self):\n        \"\"\"Zeigt Auto-Informationen\"\"\"\n        print(f\"\\nğŸš— {self.marke} {self.modell} ({self.baujahr})\")\n        print(f\"   Kilometerstand: {self.kilometerstand} km\")\n        print(f\"   Tank: {self.tank_inhalt:.1f}L / {self.tank_kapazitÃ¤t}L\")\n\n# Testen\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸš— AUTO-SIMULATOR\")\nprint(\"=\" * 60)\n\nmein_auto = Auto(\"VW\", \"Golf\", 2020)\nmein_auto.info()\n\nprint(\"\\nğŸ“ Fahre zur Arbeit (30km):\")\nmein_auto.fahren(30)\n\nprint(\"\\nğŸ“ Fahre nach Hause (30km):\")\nmein_auto.fahren(30)\n\nprint(\"\\nâ›½ Tanken:\")\nmein_auto.tanken(20)\n\nprint(\"\\nğŸ“ Langer Trip (500km):\")\nmein_auto.fahren(500)\n\nmein_auto.info()\n\n# Attribut direkt Ã¤ndern (geht, aber nicht empfohlen!)\nprint(\"\\nâš ï¸ Direkte Attribut-Ã„nderung (nicht empfohlen):\")\nmein_auto.kilometerstand = 999999  # Betrug! ğŸ˜ˆ\nmein_auto.info()",
                                "checkpoint": " - Attribute speichern Daten (Zustand) - Methoden Ã¤ndern Daten oder fÃ¼hren Aktionen aus - `self.attribut` greift auf Attribute zu - Methoden haben immer `self` als ersten Parameter"
                        },
                        {
                                "number": 3,
                                "title": "Erweitertes Bankkonto mit Transaktionshistorie",
                                "goal": "Komplexere Class mit Listen als Attributen",
                                "why": "Attribute kÃ¶nnen auch Listen, Dicts, andere Objekte sein!",
                                "instruction": "",
                                "code": "from datetime import datetime\n\nclass Bankkonto:\n    \"\"\"Erweitertes Bankkonto mit Transaktionshistorie\"\"\"\n    \n    def __init__(self, inhaber, kontonummer, startguthaben=0):\n        self.inhaber = inhaber\n        self.kontonummer = kontonummer\n        self.kontostand = startguthaben\n        self.transaktionen = []  # Liste von Transaktionen\n        \n        # Erste Transaktion: KontoerÃ¶ffnung\n        if startguthaben > 0:\n            self._transaktion_speichern(\"KontoerÃ¶ffnung\", startguthaben)\n    \n    def _transaktion_speichern(self, typ, betrag):\n        \"\"\"\n        Private Methode (beginnt mit _) - sollte nicht von auÃŸen aufgerufen werden\n        Speichert eine Transaktion\n        \"\"\"\n        transaktion = {\n            'zeitpunkt': datetime.now(),\n            'typ': typ,\n            'betrag': betrag,\n            'kontostand_nach': self.kontostand\n        }\n        self.transaktionen.append(transaktion)\n    \n    def einzahlen(self, betrag, beschreibung=\"Einzahlung\"):\n        \"\"\"Zahlt Geld ein\"\"\"\n        if betrag <= 0:\n            print(\"âŒ Betrag muss positiv sein!\")\n            return False\n        \n        self.kontostand += betrag\n        self._transaktion_speichern(beschreibung, betrag)\n        print(f\"âœ… {betrag:.2f}â‚¬ eingezahlt ({beschreibung})\")\n        return True\n    \n    def abheben(self, betrag, beschreibung=\"Abhebung\"):\n        \"\"\"Hebt Geld ab\"\"\"\n        if betrag <= 0:\n            print(\"âŒ Betrag muss positiv sein!\")\n            return False\n        \n        if self.kontostand >= betrag:\n            self.kontostand -= betrag\n            self._transaktion_speichern(beschreibung, -betrag)  # Negativ!\n            print(f\"âœ… {betrag:.2f}â‚¬ abgehoben ({beschreibung})\")\n            return True\n        else:\n            print(f\"âŒ Nicht genug Geld! (Haben: {self.kontostand:.2f}â‚¬)\")\n            return False\n    \n    def Ã¼berweisen(self, empfÃ¤nger, betrag, verwendungszweck=\"Ãœberweisung\"):\n        \"\"\"Ãœberweist Geld an anderes Konto\"\"\"\n        if self.abheben(betrag, f\"Ãœberweisung an {empfÃ¤nger.inhaber}\"):\n            empfÃ¤nger.einzahlen(betrag, f\"Ãœberweisung von {self.inhaber}\")\n            return True\n        return False\n    \n    def kontoauszug(self, anzahl=10):\n        \"\"\"Zeigt letzte N Transaktionen\"\"\"\n        print(f\"\\n{'=' * 70}\")\n        print(f\"ğŸ“„ KONTOAUSZUG - {self.inhaber}\")\n        print(f\"   Kontonummer: {self.kontonummer}\")\n        print(f\"   Aktueller Stand: {self.kontostand:.2f}â‚¬\")\n        print(f\"{'=' * 70}\")\n        \n        if not self.transaktionen:\n            print(\"Keine Transaktionen vorhanden\")\n            return\n        \n        # Letzte N Transaktionen (neueste zuerst)\n        letzte = self.transaktionen[-anzahl:]\n        letzte.reverse()\n        \n        print(f\"\\n{'Datum':<20} {'Typ':<25} {'Betrag':>12} {'Stand':>12}\")\n        print(\"-\" * 70)\n        \n        for t in letzte:\n            datum = t['zeitpunkt'].strftime(\"%d.%m.%Y %H:%M:%S\")\n            betrag_str = f\"{t['betrag']:+.2f}â‚¬\"  # + fÃ¼r positiv, - fÃ¼r negativ\n            stand_str = f\"{t['kontostand_nach']:.2f}â‚¬\"\n            \n            print(f\"{datum:<20} {t['typ']:<25} {betrag_str:>12} {stand_str:>12}\")\n        \n        print(\"-\" * 70)\n    \n    def statistik(self):\n        \"\"\"Zeigt Statistiken Ã¼ber das Konto\"\"\"\n        if not self.transaktionen:\n            print(\"Keine Transaktionen fÃ¼r Statistik\")\n            return\n        \n        einzahlungen = [t['betrag'] for t in self.transaktionen if t['betrag'] > 0]\n        abhebungen = [abs(t['betrag']) for t in self.transaktionen if t['betrag'] < 0]\n        \n        print(f\"\\nğŸ“Š STATISTIK - {self.inhaber}\")\n        print(f\"Transaktionen gesamt: {len(self.transaktionen)}\")\n        print(f\"Einzahlungen: {len(einzahlungen)} (âˆ‘ {sum(einzahlungen):.2f}â‚¬)\")\n        print(f\"Abhebungen: {len(abhebungen)} (âˆ‘ {sum(abhebungen):.2f}â‚¬)\")\n        \n        if einzahlungen:\n            print(f\"Ã˜ Einzahlung: {sum(einzahlungen)/len(einzahlungen):.2f}â‚¬\")\n        if abhebungen:\n            print(f\"Ã˜ Abhebung: {sum(abhebungen)/len(abhebungen):.2f}â‚¬\")\n\n# TESTEN\nprint(\"=\" * 70)\nprint(\"ğŸ¦ ERWEITERTES BANKKONTO-SYSTEM\")\nprint(\"=\" * 70)\n\n# Konten erstellen\nanna = Bankkonto(\"Anna Schmidt\", \"DE111111\", startguthaben=1000)\nmax_k = Bankkonto(\"Max MÃ¼ller\", \"DE222222\", startguthaben=500)\n\n# Transaktionen\nprint(\"\\nğŸ’³ Transaktionen:\")\nanna.einzahlen(500, \"Gehalt\")\nanna.abheben(100, \"Einkaufen\")\nanna.abheben(50, \"Tanken\")\n\nmax_k.einzahlen(200, \"Freelance\")\nmax_k.abheben(150, \"Restaurant\")\n\n# Ãœberweisung\nprint(\"\\nğŸ’¸ Ãœberweisung:\")\nanna.Ã¼berweisen(max_k, 250, \"Miete\")\n\n# KontoauszÃ¼ge\nanna.kontoauszug(anzahl=5)\nmax_k.kontoauszug(anzahl=5)\n\n# Statistiken\nanna.statistik()\nmax_k.statistik()",
                                "checkpoint": " - Listen als Attribute (Transaktionshistorie) - Private Methoden mit `_` - Objekte interagieren miteinander (Ãœberweisung) - Komplexe Datenstrukturen in Classes"
                        },
                        {
                                "number": 4,
                                "title": "__str__ und __repr__ - Objekte schÃ¶n ausgeben",
                                "goal": "Objekte lesbar machen",
                                "why": "Ohne `__str__` zeigt `print(objekt)` nur `<__main__.Klasse object at 0x...>`",
                                "instruction": "",
                                "code": "class Bankkonto:\n    \"\"\"Bankkonto mit schÃ¶ner String-Darstellung\"\"\"\n    \n    def __init__(self, inhaber, kontonummer, kontostand=0):\n        self.inhaber = inhaber\n        self.kontonummer = kontonummer\n        self.kontostand = kontostand\n    \n    def __str__(self):\n        \"\"\"\n        Wird bei print() und str() aufgerufen\n        Soll benutzerfreundlich sein\n        \"\"\"\n        return f\"Bankkonto von {self.inhaber} (Kontostand: {self.kontostand:.2f}â‚¬)\"\n    \n    def __repr__(self):\n        \"\"\"\n        Wird in der Konsole/Debugger angezeigt\n        Soll eindeutig sein (idealerweise Code um Objekt nachzubauen)\n        \"\"\"\n        return f\"Bankkonto('{self.inhaber}', '{self.kontonummer}', {self.kontostand})\"\n    \n    def einzahlen(self, betrag):\n        self.kontostand += betrag\n    \n    def abheben(self, betrag):\n        if self.kontostand >= betrag:\n            self.kontostand -= betrag\n            return True\n        return False\n\n# Testen\nkonto = Bankkonto(\"Anna\", \"DE123\", 1000)\n\n# Ohne __str__/__repr__ wÃ¼rde das anzeigen:\n# <__main__.Bankkonto object at 0x7f8b2c3d4e10>\n\n# Mit __str__:\nprint(konto)  # Ruft __str__() auf\n# Ausgabe: Bankkonto von Anna (Kontostand: 1000.00â‚¬)\n\n# Mit __repr__:\nprint(repr(konto))  # Ruft __repr__() auf\n# Ausgabe: Bankkonto('Anna', 'DE123', 1000.0)\n\n# In einer Liste:\nkonten = [\n    Bankkonto(\"Anna\", \"DE111\", 1000),\n    Bankkonto(\"Ben\", \"DE222\", 500),\n    Bankkonto(\"Clara\", \"DE333\", 2000)\n]\n\nprint(\"\\nAlle Konten:\")\nfor k in konten:\n    print(k)  # Nutzt __str__\n\nprint(\"\\nRepr-Darstellung:\")\nprint(konten)  # Nutzt __repr__ fÃ¼r jedes Element\n\n# Weitere Magic Methods (kurzer Ãœberblick)\nclass ErweitertesBankkonto(Bankkonto):\n    \n    def __len__(self):\n        \"\"\"Wird bei len() aufgerufen\"\"\"\n        return int(self.kontostand)  # Kontostand als \"LÃ¤nge\"\n    \n    def __bool__(self):\n        \"\"\"Wird bei if/bool() aufgerufen\"\"\"\n        return self.kontostand > 0  # True wenn Guthaben\n    \n    def __eq__(self, other):\n        \"\"\"Wird bei == aufgerufen\"\"\"\n        if isinstance(other, Bankkonto):\n            return self.kontonummer == other.kontonummer\n        return False\n\nkonto1 = ErweitertesBankkonto(\"Test\", \"DE123\", 500)\nkonto2 = ErweitertesBankkonto(\"Test2\", \"DE123\", 1000)  # Gleiche Nummer!\n\nprint(f\"\\nlen(konto1): {len(konto1)}\")  # 500\nprint(f\"bool(konto1): {bool(konto1)}\")  # True (hat Guthaben)\n\nleeres_konto = ErweitertesBankkonto(\"Leer\", \"DE999\", 0)\nprint(f\"bool(leeres_konto): {bool(leeres_konto)}\")  # False (kein Guthaben)\n\nprint(f\"konto1 == konto2: {konto1 == konto2}\")  # True (gleiche Nummer)",
                                "checkpoint": " - `__str__()` fÃ¼r benutzerfreundliche Ausgabe - `__repr__()` fÃ¼r entwicklerfreundliche Ausgabe - Magic Methods wie `__len__`, `__bool__`, `__eq__` - `print(objekt)` ruft `__str__()` auf"
                        }
                ]
        },
        {
                "id": 2,
                "weekId": 3,
                "title": "Spielcharakter-System (Classes Advanced)",
                "duration": "45-60 min",
                "task": {
                        "title": "Spielcharakter-System (Classes Advanced)",
                        "description": "Lerne fortgeschrittene Class-Konzepte durch ein RPG-Charaktersystem!",
                        "goals": [
                                "Class vs Instance Variables: Geteilt vs. individuell",
                                "@classmethod: Methoden die mit der Klasse arbeiten",
                                "@staticmethod: Utility-Funktionen in der Klasse",
                                "@property: Getter/Setter elegant",
                                "Private Attribute: `_attribut` Konvention",
                                "Dataclasses: Weniger Boilerplate fÃ¼r Daten-Klassen",
                                "Type Hints: `List[Item]`, `Dict`, etc.",
                                "Komplexe Systeme: Mehrere Classes zusammen"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Class Variables vs Instance Variables",
                                "goal": "Unterschied zwischen Klassen- und Instanz-Variablen verstehen",
                                "why": "",
                                "instruction": "",
                                "code": "class Spieler:\n    \"\"\"Spieler in einem RPG\"\"\"\n    \n    # CLASS VARIABLE - Gilt fÃ¼r ALLE Spieler\n    anzahl_spieler = 0  # ZÃ¤hlt wie viele Spieler erstellt wurden\n    max_level = 100     # Maximales Level fÃ¼r alle\n    spiel_version = \"1.0.0\"\n    \n    def __init__(self, name):\n        # INSTANCE VARIABLES - Jeder Spieler hat eigene Werte\n        self.name = name\n        self.level = 1\n        self.hp = 100\n        self.exp = 0\n        \n        # Class Variable erhÃ¶hen\n        Spieler.anzahl_spieler += 1\n    \n    def __str__(self):\n        return f\"{self.name} (Lv.{self.level}, HP: {self.hp})\"\n    \n    @classmethod  # Decorator fÃ¼r Class Methods\n    def zeige_statistik(cls):\n        \"\"\"\n        Class Method - arbeitet mit Class Variables\n        cls = die Klasse selbst (wie self, aber fÃ¼r die Klasse)\n        \"\"\"\n        print(f\"ğŸ® Spiel Version: {cls.spiel_version}\")\n        print(f\"ğŸ‘¥ Spieler online: {cls.anzahl_spieler}\")\n        print(f\"â­ Max Level: {cls.max_level}\")\n    \n    @staticmethod  # Decorator fÃ¼r Static Methods\n    def ist_gÃ¼ltiger_name(name):\n        \"\"\"\n        Static Method - braucht weder self noch cls\n        Ist wie eine normale Funktion, gehÃ¶rt aber zur Klasse\n        \"\"\"\n        return len(name) >= 3 and name.isalnum()\n\n# TESTEN\nprint(\"=\" * 60)\nprint(\"ğŸ® CLASS VARIABLES vs INSTANCE VARIABLES\")\nprint(\"=\" * 60)\n\n# Spieler erstellen\nspieler1 = Spieler(\"Anna\")\nspieler2 = Spieler(\"Max\")\nspieler3 = Spieler(\"Lisa\")\n\n# Instance Variables - jeder hat eigene\nprint(\"\\nInstance Variables (individuell):\")\nprint(f\"Spieler 1: {spieler1}\")\nprint(f\"Spieler 2: {spieler2}\")\nprint(f\"Spieler 3: {spieler3}\")\n\nspieler1.hp = 50  # Nur spieler1 betroffen!\nprint(f\"\\nNach HP-Ã„nderung:\")\nprint(f\"Spieler 1 HP: {spieler1.hp}\")\nprint(f\"Spieler 2 HP: {spieler2.hp}\")\n\n# Class Variables - alle teilen\nprint(f\"\\nClass Variable (geteilt):\")\nprint(f\"Anzahl Spieler: {Spieler.anzahl_spieler}\")\nprint(f\"Auch Ã¼ber Instanz: {spieler1.anzahl_spieler}\")\n\n# Class Method aufrufen\nprint(\"\\nğŸ“Š Statistik:\")\nSpieler.zeige_statistik()\n\n# Static Method aufrufen\nprint(\"\\nâœ… Namen validieren:\")\nnamen = [\"An\", \"Anna123\", \"Max_MÃ¼ller\", \"Clara\"]\nfor name in namen:\n    gÃ¼ltig = \"âœ…\" if Spieler.ist_gÃ¼ltiger_name(name) else \"âŒ\"\n    print(f\"{gÃ¼ltig} {name}\")",
                                "checkpoint": " - Class Variables: AuÃŸerhalb von `__init__`, geteilt - Instance Variables: Mit `self.`, individuell - `@classmethod`: Arbeitet mit Klasse, nutzt `cls` - `@staticmethod`: Normale Funktion in der Klasse"
                        },
                        {
                                "number": 2,
                                "title": "Properties (@property)",
                                "goal": "Getter und Setter elegant implementieren",
                                "why": "Properties erlauben Kontrolle Ã¼ber Attribut-Zugriff mit normaler Syntax!",
                                "instruction": "",
                                "code": "class Charakter:\n    \"\"\"RPG-Charakter mit Properties\"\"\"\n    \n    def __init__(self, name, level=1):\n        self.name = name\n        self._level = level  # _ zeigt: \"privates\" Attribut\n        self._hp = 100\n        self._max_hp = 100\n        self._exp = 0\n    \n    # PROPERTY: hp (mit Getter und Setter)\n    @property\n    def hp(self):\n        \"\"\"Getter fÃ¼r HP\"\"\"\n        return self._hp\n    \n    @hp.setter\n    def hp(self, wert):\n        \"\"\"Setter fÃ¼r HP - mit Validierung!\"\"\"\n        if wert < 0:\n            self._hp = 0\n        elif wert > self._max_hp:\n            self._hp = self._max_hp\n        else:\n            self._hp = wert\n    \n    # READ-ONLY PROPERTY (nur Getter, kein Setter)\n    @property\n    def ist_am_leben(self):\n        \"\"\"Gibt True zurÃ¼ck wenn HP > 0\"\"\"\n        return self._hp > 0\n    \n    # PROPERTY: level (mit automatischer HP-Anpassung)\n    @property\n    def level(self):\n        return self._level\n    \n    @level.setter\n    def level(self, wert):\n        if wert > self._level:\n            # Level-Up!\n            self._level = wert\n            self._max_hp = 100 + (wert - 1) * 10  # +10 HP pro Level\n            self._hp = self._max_hp  # Volle HP beim Level-Up\n            print(f\"ğŸ‰ LEVEL UP! {self.name} ist jetzt Level {wert}!\")\n    \n    # COMPUTED PROPERTY (wird berechnet, nicht gespeichert)\n    @property\n    def hp_prozent(self):\n        \"\"\"HP als Prozentsatz\"\"\"\n        return (self._hp / self._max_hp) * 100\n    \n    @property\n    def hp_bar(self):\n        \"\"\"Visuelle HP-Anzeige\"\"\"\n        filled = int(self.hp_prozent / 10)  # 10 BlÃ¶cke\n        empty = 10 - filled\n        return f\"[{'â–ˆ' * filled}{'â–‘' * empty}] {self._hp}/{self._max_hp}\"\n    \n    def schaden_nehmen(self, schaden):\n        \"\"\"Nimmt Schaden\"\"\"\n        self.hp -= schaden  # Nutzt den Setter!\n        print(f\"ğŸ’¥ {self.name} nimmt {schaden} Schaden! HP: {self.hp_bar}\")\n    \n    def heilen(self, menge):\n        \"\"\"Heilt HP\"\"\"\n        self.hp += menge  # Nutzt den Setter!\n        print(f\"ğŸ’š {self.name} heilt {menge} HP! HP: {self.hp_bar}\")\n\n# TESTEN\nprint(\"\\n\" + \"=\" * 60)\nprint(\"âœ¨ PROPERTIES DEMO\")\nprint(\"=\" * 60)\n\nheld = Charakter(\"Arathorn\")\n\nprint(f\"\\n{held.name} startet:\")\nprint(f\"Level: {held.level}\")\nprint(f\"HP: {held.hp_bar}\")\nprint(f\"Am Leben? {held.ist_am_leben}\")\n\n# Schaden nehmen\nprint(\"\\nâš”ï¸ Kampf:\")\nheld.schaden_nehmen(30)\nheld.schaden_nehmen(25)\n\n# Versuche negative HP (wird durch Setter verhindert!)\nprint(\"\\nâš”ï¸ Kritischer Treffer:\")\nheld.hp = -50  # Setter setzt auf 0\nprint(f\"HP nach -50: {held.hp}\")  # Zeigt 0\n\n# Heilen\nprint(\"\\nğŸ’š Heilung:\")\nheld.heilen(40)\n\n# Versuche Ã¼ber Maximum (wird durch Setter verhindert!)\nheld.hp = 999  # Setter begrenzt auf max_hp\nprint(f\"HP nach 999: {held.hp}\")\n\n# Level-Up\nprint(\"\\nâ­ Level-Up:\")\nheld.level = 5\n\nprint(f\"\\nFinaler Status:\")\nprint(f\"Level: {held.level}\")\nprint(f\"HP: {held.hp_bar}\")\n\n# Versuche read-only zu setzen (Fehler!)\ntry:\n    held.ist_am_leben = False  # Geht nicht!\nexcept AttributeError as e:\n    print(f\"\\nâŒ Fehler: {e}\")\n    print(\"ist_am_leben ist read-only!\")",
                                "checkpoint": " - `@property` macht Methode zu Attribut-Zugriff - Getter holt Wert - Setter validiert/transformiert Wert - Read-only Properties (nur Getter) - Computed Properties (berechnet bei Zugriff)"
                        },
                        {
                                "number": 3,
                                "title": "VollstÃ¤ndiges RPG-Charakter-System",
                                "goal": "Alle Konzepte in einem komplexen System kombinieren",
                                "why": "Real-World Beispiel mit allen Features!",
                                "instruction": "",
                                "code": "from dataclasses import dataclass\nfrom typing import List, Dict\nimport random\n\n@dataclass\nclass Item:\n    \"\"\"Einfaches Item (nutzt dataclass fÃ¼r weniger Code)\"\"\"\n    name: str\n    typ: str  # 'waffe', 'rÃ¼stung', 'trank'\n    wert: int\n    \n    def __str__(self):\n        return f\"{self.name} ({self.typ}, +{self.wert})\"\n\nclass Inventar:\n    \"\"\"Inventar fÃ¼r Items\"\"\"\n    \n    def __init__(self, max_grÃ¶ÃŸe=20):\n        self.items: List[Item] = []\n        self.max_grÃ¶ÃŸe = max_grÃ¶ÃŸe\n    \n    def hinzufÃ¼gen(self, item: Item) -> bool:\n        \"\"\"FÃ¼gt Item hinzu\"\"\"\n        if len(self.items) < self.max_grÃ¶ÃŸe:\n            self.items.append(item)\n            print(f\"âœ… {item.name} hinzugefÃ¼gt\")\n            return True\n        else:\n            print(f\"âŒ Inventar voll!\")\n            return False\n    \n    def entfernen(self, item_name: str) -> bool:\n        \"\"\"Entfernt Item nach Name\"\"\"\n        for item in self.items:\n            if item.name == item_name:\n                self.items.remove(item)\n                print(f\"ğŸ—‘ï¸ {item_name} entfernt\")\n                return True\n        return False\n    \n    def finde(self, item_name: str) -> Item:\n        \"\"\"Findet Item nach Name\"\"\"\n        for item in self.items:\n            if item.name.lower() == item_name.lower():\n                return item\n        return None\n    \n    def nach_typ(self, typ: str) -> List[Item]:\n        \"\"\"Gibt alle Items eines Typs zurÃ¼ck\"\"\"\n        return [item for item in self.items if item.typ == typ]\n    \n    def anzeigen(self):\n        \"\"\"Zeigt Inventar\"\"\"\n        if not self.items:\n            print(\"ğŸ“¦ Inventar leer\")\n            return\n        \n        print(f\"\\nğŸ“¦ INVENTAR ({len(self.items)}/{self.max_grÃ¶ÃŸe}):\")\n        \n        # Gruppiert nach Typ\n        typen = {}\n        for item in self.items:\n            if item.typ not in typen:\n                typen[item.typ] = []\n            typen[item.typ].append(item)\n        \n        for typ, items in typen.items():\n            print(f\"\\n{typ.upper()}:\")\n            for item in items:\n                print(f\"  - {item}\")\n\nclass Charakter:\n    \"\"\"VollstÃ¤ndiger RPG-Charakter\"\"\"\n    \n    # Class Variables\n    charaktere_erstellt = 0\n    \n    def __init__(self, name: str, klasse: str):\n        self.name = name\n        self.klasse = klasse  # z.B. \"Krieger\", \"Magier\"\n        \n        # Stats\n        self._level = 1\n        self._exp = 0\n        self._exp_fÃ¼r_next_level = 100\n        \n        # HP/Mana\n        self._max_hp = self._berechne_max_hp()\n        self._hp = self._max_hp\n        self._max_mana = self._berechne_max_mana()\n        self._mana = self._max_mana\n        \n        # Kampf-Stats\n        self._angriff = self._berechne_angriff()\n        self._verteidigung = self._berechne_verteidigung()\n        \n        # Inventar\n        self.inventar = Inventar()\n        \n        # AusrÃ¼stung\n        self.waffe: Item = None\n        self.rÃ¼stung: Item = None\n        \n        Charakter.charaktere_erstellt += 1\n    \n    # === PROPERTIES ===\n    \n    @property\n    def level(self):\n        return self._level\n    \n    @property\n    def hp(self):\n        return self._hp\n    \n    @hp.setter\n    def hp(self, wert):\n        self._hp = max(0, min(wert, self._max_hp))\n    \n    @property\n    def mana(self):\n        return self._mana\n    \n    @mana.setter\n    def mana(self, wert):\n        self._mana = max(0, min(wert, self._max_mana))\n    \n    @property\n    def ist_am_leben(self):\n        return self._hp > 0\n    \n    @property\n    def angriff_total(self):\n        \"\"\"Basis-Angriff + Waffen-Bonus\"\"\"\n        bonus = self.waffe.wert if self.waffe else 0\n        return self._angriff + bonus\n    \n    @property\n    def verteidigung_total(self):\n        \"\"\"Basis-Verteidigung + RÃ¼stungs-Bonus\"\"\"\n        bonus = self.rÃ¼stung.wert if self.rÃ¼stung else 0\n        return self._verteidigung + bonus\n    \n    # === PRIVATE METHODEN ===\n    \n    def _berechne_max_hp(self):\n        \"\"\"Berechnet Max-HP basierend auf Level und Klasse\"\"\"\n        basis = 100\n        pro_level = 15 if self.klasse == \"Krieger\" else 10\n        return basis + (self._level - 1) * pro_level\n    \n    def _berechne_max_mana(self):\n        \"\"\"Berechnet Max-Mana basierend auf Level und Klasse\"\"\"\n        basis = 50\n        pro_level = 15 if self.klasse == \"Magier\" else 5\n        return basis + (self._level - 1) * pro_level\n    \n    def _berechne_angriff(self):\n        \"\"\"Berechnet Basis-Angriff\"\"\"\n        if self.klasse == \"Krieger\":\n            return 15 + self._level * 2\n        elif self.klasse == \"Magier\":\n            return 10 + self._level\n        else:\n            return 12 + self._level\n    \n    def _berechne_verteidigung(self):\n        \"\"\"Berechnet Basis-Verteidigung\"\"\"\n        return 5 + self._level\n    \n    # === Ã–FFENTLICHE METHODEN ===\n    \n    def exp_sammeln(self, menge: int):\n        \"\"\"Sammelt EXP und prÃ¼ft Level-Up\"\"\"\n        self._exp += menge\n        print(f\"âœ¨ {menge} EXP gesammelt! ({self._exp}/{self._exp_fÃ¼r_next_level})\")\n        \n        while self._exp >= self._exp_fÃ¼r_next_level:\n            self._level_up()\n    \n    def _level_up(self):\n        \"\"\"Level-Up mit Stat-ErhÃ¶hungen\"\"\"\n        self._level += 1\n        self._exp -= self._exp_fÃ¼r_next_level\n        self._exp_fÃ¼r_next_level = int(self._exp_fÃ¼r_next_level * 1.5)\n        \n        # Stats neu berechnen\n        self._max_hp = self._berechne_max_hp()\n        self._max_mana = self._berechne_max_mana()\n        self._angriff = self._berechne_angriff()\n        self._verteidigung = self._berechne_verteidigung()\n        \n        # Volle HP/Mana beim Level-Up\n        self._hp = self._max_hp\n        self._mana = self._max_mana\n        \n        print(f\"ğŸ‰ LEVEL UP! {self.name} ist jetzt Level {self._level}!\")\n        print(f\"   HP: {self._max_hp} | Mana: {self._max_mana}\")\n        print(f\"   Angriff: {self._angriff} | Verteidigung: {self._verteidigung}\")\n    \n    def angreifen(self, gegner: 'Charakter'):\n        \"\"\"Greift einen Gegner an\"\"\"\n        if not self.ist_am_leben:\n            print(f\"âŒ {self.name} ist tot!\")\n            return\n        \n        # Schaden berechnen\n        basis_schaden = self.angriff_total\n        schaden = max(1, basis_schaden - gegner.verteidigung_total)\n        \n        # Kritischer Treffer? (10% Chance)\n        if random.random() < 0.1:\n            schaden *= 2\n            print(f\"ğŸ’¥ KRITISCHER TREFFER!\")\n        \n        gegner.hp -= schaden\n        print(f\"âš”ï¸ {self.name} greift {gegner.name} an! -{schaden} HP\")\n        \n        if not gegner.ist_am_leben:\n            print(f\"ğŸ’€ {gegner.name} wurde besiegt!\")\n            self.exp_sammeln(gegner.level * 50)\n    \n    def heilen(self, menge: int):\n        \"\"\"Heilt HP\"\"\"\n        alt = self._hp\n        self.hp += menge\n        geheilt = self._hp - alt\n        print(f\"ğŸ’š {self.name} heilt {geheilt} HP! ({self._hp}/{self._max_hp})\")\n    \n    def ausrÃ¼sten(self, item_name: str):\n        \"\"\"RÃ¼stet Item aus Inventar aus\"\"\"\n        item = self.inventar.finde(item_name)\n        \n        if not item:\n            print(f\"âŒ {item_name} nicht im Inventar!\")\n            return\n        \n        if item.typ == \"waffe\":\n            if self.waffe:\n                self.inventar.hinzufÃ¼gen(self.waffe)\n            self.waffe = item\n            self.inventar.entfernen(item_name)\n            print(f\"âš”ï¸ {item_name} ausgerÃ¼stet!\")\n            \n        elif item.typ == \"rÃ¼stung\":\n            if self.rÃ¼stung:\n                self.inventar.hinzufÃ¼gen(self.rÃ¼stung)\n            self.rÃ¼stung = item\n            self.inventar.entfernen(item_name)\n            print(f\"ğŸ›¡ï¸ {item_name} ausgerÃ¼stet!\")\n    \n    def status(self):\n        \"\"\"Zeigt Status\"\"\"\n        print(f\"\\n{'=' * 60}\")\n        print(f\"ğŸ‘¤ {self.name} - {self.klasse} (Level {self.level})\")\n        print(f\"{'=' * 60}\")\n        print(f\"â¤ï¸  HP: {self._hp}/{self._max_hp}\")\n        print(f\"ğŸ’™ Mana: {self._mana}/{self._max_mana}\")\n        print(f\"âœ¨ EXP: {self._exp}/{self._exp_fÃ¼r_next_level}\")\n        print(f\"âš”ï¸  Angriff: {self.angriff_total} ({self._angriff} + {self.waffe.wert if self.waffe else 0})\")\n        print(f\"ğŸ›¡ï¸  Verteidigung: {self.verteidigung_total} ({self._verteidigung} + {self.rÃ¼stung.wert if self.rÃ¼stung else 0})\")\n        \n        print(f\"\\nğŸ“¦ AusrÃ¼stung:\")\n        print(f\"   Waffe: {self.waffe if self.waffe else 'Keine'}\")\n        print(f\"   RÃ¼stung: {self.rÃ¼stung if self.rÃ¼stung else 'Keine'}\")\n    \n    def __str__(self):\n        return f\"{self.name} (Lv.{self.level} {self.klasse})\"\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"ğŸ® RPG CHARAKTER-SYSTEM\")\nprint(\"=\" * 60)\n\n# Charakter erstellen\nheld = Charakter(\"Arathorn\", \"Krieger\")\nmagier = Charakter(\"Gandalf\", \"Magier\")\n\n# Status anzeigen\nheld.status()\n\n# Items finden\nprint(\"\\nğŸ Items gefunden:\")\nschwert = Item(\"Eisenschwert\", \"waffe\", 15)\nrÃ¼stung = Item(\"KettenrÃ¼stung\", \"rÃ¼stung\", 10)\ntrank = Item(\"Heiltrank\", \"trank\", 50)\n\nheld.inventar.hinzufÃ¼gen(schwert)\nheld.inventar.hinzufÃ¼gen(rÃ¼stung)\nheld.inventar.hinzufÃ¼gen(trank)\n\n# Inventar anzeigen\nheld.inventar.anzeigen()\n\n# AusrÃ¼sten\nprint(\"\\nâš”ï¸ AusrÃ¼sten:\")\nheld.ausrÃ¼sten(\"Eisenschwert\")\nheld.ausrÃ¼sten(\"KettenrÃ¼stung\")\n\nheld.status()\n\n# Kampf\nprint(\"\\nâš”ï¸ KAMPF:\")\ngoblin = Charakter(\"Goblin\", \"Monster\")\ngoblin._level = 3\ngoblin._hp = 50\ngoblin._angriff = 8\n\nprint(f\"\\n{held} vs {goblin}\")\n\nwhile held.ist_am_leben and goblin.ist_am_leben:\n    held.angreifen(goblin)\n    if goblin.ist_am_leben:\n        goblin.angreifen(held)\n    print()\n\nprint(f\"\\nğŸ† Kampf beendet!\")\nheld.status()",
                                "checkpoint": " - Komplexes OOP-System mit mehreren Classes - Properties fÃ¼r kontrollierte Attribute - Private Methoden fÃ¼r interne Logik - Objekt-Interaktion (Kampf, Inventar) - Class Variables fÃ¼r globale Stats"
                        }
                ]
        },
        {
                "id": 3,
                "weekId": 3,
                "title": "Tier-Hierarchie (Vererbung)",
                "duration": "45-60 min",
                "task": {
                        "title": "Tier-Hierarchie (Vererbung)",
                        "description": "Lerne Vererbung (Inheritance) - eines der mÃ¤chtigsten OOP-Konzepte!",
                        "goals": [
                                "Vererbung: `class Kind(Parent):`",
                                "super(): Parent-Methoden aufrufen",
                                "Method Overriding: Parent-Methoden Ã¼berschreiben",
                                "Polymorphismus: Gleicher Aufruf, unterschiedliches Verhalten",
                                "Mehrfachvererbung: Mehrere Parents",
                                "Abstract Classes: Nicht-instanziierbare Basis-Klassen",
                                "@abstractmethod: Erzwinge Implementation",
                                "isinstance(): Typ-Hierarchie prÃ¼fen"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Vererbung Grundlagen",
                                "goal": "Verstehen wie Vererbung funktioniert",
                                "why": "",
                                "instruction": "",
                                "code": "# OHNE VERERBUNG - Code-Duplikation! ğŸ˜±\nclass Hund:\n    def __init__(self, name):\n        self.name = name\n        self.alter = 0\n    \n    def fressen(self):\n        print(f\"{self.name} frisst\")\n    \n    def schlafen(self):\n        print(f\"{self.name} schlÃ¤ft\")\n    \n    def bellen(self):\n        print(f\"{self.name}: Wuff!\")\n\nclass Katze:\n    def __init__(self, name):\n        self.name = name\n        self.alter = 0\n    \n    def fressen(self):  # Duplikat!\n        print(f\"{self.name} frisst\")\n    \n    def schlafen(self):  # Duplikat!\n        print(f\"{self.name} schlÃ¤ft\")\n    \n    def miauen(self):\n        print(f\"{self.name}: Miau!\")\n\n# MIT VERERBUNG - DRY (Don't Repeat Yourself)! ğŸ˜Š\n\nclass Tier:\n    \"\"\"Basis-Klasse fÃ¼r alle Tiere\"\"\"\n    \n    def __init__(self, name, art):\n        self.name = name\n        self.art = art\n        self.alter = 0\n    \n    def fressen(self):\n        print(f\"{self.name} ({self.art}) frisst\")\n    \n    def schlafen(self):\n        print(f\"{self.name} ({self.art}) schlÃ¤ft\")\n    \n    def __str__(self):\n        return f\"{self.name} ({self.art}, {self.alter} Jahre alt)\"\n\n# Hund ERBT von Tier\nclass Hund(Tier):  # Tier in Klammern = Parent-Class\n    \"\"\"Spezialisierte Tier-Klasse fÃ¼r Hunde\"\"\"\n    \n    def __init__(self, name, rasse):\n        # super() ruft Parent-Class-Methode auf\n        super().__init__(name, art=\"Hund\")\n        self.rasse = rasse\n    \n    def bellen(self):\n        \"\"\"Hunde-spezifische Methode\"\"\"\n        print(f\"{self.name}: Wuff! Wuff!\")\n    \n    def apportieren(self):\n        print(f\"{self.name} apportiert den Ball!\")\n\nclass Katze(Tier):\n    \"\"\"Spezialisierte Tier-Klasse fÃ¼r Katzen\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name, art=\"Katze\")\n    \n    def miauen(self):\n        \"\"\"Katzen-spezifische Methode\"\"\"\n        print(f\"{self.name}: Miau!\")\n    \n    def kratzen(self):\n        print(f\"{self.name} kratzt am Sofa!\")\n\n# TESTEN\nprint(\"=\" * 60)\nprint(\"ğŸ¾ VERERBUNG - TIER-HIERARCHIE\")\nprint(\"=\" * 60)\n\n# Erstelle Tiere\nbello = Hund(\"Bello\", \"Golden Retriever\")\nmimi = Katze(\"Mimi\")\n\nprint(f\"\\n{bello}\")\nprint(f\"{mimi}\")\n\n# Gemeinsame Methoden (von Tier geerbt)\nprint(\"\\nğŸ– Gemeinsame Aktionen:\")\nbello.fressen()\nmimi.fressen()\n\n# Spezifische Methoden\nprint(\"\\nğŸ”Š Spezifische Aktionen:\")\nbello.bellen()\nbello.apportieren()\n\nmimi.miauen()\nmimi.kratzen()\n\n# Instanz-PrÃ¼fung\nprint(\"\\nğŸ” Typ-PrÃ¼fung:\")\nprint(f\"bello ist ein Hund? {isinstance(bello, Hund)}\")  # True\nprint(f\"bello ist ein Tier? {isinstance(bello, Tier)}\")  # True!\nprint(f\"bello ist eine Katze? {isinstance(bello, Katze)}\")  # False\n\nprint(f\"mimi ist eine Katze? {isinstance(mimi, Katze)}\")  # True\nprint(f\"mimi ist ein Tier? {isinstance(mimi, Tier)}\")  # True!",
                                "checkpoint": " - `class Kind(Eltern):` erstellt Vererbung - Kind-Klasse erbt alle Methoden/Attribute - `super()` ruft Parent-Methode auf - `isinstance()` prÃ¼ft Typ-Hierarchie"
                        },
                        {
                                "number": 2,
                                "title": "Method Overriding",
                                "goal": "Parent-Methoden in Kind-Klasse Ã¼berschreiben",
                                "why": "Spezialisiertes Verhalten fÃ¼r verschiedene Typen!",
                                "instruction": "",
                                "code": "class Tier:\n    def __init__(self, name):\n        self.name = name\n    \n    def laut_geben(self):\n        \"\"\"Basis-Implementation - wird Ã¼berschrieben\"\"\"\n        print(f\"{self.name} macht ein GerÃ¤usch\")\n    \n    def bewegen(self):\n        print(f\"{self.name} bewegt sich\")\n\nclass Hund(Tier):\n    def laut_geben(self):  # ÃœBERSCHREIBT Tier.laut_geben()\n        \"\"\"Spezialisierte Version fÃ¼r Hunde\"\"\"\n        print(f\"{self.name}: Wuff! Wuff!\")\n    \n    def bewegen(self):  # ÃœBERSCHREIBT und ERWEITERT\n        \"\"\"Ruft Parent-Methode auf UND fÃ¼gt hinzu\"\"\"\n        super().bewegen()  # Ruft Tier.bewegen() auf\n        print(f\"{self.name} wedelt mit dem Schwanz\")  # ZusÃ¤tzlich\n\nclass Katze(Tier):\n    def laut_geben(self):  # ÃœBERSCHREIBT\n        print(f\"{self.name}: Miau!\")\n\nclass Vogel(Tier):\n    def laut_geben(self):  # ÃœBERSCHREIBT\n        print(f\"{self.name}: Piep!\")\n    \n    def bewegen(self):  # KOMPLETT NEU\n        print(f\"{self.name} fliegt durch die Luft\")\n\n# POLYMORPHISMUS - Gleiche Methode, unterschiedliches Verhalten\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ”„ METHOD OVERRIDING & POLYMORPHISMUS\")\nprint(\"=\" * 60)\n\ntiere = [\n    Hund(\"Bello\"),\n    Katze(\"Mimi\"),\n    Vogel(\"Tweety\")\n]\n\nprint(\"\\nğŸ”Š Alle Tiere machen Laute:\")\nfor tier in tiere:\n    tier.laut_geben()  # Jedes ruft SEINE Version auf!\n\nprint(\"\\nğŸƒ Alle Tiere bewegen sich:\")\nfor tier in tiere:\n    tier.bewegen()",
                                "checkpoint": " - Methode mit gleichem Namen Ã¼berschreibt Parent-Version - `super().methode()` ruft Parent-Version auf - Polymorphismus: Gleicher Aufruf, unterschiedliches Verhalten"
                        },
                        {
                                "number": 3,
                                "title": "Mehrfachvererbung",
                                "goal": "Von mehreren Parent-Classes erben",
                                "why": "Manchmal braucht man Eigenschaften von mehreren Quellen!",
                                "instruction": "",
                                "code": "# Mehrere Parent-Classes\n\nclass Schwimmer:\n    \"\"\"Mixin fÃ¼r schwimmende FÃ¤higkeiten\"\"\"\n    \n    def schwimmen(self):\n        print(f\"{self.name} schwimmt\")\n\nclass Flieger:\n    \"\"\"Mixin fÃ¼r fliegende FÃ¤higkeiten\"\"\"\n    \n    def fliegen(self):\n        print(f\"{self.name} fliegt\")\n\nclass LÃ¤ufer:\n    \"\"\"Mixin fÃ¼r laufende FÃ¤higkeiten\"\"\"\n    \n    def laufen(self):\n        print(f\"{self.name} lÃ¤uft\")\n\n# Tier mit einer FÃ¤higkeit\nclass Fisch(Tier, Schwimmer):\n    \"\"\"Erbt von Tier UND Schwimmer\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name)\n\n# Tier mit zwei FÃ¤higkeiten\nclass Ente(Tier, Schwimmer, Flieger):\n    \"\"\"Erbt von Tier, Schwimmer UND Flieger\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name)\n    \n    def quaken(self):\n        print(f\"{self.name}: Quak!\")\n\n# Tier mit drei FÃ¤higkeiten\nclass Pinguin(Tier, Schwimmer, LÃ¤ufer):\n    \"\"\"Kann schwimmen und laufen, aber NICHT fliegen\"\"\"\n    \n    def __init__(self, name):\n        super().__init__(name)\n\n# TESTEN\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸŒŠ MEHRFACHVERERBUNG\")\nprint(\"=\" * 60)\n\nnemo = Fisch(\"Nemo\")\ndonald = Ente(\"Donald\")\ntux = Pinguin(\"Tux\")\n\nprint(\"\\nğŸŸ Fisch (nur schwimmen):\")\nnemo.schwimmen()\n# nemo.fliegen()  # Fehler! Fisch kann nicht fliegen\n\nprint(\"\\nğŸ¦† Ente (schwimmen + fliegen):\")\ndonald.schwimmen()\ndonald.fliegen()\ndonald.quaken()\n\nprint(\"\\nğŸ§ Pinguin (schwimmen + laufen):\")\ntux.schwimmen()\ntux.laufen()\n# tux.fliegen()  # Fehler! Pinguin kann nicht fliegen\n\n# MRO (Method Resolution Order) - In welcher Reihenfolge werden Parents gesucht?\nprint(\"\\nğŸ“‹ Method Resolution Order:\")\nprint(f\"Ente MRO: {[cls.__name__ for cls in Ente.__mro__]}\")",
                                "checkpoint": " - `class Kind(Parent1, Parent2, ...)` fÃ¼r Mehrfachvererbung - Mixins sind Classes die FÃ¤higkeiten hinzufÃ¼gen - MRO bestimmt Reihenfolge der Parent-Suche"
                        },
                        {
                                "number": 4,
                                "title": "VollstÃ¤ndige Tier-Hierarchie",
                                "goal": "Komplexes System mit Vererbung aufbauen",
                                "why": "Real-World Beispiel mit allen Konzepten!",
                                "instruction": "",
                                "code": "from abc import ABC, abstractmethod\nfrom typing import List\n\n# ABSTRAKTE BASIS-KLASSE\nclass Tier(ABC):\n    \"\"\"\n    Abstrakte Basis-Klasse fÃ¼r alle Tiere\n    ABC = Abstract Base Class\n    Kann nicht direkt instanziiert werden!\n    \"\"\"\n    \n    def __init__(self, name: str, alter: int, gewicht: float):\n        self.name = name\n        self.alter = alter\n        self.gewicht = gewicht  # in kg\n        self.hunger = 50  # 0-100\n        self.gesundheit = 100  # 0-100\n    \n    @abstractmethod\n    def laut_geben(self):\n        \"\"\"MUSS von Subklassen implementiert werden!\"\"\"\n        pass\n    \n    @abstractmethod\n    def nahrung(self) -> str:\n        \"\"\"MUSS von Subklassen implementiert werden!\"\"\"\n        pass\n    \n    def fressen(self, menge: int = 30):\n        \"\"\"Gemeinsame Methode fÃ¼r alle Tiere\"\"\"\n        self.hunger = max(0, self.hunger - menge)\n        print(f\"{self.name} frisst {self.nahrung()}. Hunger: {self.hunger}\")\n    \n    def altern(self):\n        \"\"\"Altert um 1 Jahr\"\"\"\n        self.alter += 1\n        self.gesundheit = max(0, self.gesundheit - 5)\n        print(f\"{self.name} ist jetzt {self.alter} Jahre alt\")\n    \n    def status(self):\n        \"\"\"Zeigt Status\"\"\"\n        print(f\"\\n{'='*50}\")\n        print(f\"ğŸ¾ {self.name} ({self.__class__.__name__})\")\n        print(f\"{'='*50}\")\n        print(f\"Alter: {self.alter} Jahre\")\n        print(f\"Gewicht: {self.gewicht} kg\")\n        print(f\"Hunger: {self.hunger}/100\")\n        print(f\"Gesundheit: {self.gesundheit}/100\")\n    \n    def __str__(self):\n        return f\"{self.name} ({self.__class__.__name__}, {self.alter}J)\"\n\n# SÃ„UGETIERE\nclass SÃ¤ugetier(Tier):\n    \"\"\"Basis fÃ¼r alle SÃ¤ugetiere\"\"\"\n    \n    def __init__(self, name, alter, gewicht, fellfarbe):\n        super().__init__(name, alter, gewicht)\n        self.fellfarbe = fellfarbe\n    \n    def sÃ¤ugen(self):\n        print(f\"{self.name} sÃ¤ugt ihre Jungen\")\n\nclass Hund(SÃ¤ugetier):\n    def __init__(self, name, alter, gewicht, fellfarbe, rasse):\n        super().__init__(name, alter, gewicht, fellfarbe)\n        self.rasse = rasse\n        self.loyalitÃ¤t = 100\n    \n    def laut_geben(self):\n        print(f\"{self.name}: Wuff! Wuff!\")\n    \n    def nahrung(self) -> str:\n        return \"Hundefutter\"\n    \n    def apportieren(self):\n        self.loyalitÃ¤t = min(100, self.loyalitÃ¤t + 5)\n        print(f\"{self.name} apportiert! LoyalitÃ¤t: {self.loyalitÃ¤t}\")\n\nclass Katze(SÃ¤ugetier):\n    def __init__(self, name, alter, gewicht, fellfarbe):\n        super().__init__(name, alter, gewicht, fellfarbe)\n        self.unabhÃ¤ngigkeit = 80\n    \n    def laut_geben(self):\n        print(f\"{self.name}: Miau!\")\n    \n    def nahrung(self) -> str:\n        return \"Katzenfutter\"\n    \n    def schnurren(self):\n        print(f\"{self.name} schnurrt zufrieden\")\n\n# VÃ–GEL\nclass Vogel(Tier):\n    \"\"\"Basis fÃ¼r alle VÃ¶gel\"\"\"\n    \n    def __init__(self, name, alter, gewicht, kann_fliegen=True):\n        super().__init__(name, alter, gewicht)\n        self.kann_fliegen = kann_fliegen\n        self.flÃ¼gelspannweite = gewicht * 0.3  # Vereinfacht\n    \n    def nahrung(self) -> str:\n        return \"KÃ¶rner\"\n    \n    def fliegen(self):\n        if self.kann_fliegen:\n            print(f\"{self.name} fliegt durch die Luft\")\n        else:\n            print(f\"{self.name} kann nicht fliegen!\")\n\nclass Papagei(Vogel):\n    def __init__(self, name, alter, gewicht):\n        super().__init__(name, alter, gewicht, kann_fliegen=True)\n        self.vokabular = []\n    \n    def laut_geben(self):\n        if self.vokabular:\n            import random\n            wort = random.choice(self.vokabular)\n            print(f\"{self.name}: {wort}!\")\n        else:\n            print(f\"{self.name}: KrÃ¤chz!\")\n    \n    def wort_lernen(self, wort: str):\n        self.vokabular.append(wort)\n        print(f\"{self.name} hat '{wort}' gelernt!\")\n\nclass Pinguin(Vogel):\n    def __init__(self, name, alter, gewicht):\n        super().__init__(name, alter, gewicht, kann_fliegen=False)\n    \n    def laut_geben(self):\n        print(f\"{self.name}: Gack!\")\n    \n    def nahrung(self) -> str:\n        return \"Fisch\"\n    \n    def schwimmen(self):\n        print(f\"{self.name} schwimmt elegant durch das Wasser\")\n\n# ZOO-VERWALTUNG\nclass Zoo:\n    \"\"\"Verwaltet eine Sammlung von Tieren\"\"\"\n    \n    def __init__(self, name: str):\n        self.name = name\n        self.tiere: List[Tier] = []\n    \n    def tier_hinzufÃ¼gen(self, tier: Tier):\n        self.tiere.append(tier)\n        print(f\"âœ… {tier} wurde dem Zoo hinzugefÃ¼gt\")\n    \n    def alle_fÃ¼ttern(self):\n        print(f\"\\nğŸ– FÃ¼tterungszeit im {self.name}!\")\n        for tier in self.tiere:\n            tier.fressen()\n    \n    def konzert(self):\n        print(f\"\\nğŸµ Tier-Konzert im {self.name}!\")\n        for tier in self.tiere:\n            tier.laut_geben()\n    \n    def tiere_nach_typ(self, typ):\n        \"\"\"Filtert Tiere nach Typ\"\"\"\n        return [t for t in self.tiere if isinstance(t, typ)]\n    \n    def statistik(self):\n        \"\"\"Zeigt Zoo-Statistiken\"\"\"\n        print(f\"\\nğŸ“Š {self.name} - STATISTIK\")\n        print(f\"{'='*50}\")\n        print(f\"Tiere gesamt: {len(self.tiere)}\")\n        \n        # Nach Typ gruppieren\n        typen = {}\n        for tier in self.tiere:\n            typ_name = tier.__class__.__name__\n            typen[typ_name] = typen.get(typ_name, 0) + 1\n        \n        print(\"\\nNach Typ:\")\n        for typ, anzahl in sorted(typen.items()):\n            print(f\"  {typ}: {anzahl}\")\n        \n        # Ã„ltestes/JÃ¼ngstes\n        if self.tiere:\n            Ã¤ltestes = max(self.tiere, key=lambda t: t.alter)\n            jÃ¼ngstes = min(self.tiere, key=lambda t: t.alter)\n            print(f\"\\nÃ„ltestes: {Ã¤ltestes.name} ({Ã¤ltestes.alter}J)\")\n            print(f\"JÃ¼ngstes: {jÃ¼ngstes.name} ({jÃ¼ngstes.alter}J)\")\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"ğŸ¦ ZOO-SIMULATOR MIT VERERBUNG\")\nprint(\"=\" * 60)\n\n# Zoo erstellen\nmein_zoo = Zoo(\"Tierpark Berlin\")\n\n# Tiere erstellen\nbello = Hund(\"Bello\", 5, 25, \"braun\", \"Golden Retriever\")\nmimi = Katze(\"Mimi\", 3, 4, \"orange\")\ntweety = Papagei(\"Tweety\", 2, 0.5)\ntux = Pinguin(\"Tux\", 4, 15)\n\n# Zum Zoo hinzufÃ¼gen\nmein_zoo.tier_hinzufÃ¼gen(bello)\nmein_zoo.tier_hinzufÃ¼gen(mimi)\nmein_zoo.tier_hinzufÃ¼gen(tweety)\nmein_zoo.tier_hinzufÃ¼gen(tux)\n\n# Papagei trainieren\nprint(\"\\nğŸ¦œ Papagei-Training:\")\ntweety.wort_lernen(\"Hallo\")\ntweety.wort_lernen(\"Python\")\ntweety.wort_lernen(\"Lernen\")\n\n# Tier-Konzert\nmein_zoo.konzert()\n\n# FÃ¼ttern\nmein_zoo.alle_fÃ¼ttern()\n\n# Spezielle Aktionen\nprint(\"\\nğŸ¾ Spezielle Aktionen:\")\nbello.apportieren()\nmimi.schnurren()\ntweety.fliegen()\ntux.schwimmen()\ntux.fliegen()  # Pinguin kann nicht fliegen!\n\n# Statistiken\nmein_zoo.statistik()\n\n# Nur SÃ¤ugetiere\nprint(\"\\nğŸ¾ Nur SÃ¤ugetiere:\")\nsÃ¤ugetiere = mein_zoo.tiere_nach_typ(SÃ¤ugetier)\nfor s in sÃ¤ugetiere:\n    print(f\"  - {s}\")\n\n# Status einzelnes Tier\nbello.status()",
                                "checkpoint": " - ABC (Abstract Base Class) fÃ¼r nicht-instanziierbare Basis - `@abstractmethod` erzwingt Implementation in Subklassen - Mehrere Vererbungs-Ebenen (Tier â†’ SÃ¤ugetier â†’ Hund) - Polymorphismus in Zoo-Klasse - Type Filtering mit `isinstance()`"
                        }
                ]
        },
        {
                "id": 4,
                "weekId": 3,
                "title": "Ordner-Organizer (OS-Modul)",
                "duration": "45-60 min",
                "task": {
                        "title": "Ordner-Organizer (OS-Modul)",
                        "description": "Lerne das OS-Modul kennen und erstelle einen automatischen Ordner-Organizer!",
                        "goals": [
                                "os.getcwd(): Aktuelles Verzeichnis",
                                "os.listdir(): Inhalte auflisten",
                                "os.path.join(): Pfade kombinieren",
                                "os.makedirs(): Ordner erstellen",
                                "os.rename(): Umbenennen",
                                "os.remove(): LÃ¶schen",
                                "os.walk(): Rekursiv durchlaufen",
                                "os.path Funktionen: basename, dirname, splitext, etc.",
                                "shutil: Kopieren/Verschieben"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "OS-Modul Grundlagen",
                                "goal": "Verstehen wie man mit dem Betriebssystem interagiert",
                                "why": "Datei- und Ordner-Operationen sind essentiell fÃ¼r praktische Programme!",
                                "instruction": "",
                                "code": "import os\n\nprint(\"=\" * 60)\nprint(\"ğŸ“ OS-MODUL GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# AKTUELLES VERZEICHNIS\naktuell = os.getcwd()  # Get Current Working Directory\nprint(f\"\\nğŸ“ Aktuelles Verzeichnis:\\n{aktuell}\")\n\n# VERZEICHNIS WECHSELN (Vorsicht!)\n# os.chdir(\"/pfad/zum/ordner\")  # Change Directory\n\n# DATEIEN UND ORDNER AUFLISTEN\nprint(f\"\\nğŸ“‚ Inhalt des aktuellen Verzeichniss:\")\ninhalt = os.listdir()  # Listet alles auf\nfor item in inhalt[:10]:  # Nur erste 10\n    print(f\"  - {item}\")\n\n# PFADE ZUSAMMENBAUEN (WICHTIG: Funktioniert auf allen OS!)\n# Windows: \\ (Backslash)\n# Mac/Linux: / (Forward slash)\n# os.path.join() macht es automatisch richtig!\n\n# FALSCH (funktioniert nur auf einem OS):\n# pfad = \"ordner1\\ordner2\\datei.txt\"  # Nur Windows\n\n# RICHTIG (funktioniert Ã¼berall):\npfad = os.path.join(\"ordner1\", \"ordner2\", \"datei.txt\")\nprint(f\"\\nğŸ”— Zusammengesetzter Pfad:\\n{pfad}\")\n\n# PFAD-INFORMATIONEN\nbeispiel_datei = __file__  # Aktuelles Script\n\nprint(f\"\\nğŸ“„ Pfad-Analyse von '{os.path.basename(beispiel_datei)}':\")\nprint(f\"Kompletter Pfad: {os.path.abspath(beispiel_datei)}\")\nprint(f\"Verzeichnis: {os.path.dirname(beispiel_datei)}\")\nprint(f\"Dateiname: {os.path.basename(beispiel_datei)}\")\nprint(f\"Ohne Endung: {os.path.splitext(beispiel_datei)[0]}\")\nprint(f\"Nur Endung: {os.path.splitext(beispiel_datei)[1]}\")\n\n# PRÃœFUNGEN\nprint(f\"\\nâœ… Existenz-PrÃ¼fungen:\")\nprint(f\"Datei existiert? {os.path.exists(beispiel_datei)}\")\nprint(f\"Ist Datei? {os.path.isfile(beispiel_datei)}\")\nprint(f\"Ist Ordner? {os.path.isdir(beispiel_datei)}\")\n\n# Test-Ordner prÃ¼fen\nprint(f\"\\nAktuelles Verzeichnis ist Ordner? {os.path.isdir(aktuell)}\")",
                                "checkpoint": " - `os.getcwd()` â†’ Aktuelles Verzeichnis - `os.listdir()` â†’ Inhalt auflisten - `os.path.join()` â†’ Pfade OS-unabhÃ¤ngig zusammenbauen - `os.path.exists()` â†’ PrÃ¼fen ob existiert - `os.path.isfile()` / `os.path.isdir()` â†’ Typ prÃ¼fen"
                        },
                        {
                                "number": 2,
                                "title": "Ordner und Dateien erstellen/lÃ¶schen",
                                "goal": "Dateisystem manipulieren",
                                "why": "Programme mÃ¼ssen oft Ordner erstellen, Dateien verschieben, etc.!",
                                "instruction": "",
                                "code": "import os\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ“ DATEISYSTEM MANIPULIEREN\")\nprint(\"=\" * 60)\n\n# Test-Verzeichnis erstellen\ntest_ordner = \"test_os_operationen\"\n\n# ORDNER ERSTELLEN\nif not os.path.exists(test_ordner):\n    os.mkdir(test_ordner)  # Erstellt einen Ordner\n    print(f\"âœ… Ordner '{test_ordner}' erstellt\")\nelse:\n    print(f\"â„¹ï¸ Ordner '{test_ordner}' existiert bereits\")\n\n# VERSCHACHTELTE ORDNER ERSTELLEN\n# mkdir() schlÃ¤gt fehl wenn Parent nicht existiert\n# makedirs() erstellt alle fehlenden Parents\n\nverschachtelt = os.path.join(test_ordner, \"sub1\", \"sub2\", \"sub3\")\nos.makedirs(verschachtelt, exist_ok=True)  # exist_ok=True verhindert Fehler wenn existiert\nprint(f\"âœ… Verschachtelte Ordner erstellt: {verschachtelt}\")\n\n# DATEI ERSTELLEN\ntest_datei = os.path.join(test_ordner, \"test.txt\")\nwith open(test_datei, \"w\") as f:\n    f.write(\"Test-Inhalt\")\nprint(f\"âœ… Datei erstellt: {test_datei}\")\n\n# DATEI UMBENENNEN\nalter_name = test_datei\nneuer_name = os.path.join(test_ordner, \"umbenannt.txt\")\nos.rename(alter_name, neuer_name)\nprint(f\"âœ… Umbenannt: {os.path.basename(alter_name)} â†’ {os.path.basename(neuer_name)}\")\n\n# DATEI-INFORMATIONEN\nprint(f\"\\nğŸ“Š Datei-Info fÃ¼r '{os.path.basename(neuer_name)}':\")\nstats = os.stat(neuer_name)\nprint(f\"GrÃ¶ÃŸe: {stats.st_size} Bytes\")\nprint(f\"Erstellt: {stats.st_ctime}\")\nprint(f\"GeÃ¤ndert: {stats.st_mtime}\")\n\n# ALLE DATEIEN IN EINEM ORDNER\nprint(f\"\\nğŸ“‚ Alle Dateien in '{test_ordner}':\")\nfor item in os.listdir(test_ordner):\n    pfad = os.path.join(test_ordner, item)\n    typ = \"ğŸ“\" if os.path.isdir(pfad) else \"ğŸ“„\"\n    print(f\"{typ} {item}\")\n\n# ORDNER REKURSIV DURCHLAUFEN\nprint(f\"\\nğŸ” Rekursive Suche in '{test_ordner}':\")\nfor root, dirs, files in os.walk(test_ordner):\n    # root = aktueller Ordner\n    # dirs = Liste von Unterordnern\n    # files = Liste von Dateien\n    ebene = root.replace(test_ordner, \"\").count(os.sep)\n    einrÃ¼ckung = \"  \" * ebene\n    print(f\"{einrÃ¼ckung}ğŸ“ {os.path.basename(root)}/\")\n    \n    sub_einrÃ¼ckung = \"  \" * (ebene + 1)\n    for datei in files:\n        print(f\"{sub_einrÃ¼ckung}ğŸ“„ {datei}\")\n\n# AUFRÃ„UMEN (VORSICHTIG!)\n# NICHT AUSFÃœHREN wenn du Daten behalten willst!\nprint(\"\\nğŸ§¹ AufrÃ¤umen...\")\n\n# Datei lÃ¶schen\nif os.path.exists(neuer_name):\n    os.remove(neuer_name)  # LÃ¶scht Datei\n    print(f\"ğŸ—‘ï¸ Datei gelÃ¶scht: {os.path.basename(neuer_name)}\")\n\n# Leeren Ordner lÃ¶schen\nif os.path.exists(verschachtelt):\n    os.rmdir(verschachtelt)  # LÃ¶scht nur LEERE Ordner\n    print(f\"ğŸ—‘ï¸ Ordner gelÃ¶scht: {os.path.basename(verschachtelt)}\")\n\n# Ordner mit Inhalt lÃ¶schen (gefÃ¤hrlich!)\n# import shutil\n# shutil.rmtree(test_ordner)  # LÃ¶scht ALLES rekursiv!",
                                "checkpoint": " - `os.mkdir()` â†’ Ein Ordner - `os.makedirs()` â†’ Verschachtelte Ordner - `os.rename()` â†’ Umbenennen/Verschieben - `os.remove()` â†’ Datei lÃ¶schen - `os.rmdir()` â†’ Leeren Ordner lÃ¶schen - `os.walk()` â†’ Rekursiv durchlaufen - `os.stat()` â†’ Datei-Metadaten"
                        },
                        {
                                "number": 3,
                                "title": "Ordner-Organizer nach Dateityp",
                                "goal": "Praktisches Tool das Dateien nach Typ sortiert",
                                "why": "Automatisiere das AufrÃ¤umen deines Downloads-Ordners!",
                                "instruction": "",
                                "code": "import os\nimport shutil\nfrom collections import defaultdict\n\nclass OrdnerOrganizer:\n    \"\"\"Organisiert Dateien in einem Ordner nach Dateityp\"\"\"\n    \n    # Dateityp-Kategorien\n    KATEGORIEN = {\n        'Bilder': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp'],\n        'Dokumente': ['.pdf', '.doc', '.docx', '.txt', '.xlsx', '.pptx', '.odt'],\n        'Videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv'],\n        'Musik': ['.mp3', '.wav', '.flac', '.m4a', '.aac'],\n        'Archive': ['.zip', '.rar', '.7z', '.tar', '.gz'],\n        'Code': ['.py', '.js', '.html', '.css', '.java', '.cpp', '.c'],\n        'Sonstiges': []  # Alles andere\n    }\n    \n    def __init__(self, quell_ordner):\n        self.quell_ordner = os.path.abspath(quell_ordner)\n        \n        if not os.path.exists(self.quell_ordner):\n            raise FileNotFoundError(f\"Ordner nicht gefunden: {self.quell_ordner}\")\n    \n    def _ermittle_kategorie(self, dateiname):\n        \"\"\"Bestimmt Kategorie basierend auf Dateierweiterung\"\"\"\n        _, erweiterung = os.path.splitext(dateiname)\n        erweiterung = erweiterung.lower()\n        \n        for kategorie, erweiterungen in self.KATEGORIEN.items():\n            if erweiterung in erweiterungen:\n                return kategorie\n        \n        return 'Sonstiges'\n    \n    def analysieren(self):\n        \"\"\"Analysiert Ordner und zeigt Statistiken\"\"\"\n        stats = defaultdict(list)\n        \n        for item in os.listdir(self.quell_ordner):\n            pfad = os.path.join(self.quell_ordner, item)\n            \n            # Nur Dateien, keine Ordner\n            if os.path.isfile(pfad):\n                kategorie = self._ermittle_kategorie(item)\n                grÃ¶ÃŸe = os.path.getsize(pfad)\n                stats[kategorie].append({\n                    'name': item,\n                    'grÃ¶ÃŸe': grÃ¶ÃŸe,\n                    'pfad': pfad\n                })\n        \n        return stats\n    \n    def bericht(self):\n        \"\"\"Zeigt Analyse-Bericht\"\"\"\n        stats = self.analysieren()\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"ğŸ“Š ORDNER-ANALYSE: {os.path.basename(self.quell_ordner)}\")\n        print(f\"{'='*60}\")\n        \n        gesamt_dateien = sum(len(dateien) for dateien in stats.values())\n        gesamt_grÃ¶ÃŸe = sum(\n            d['grÃ¶ÃŸe'] for dateien in stats.values() for d in dateien\n        )\n        \n        print(f\"\\nDateien gesamt: {gesamt_dateien}\")\n        print(f\"GesamtgrÃ¶ÃŸe: {gesamt_grÃ¶ÃŸe / 1024 / 1024:.2f} MB\")\n        \n        print(f\"\\n{'Kategorie':<15} {'Anzahl':>8} {'GrÃ¶ÃŸe (MB)':>12}\")\n        print(\"-\" * 60)\n        \n        for kategorie, dateien in sorted(stats.items()):\n            if dateien:\n                anzahl = len(dateien)\n                grÃ¶ÃŸe = sum(d['grÃ¶ÃŸe'] for d in dateien) / 1024 / 1024\n                print(f\"{kategorie:<15} {anzahl:>8} {grÃ¶ÃŸe:>12.2f}\")\n        \n        return stats\n    \n    def organisieren(self, modus='kopieren', test_lauf=False):\n        \"\"\"\n        Organisiert Dateien in Unterordner nach Kategorie\n        \n        Args:\n            modus: 'kopieren' oder 'verschieben'\n            test_lauf: Wenn True, nur simulieren ohne Ã„nderungen\n        \"\"\"\n        stats = self.analysieren()\n        \n        if test_lauf:\n            print(f\"\\n{'='*60}\")\n            print(f\"ğŸ§ª TEST-LAUF (keine Ã„nderungen)\")\n            print(f\"{'='*60}\")\n        else:\n            print(f\"\\n{'='*60}\")\n            print(f\"ğŸ—‚ï¸ ORGANISIERE ORDNER ({modus})\")\n            print(f\"{'='*60}\")\n        \n        Ã¤nderungen = 0\n        \n        for kategorie, dateien in stats.items():\n            if not dateien:\n                continue\n            \n            # Ziel-Ordner erstellen\n            ziel_ordner = os.path.join(self.quell_ordner, kategorie)\n            \n            if not test_lauf:\n                os.makedirs(ziel_ordner, exist_ok=True)\n            \n            print(f\"\\nğŸ“ {kategorie}:\")\n            \n            for datei_info in dateien:\n                quelle = datei_info['pfad']\n                ziel = os.path.join(ziel_ordner, datei_info['name'])\n                \n                # PrÃ¼fe ob Datei bereits im Ziel-Ordner ist\n                if os.path.dirname(quelle) == ziel_ordner:\n                    continue\n                \n                print(f\"  {'â†’' if modus == 'verschieben' else 'ğŸ“‹'} {datei_info['name']}\")\n                \n                if not test_lauf:\n                    try:\n                        if modus == 'verschieben':\n                            shutil.move(quelle, ziel)\n                        else:  # kopieren\n                            shutil.copy2(quelle, ziel)\n                        \n                        Ã¤nderungen += 1\n                    except Exception as e:\n                        print(f\"    âŒ Fehler: {e}\")\n        \n        if test_lauf:\n            print(f\"\\nğŸ’¡ {Ã¤nderungen} Dateien wÃ¼rden organisiert werden\")\n            print(\"FÃ¼hre mit test_lauf=False aus um tatsÃ¤chlich zu organisieren\")\n        else:\n            print(f\"\\nâœ… {Ã¤nderungen} Dateien {modus}t\")\n    \n    def duplikate_finden(self):\n        \"\"\"Findet Duplikate basierend auf Dateinamen\"\"\"\n        dateien = {}\n        duplikate = []\n        \n        for item in os.listdir(self.quell_ordner):\n            pfad = os.path.join(self.quell_ordner, item)\n            \n            if os.path.isfile(pfad):\n                name = os.path.splitext(item)[0].lower()\n                \n                if name in dateien:\n                    duplikate.append((dateien[name], pfad))\n                else:\n                    dateien[name] = pfad\n        \n        if duplikate:\n            print(f\"\\n{'='*60}\")\n            print(f\"ğŸ” DUPLIKATE GEFUNDEN\")\n            print(f\"{'='*60}\")\n            \n            for original, duplikat in duplikate:\n                print(f\"\\nğŸ“„ {os.path.basename(original)}\")\n                print(f\"  â†³ {os.path.basename(duplikat)}\")\n        else:\n            print(\"\\nâœ… Keine Duplikate gefunden\")\n        \n        return duplikate\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"ğŸ“ ORDNER-ORGANIZER\")\nprint(\"=\" * 60)\n\n# Test-Umgebung erstellen\ntest_ordner = \"test_organizer\"\nos.makedirs(test_ordner, exist_ok=True)\n\n# Test-Dateien erstellen\ntest_dateien = [\n    \"dokument.pdf\",\n    \"foto1.jpg\",\n    \"foto2.png\",\n    \"musik.mp3\",\n    \"video.mp4\",\n    \"code.py\",\n    \"archiv.zip\",\n    \"notizen.txt\",\n    \"bild.gif\",\n    \"song.wav\"\n]\n\nprint(\"\\nğŸ“ Erstelle Test-Dateien...\")\nfor datei in test_dateien:\n    pfad = os.path.join(test_ordner, datei)\n    with open(pfad, \"w\") as f:\n        f.write(f\"Test-Inhalt fÃ¼r {datei}\")\n\n# Organizer erstellen\norganizer = OrdnerOrganizer(test_ordner)\n\n# Analyse\norganizer.bericht()\n\n# Test-Lauf (simulieren)\norganizer.organisieren(test_lauf=True)\n\n# Wirklich organisieren?\nprint(\"\\n\" + \"=\"*60)\nantwort = input(\"Wirklich organisieren? (j/n): \")\nif antwort.lower() == 'j':\n    organizer.organisieren(modus='verschieben', test_lauf=False)\n    \n    # Nach dem Organisieren nochmal analysieren\n    print(\"\\nğŸ“Š Analyse nach Organisierung:\")\n    organizer.bericht()",
                                "checkpoint": " - Dateien nach Typ kategorisieren - Automatisch Ordner erstellen - Dateien kopieren oder verschieben - Test-Modus zum Simulieren - Statistiken und Berichte"
                        }
                ]
        },
        {
                "id": 5,
                "weekId": 3,
                "title": "Datei-Scanner (Pathlib)",
                "duration": "45-60 min",
                "task": {
                        "title": "Datei-Scanner (Pathlib)",
                        "description": "Lerne Pathlib kennen - die moderne Alternative zu os.path!",
                        "goals": [
                                "Path-Objekte: Moderne Alternative zu Strings",
                                "/ Operator: Elegante Pfad-Kombination",
                                "Eigenschaften: `.name`, `.suffix`, `.stem`, etc.",
                                "Methoden: `.mkdir()`, `.write_text()`, `.read_text()`",
                                ".glob(): Muster-basierte Suche",
                                ".rglob(): Rekursive Suche",
                                ".iterdir(): Inhalt auflisten",
                                "Praktische Tools: Scanner, Analyzer, Filter"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Pathlib Grundlagen",
                                "goal": "Verstehen warum Pathlib besser als os.path ist",
                                "why": "",
                                "instruction": "",
                                "code": "from pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"ğŸ›¤ï¸ PATHLIB - MODERNE PFAD-OPERATIONEN\")\nprint(\"=\" * 60)\n\n# Path-Objekt erstellen\n# Verschiedene Methoden:\n\n# 1. Aktuelles Verzeichnis\naktuell = Path.cwd()  # Current Working Directory\nprint(f\"\\nğŸ“ Aktuelles Verzeichnis:\\n{aktuell}\")\n\n# 2. Home-Verzeichnis des Benutzers\nhome = Path.home()\nprint(f\"\\nğŸ  Home-Verzeichnis:\\n{home}\")\n\n# 3. Pfad aus String\npfad = Path(\"ordner/unterordner/datei.txt\")\nprint(f\"\\nğŸ“„ Pfad-Objekt:\\n{pfad}\")\n\n# 4. Pfade kombinieren mit / Operator (!)\n# Das ist VIEL eleganter als os.path.join()!\nbasis = Path(\"projekte\")\nprojekt = basis / \"python\" / \"mein_script.py\"\nprint(f\"\\nğŸ”— Kombiniert mit / Operator:\\n{projekt}\")\n\n# PFAD-EIGENSCHAFTEN (als Attribute, nicht Funktionen!)\nbeispiel = Path(\"/home/user/dokumente/bericht.pdf\")\n\nprint(f\"\\nğŸ“Š Pfad-Eigenschaften:\")\nprint(f\"Name: {beispiel.name}\")              # bericht.pdf\nprint(f\"Stamm (stem): {beispiel.stem}\")      # bericht\nprint(f\"Suffix: {beispiel.suffix}\")          # .pdf\nprint(f\"Suffixe: {beispiel.suffixes}\")       # ['.pdf']\nprint(f\"Parent: {beispiel.parent}\")          # /home/user/dokumente\nprint(f\"Parents: {list(beispiel.parents)}\")  # Alle Parent-Ordner\nprint(f\"Anchor: {beispiel.anchor}\")          # / (Wurzel)\nprint(f\"Parts: {beispiel.parts}\")            # Alle Teile als Tupel\n\n# VERGLEICH: os.path vs Pathlib\nimport os\n\nprint(f\"\\n{'='*60}\")\nprint(\"VERGLEICH: os.path vs Pathlib\")\nprint(f\"{'='*60}\")\n\ndatei = \"test.txt\"\n\n# Mit os.path (alte Methode)\nos_pfad = os.path.join(\"ordner\", \"unterordner\", datei)\nos_name = os.path.basename(os_pfad)\nos_ohne_ext = os.path.splitext(os_pfad)[0]\n\nprint(\"\\nğŸ“ os.path:\")\nprint(f\"Pfad: {os_pfad}\")\nprint(f\"Name: {os_name}\")\nprint(f\"Ohne Ext: {os_ohne_ext}\")\n\n# Mit Pathlib (neue Methode)\np_pfad = Path(\"ordner\") / \"unterordner\" / datei\np_name = p_pfad.name\np_ohne_ext = p_pfad.stem\n\nprint(\"\\nğŸ“ Pathlib:\")\nprint(f\"Pfad: {p_pfad}\")\nprint(f\"Name: {p_name}\")\nprint(f\"Ohne Ext: {p_ohne_ext}\")\n\n# Welche ist lesbarer? Pathlib! ğŸ˜Š",
                                "checkpoint": " - `Path()` erstellt Path-Objekt - `/` Operator kombiniert Pfade - Eigenschaften als Attribute (`.name`, `.suffix`, etc.) - Viel lesbarer als os.path!"
                        },
                        {
                                "number": 2,
                                "title": "Dateisystem-Operationen mit Pathlib",
                                "goal": "Dateien und Ordner mit Pathlib manipulieren",
                                "why": "Pathlib kann fast alles was os kann - nur eleganter!",
                                "instruction": "",
                                "code": "from pathlib import Path\nimport time\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ”§ DATEISYSTEM-OPERATIONEN MIT PATHLIB\")\nprint(\"=\" * 60)\n\n# Test-Umgebung\ntest_basis = Path(\"test_pathlib\")\ntest_basis.mkdir(exist_ok=True)  # Ordner erstellen\nprint(f\"âœ… Basis-Ordner erstellt: {test_basis}\")\n\n# VERSCHACHTELTE ORDNER\ntief = test_basis / \"ebene1\" / \"ebene2\" / \"ebene3\"\ntief.mkdir(parents=True, exist_ok=True)  # parents=True wie os.makedirs()\nprint(f\"âœ… Verschachtelte Ordner: {tief}\")\n\n# DATEIEN ERSTELLEN\ndateien = [\n    test_basis / \"dokument.txt\",\n    test_basis / \"bild.jpg\",\n    test_basis / \"daten.json\",\n    tief / \"tief.txt\"\n]\n\nfor datei in dateien:\n    datei.write_text(f\"Inhalt von {datei.name}\")  # Schreibt Text\n    print(f\"âœ… Datei erstellt: {datei.name}\")\n\n# EXISTENZ PRÃœFEN\nprint(f\"\\nâœ… Existenz-PrÃ¼fungen:\")\nprint(f\"Basis existiert? {test_basis.exists()}\")\nprint(f\"Ist Ordner? {test_basis.is_dir()}\")\nprint(f\"Ist Datei? {test_basis.is_file()}\")\n\ntest_datei = test_basis / \"dokument.txt\"\nprint(f\"\\n'{test_datei.name}' existiert? {test_datei.exists()}\")\nprint(f\"Ist Datei? {test_datei.is_file()}\")\n\n# DATEI LESEN/SCHREIBEN\nprint(f\"\\nğŸ“ Datei-Operationen:\")\n\n# Schreiben\ntest_datei.write_text(\"Neuer Inhalt!\")\nprint(f\"âœ… Text geschrieben\")\n\n# Lesen\ninhalt = test_datei.read_text()\nprint(f\"ğŸ“– Gelesen: '{inhalt}'\")\n\n# Bytes schreiben/lesen\nbinÃ¤r_datei = test_basis / \"binary.dat\"\nbinÃ¤r_datei.write_bytes(b'\\x00\\x01\\x02\\x03')\ndaten = binÃ¤r_datei.read_bytes()\nprint(f\"ğŸ“¦ BinÃ¤r: {daten}\")\n\n# DATEI-INFORMATIONEN\nprint(f\"\\nğŸ“Š Datei-Info fÃ¼r '{test_datei.name}':\")\nstats = test_datei.stat()\nprint(f\"GrÃ¶ÃŸe: {stats.st_size} Bytes\")\nprint(f\"Erstellt: {time.ctime(stats.st_ctime)}\")\nprint(f\"GeÃ¤ndert: {time.ctime(stats.st_mtime)}\")\n\n# UMBENENNEN\nalt = test_datei\nneu = test_basis / \"umbenannt.txt\"\nalt.rename(neu)\nprint(f\"\\nâœ… Umbenannt: {alt.name} â†’ {neu.name}\")\n\n# VERSCHIEBEN (rename funktioniert auch fÃ¼r Verschieben!)\nziel_ordner = test_basis / \"verschoben\"\nziel_ordner.mkdir(exist_ok=True)\nverschoben = neu.rename(ziel_ordner / neu.name)\nprint(f\"âœ… Verschoben nach: {verschoben.parent.name}/\")\n\n# ORDNER-INHALT AUFLISTEN\nprint(f\"\\nğŸ“‚ Inhalt von '{test_basis.name}':\")\nfor item in test_basis.iterdir():  # Wie os.listdir(), aber besser\n    typ = \"ğŸ“\" if item.is_dir() else \"ğŸ“„\"\n    print(f\"{typ} {item.name}\")\n\n# REKURSIV SUCHEN\nprint(f\"\\nğŸ” Alle .txt Dateien (rekursiv):\")\nfor txt_datei in test_basis.rglob(\"*.txt\"):  # rglob = rekursives glob\n    print(f\"  ğŸ“„ {txt_datei.relative_to(test_basis)}\")\n\n# AUFRÃ„UMEN\nprint(f\"\\nğŸ§¹ AufrÃ¤umen...\")\n# Datei lÃ¶schen\nif verschoben.exists():\n    verschoben.unlink()  # unlink() = lÃ¶schen\n    print(f\"ğŸ—‘ï¸ {verschoben.name} gelÃ¶scht\")\n\n# Ordner lÃ¶schen (nur wenn leer!)\nif ziel_ordner.exists():\n    ziel_ordner.rmdir()\n    print(f\"ğŸ—‘ï¸ {ziel_ordner.name}/ gelÃ¶scht\")",
                                "checkpoint": " - `.mkdir()` erstellt Ordner - `.write_text()` / `.read_text()` fÃ¼r Text - `.write_bytes()` / `.read_bytes()` fÃ¼r BinÃ¤rdaten - `.iterdir()` listet Inhalt auf - `.rglob()` sucht rekursiv - `.unlink()` lÃ¶scht Dateien - `.rmdir()` lÃ¶scht leere Ordner"
                        },
                        {
                                "number": 3,
                                "title": "Glob-Patterns fÃ¼r Dateisuche",
                                "goal": "Dateien nach Mustern finden",
                                "why": "Oft brauchen wir \"alle .jpg Dateien\" oder \"alle Dateien die mit test_ beginnen\"!",
                                "instruction": "",
                                "code": "from pathlib import Path\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ” GLOB-PATTERNS - DATEI-SUCHE\")\nprint(\"=\" * 60)\n\n# Test-Struktur erstellen\nbasis = Path(\"test_glob\")\nbasis.mkdir(exist_ok=True)\n\n# Verschiedene Dateien erstellen\ntest_dateien = [\n    \"bild1.jpg\", \"bild2.jpg\", \"foto.png\",\n    \"dokument.pdf\", \"notizen.txt\", \"backup.txt\",\n    \"script.py\", \"data.json\", \"config.yaml\"\n]\n\nfor datei in test_dateien:\n    (basis / datei).write_text(f\"Inhalt von {datei}\")\n\n# Unterordner mit Dateien\nsub = basis / \"unterordner\"\nsub.mkdir(exist_ok=True)\n(sub / \"deep.jpg\").write_text(\"Tief verschachtelt\")\n(sub / \"readme.txt\").write_text(\"README\")\n\nprint(f\"âœ… {len(test_dateien) + 2} Test-Dateien erstellt\\n\")\n\n# GLOB-PATTERNS\n\n# Alle Dateien mit .txt\nprint(\"ğŸ“ Alle .txt Dateien:\")\nfor datei in basis.glob(\"*.txt\"):\n    print(f\"  - {datei.name}\")\n\n# Alle Bild-Dateien (jpg ODER png)\nprint(\"\\nğŸ–¼ï¸ Alle Bilder (.jpg, .png):\")\nfor ext in [\".jpg\", \".png\"]:\n    for datei in basis.glob(f\"*{ext}\"):\n        print(f\"  - {datei.name}\")\n\n# Alternativ: Mehrere Patterns\nprint(\"\\nğŸ–¼ï¸ Bilder (Alternative):\")\nfor datei in basis.glob(\"bild*\"):  # Alles was mit \"bild\" beginnt\n    print(f\"  - {datei.name}\")\n\n# REKURSIVE SUCHE mit rglob()\nprint(\"\\nğŸ” Alle .txt Dateien (inkl. Unterordner):\")\nfor datei in basis.rglob(\"*.txt\"):  # Sucht in ALLEN Unterordnern\n    print(f\"  - {datei.relative_to(basis)}\")\n\n# Alle Dateien rekursiv\nprint(\"\\nğŸ“‚ ALLE Dateien rekursiv:\")\nfor datei in basis.rglob(\"*\"):\n    if datei.is_file():\n        rel_pfad = datei.relative_to(basis)\n        print(f\"  - {rel_pfad}\")\n\n# ERWEITERTE PATTERNS\n\n# Dateien die mit bestimmtem Buchstaben beginnen\nprint(\"\\nğŸ”¤ Dateien die mit 'b' oder 'd' beginnen:\")\nfor datei in list(basis.glob(\"b*\")) + list(basis.glob(\"d*\")):\n    print(f\"  - {datei.name}\")\n\n# Dateien mit mehreren Buchstaben im Namen\nprint(\"\\nğŸ“ Dateien mit 'data' oder 'config' im Namen:\")\nfor pattern in [\"*data*\", \"*config*\"]:\n    for datei in basis.glob(pattern):\n        print(f\"  - {datei.name}\")\n\n# Nach GrÃ¶ÃŸe filtern\nprint(\"\\nğŸ“¦ Dateien grÃ¶ÃŸer als 10 Bytes:\")\nfor datei in basis.rglob(\"*\"):\n    if datei.is_file() and datei.stat().st_size > 10:\n        grÃ¶ÃŸe = datei.stat().st_size\n        print(f\"  - {datei.name} ({grÃ¶ÃŸe} Bytes)\")",
                                "checkpoint": " - `.glob(pattern)` sucht mit Muster - `*.txt` = alle .txt Dateien - `test_*` = alles was mit test_ beginnt - `.rglob()` = rekursiv in allen Unterordnern - Wildcards: `*` (beliebig viel), `?` (ein Zeichen)"
                        },
                        {
                                "number": 4,
                                "title": "Datei-Scanner Tool",
                                "goal": "VollstÃ¤ndiges Tool zum Durchsuchen und Analysieren",
                                "why": "Praktisches Tool das du wiederverwenden kannst!",
                                "instruction": "",
                                "code": "from pathlib import Path\nfrom datetime import datetime\nfrom collections import defaultdict\nimport mimetypes\n\nclass DateiScanner:\n    \"\"\"Scannt und analysiert Verzeichnisse\"\"\"\n    \n    def __init__(self, basis_pfad):\n        self.basis = Path(basis_pfad)\n        \n        if not self.basis.exists():\n            raise FileNotFoundError(f\"Pfad existiert nicht: {basis_pfad}\")\n        \n        self.dateien = []\n        self.ordner = []\n    \n    def scannen(self, rekursiv=True):\n        \"\"\"Scannt das Verzeichnis\"\"\"\n        self.dateien = []\n        self.ordner = []\n        \n        if rekursiv:\n            items = self.basis.rglob(\"*\")\n        else:\n            items = self.basis.glob(\"*\")\n        \n        for item in items:\n            if item.is_file():\n                self.dateien.append(item)\n            elif item.is_dir():\n                self.ordner.append(item)\n        \n        return len(self.dateien), len(self.ordner)\n    \n    def nach_erweiterung(self):\n        \"\"\"Gruppiert Dateien nach Erweiterung\"\"\"\n        gruppen = defaultdict(list)\n        \n        for datei in self.dateien:\n            ext = datei.suffix.lower() or \".keine\"\n            gruppen[ext].append(datei)\n        \n        return dict(gruppen)\n    \n    def nach_grÃ¶ÃŸe(self, min_mb=None, max_mb=None):\n        \"\"\"Filtert Dateien nach GrÃ¶ÃŸe\"\"\"\n        ergebnis = []\n        \n        for datei in self.dateien:\n            grÃ¶ÃŸe_mb = datei.stat().st_size / 1024 / 1024\n            \n            if min_mb and grÃ¶ÃŸe_mb < min_mb:\n                continue\n            if max_mb and grÃ¶ÃŸe_mb > max_mb:\n                continue\n            \n            ergebnis.append((datei, grÃ¶ÃŸe_mb))\n        \n        return sorted(ergebnis, key=lambda x: x[1], reverse=True)\n    \n    def nach_datum(self, tage=7):\n        \"\"\"Findet Dateien der letzten N Tage\"\"\"\n        from datetime import timedelta\n        \n        jetzt = datetime.now().timestamp()\n        grenze = jetzt - (tage * 24 * 60 * 60)\n        \n        neu = []\n        \n        for datei in self.dateien:\n            mod_zeit = datei.stat().st_mtime\n            if mod_zeit > grenze:\n                alter = (jetzt - mod_zeit) / 60 / 60 / 24  # in Tagen\n                neu.append((datei, alter))\n        \n        return sorted(neu, key=lambda x: x[1])\n    \n    def duplikate_nach_name(self):\n        \"\"\"Findet Duplikate nach Dateinamen\"\"\"\n        namen = defaultdict(list)\n        \n        for datei in self.dateien:\n            namen[datei.stem.lower()].append(datei)\n        \n        duplikate = {k: v for k, v in namen.items() if len(v) > 1}\n        return duplikate\n    \n    def grÃ¶ÃŸte_dateien(self, n=10):\n        \"\"\"Gibt die N grÃ¶ÃŸten Dateien zurÃ¼ck\"\"\"\n        mit_grÃ¶ÃŸe = [(d, d.stat().st_size) for d in self.dateien]\n        sortiert = sorted(mit_grÃ¶ÃŸe, key=lambda x: x[1], reverse=True)\n        return sortiert[:n]\n    \n    def statistik(self):\n        \"\"\"Erstellt umfassende Statistik\"\"\"\n        if not self.dateien:\n            print(\"âš ï¸ Keine Dateien gescannt. Rufe .scannen() auf!\")\n            return\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"ğŸ“Š DATEI-SCANNER STATISTIK\")\n        print(f\"{'='*70}\")\n        print(f\"Basis: {self.basis}\")\n        print(f\"\\nOrdner: {len(self.ordner)}\")\n        print(f\"Dateien: {len(self.dateien)}\")\n        \n        # GesamtgrÃ¶ÃŸe\n        gesamt_bytes = sum(d.stat().st_size for d in self.dateien)\n        gesamt_mb = gesamt_bytes / 1024 / 1024\n        print(f\"GesamtgrÃ¶ÃŸe: {gesamt_mb:.2f} MB\")\n        \n        # Nach Typ\n        print(f\"\\nğŸ“ Nach Dateityp:\")\n        typen = self.nach_erweiterung()\n        for ext, dateien in sorted(typen.items(), key=lambda x: len(x[1]), reverse=True):\n            anzahl = len(dateien)\n            grÃ¶ÃŸe = sum(d.stat().st_size for d in dateien) / 1024 / 1024\n            print(f\"  {ext:<10} {anzahl:>5} Dateien  {grÃ¶ÃŸe:>8.2f} MB\")\n        \n        # GrÃ¶ÃŸte Dateien\n        print(f\"\\nğŸ“¦ Top 5 grÃ¶ÃŸte Dateien:\")\n        for datei, grÃ¶ÃŸe in self.grÃ¶ÃŸte_dateien(5):\n            rel = datei.relative_to(self.basis) if datei.is_relative_to(self.basis) else datei\n            print(f\"  {grÃ¶ÃŸe/1024/1024:>8.2f} MB  {rel}\")\n        \n        # Neueste Dateien\n        print(f\"\\nğŸ†• Dateien der letzten 7 Tage:\")\n        neueste = self.nach_datum(7)\n        if neueste:\n            for datei, alter in neueste[:5]:\n                rel = datei.relative_to(self.basis) if datei.is_relative_to(self.basis) else datei\n                print(f\"  vor {alter:.1f} Tagen: {rel}\")\n        else:\n            print(\"  Keine neuen Dateien\")\n        \n        # Duplikate\n        dups = self.duplikate_nach_name()\n        if dups:\n            print(f\"\\nâš ï¸ MÃ¶gliche Duplikate nach Name:\")\n            for name, dateien in list(dups.items())[:3]:\n                print(f\"  '{name}':\")\n                for d in dateien:\n                    print(f\"    - {d.relative_to(self.basis) if d.is_relative_to(self.basis) else d}\")\n    \n    def suche(self, pattern, in_namen=True, in_inhalt=False):\n        \"\"\"Sucht nach Pattern in Dateinamen oder Inhalt\"\"\"\n        ergebnisse = []\n        \n        for datei in self.dateien:\n            # In Namen suchen\n            if in_namen and pattern.lower() in datei.name.lower():\n                ergebnisse.append(datei)\n                continue\n            \n            # In Inhalt suchen (nur Text-Dateien)\n            if in_inhalt:\n                try:\n                    if datei.suffix in ['.txt', '.py', '.md', '.json']:\n                        inhalt = datei.read_text(encoding='utf-8', errors='ignore')\n                        if pattern.lower() in inhalt.lower():\n                            ergebnisse.append(datei)\n                except:\n                    pass\n        \n        return ergebnisse\n\n# === TESTEN ===\nprint(\"=\" * 70)\nprint(\"ğŸ” DATEI-SCANNER\")\nprint(\"=\" * 70)\n\n# Test-Struktur erstellen\ntest = Path(\"test_scanner\")\ntest.mkdir(exist_ok=True)\n\n# Verschiedene Dateien\ndateien_info = [\n    (\"groÃŸ.dat\", \"x\" * 1000000),  # ~1 MB\n    (\"klein.txt\", \"klein\"),\n    (\"bild1.jpg\", \"fake jpg\" * 1000),\n    (\"bild2.jpg\", \"fake jpg\" * 500),\n    (\"dokument.pdf\", \"pdf\" * 10000),\n    (\"script.py\", \"print('hello')\" * 100),\n]\n\nfor name, inhalt in dateien_info:\n    (test / name).write_text(inhalt)\n\n# Unterordner\nsub = test / \"archiv\"\nsub.mkdir(exist_ok=True)\n(sub / \"alt.txt\").write_text(\"alt\")\n(sub / \"backup.zip\").write_text(\"zip\" * 5000)\n\nprint(f\"âœ… Test-Struktur erstellt\\n\")\n\n# Scanner erstellen und ausfÃ¼hren\nscanner = DateiScanner(test)\ndateien, ordner = scanner.scannen(rekursiv=True)\nprint(f\"ğŸ“‚ Gescannt: {dateien} Dateien, {ordner} Ordner\")\n\n# Statistik\nscanner.statistik()\n\n# Suche\nprint(f\"\\nğŸ” Suche nach 'bild':\")\ntreffer = scanner.suche(\"bild\", in_namen=True)\nfor t in treffer:\n    print(f\"  - {t.name}\")\n\n# Nach GrÃ¶ÃŸe filtern\nprint(f\"\\nğŸ“¦ Dateien grÃ¶ÃŸer als 0.5 MB:\")\ngroÃŸe = scanner.nach_grÃ¶ÃŸe(min_mb=0.5)\nfor datei, grÃ¶ÃŸe in groÃŸe:\n    print(f\"  {grÃ¶ÃŸe:.2f} MB: {datei.name}\")",
                                "checkpoint": " - VollstÃ¤ndiger Datei-Scanner - Gruppierung nach Typ, GrÃ¶ÃŸe, Datum - Duplikate-Erkennung - Such-Funktion - Umfassende Statistiken"
                        }
                ]
        },
        {
                "id": 6,
                "weekId": 3,
                "title": "Backup-Tool (Shutil)",
                "duration": "45-60 min",
                "task": {
                        "title": "Backup-Tool (Shutil)",
                        "description": "Lerne Shutil kennen - das Modul fÃ¼r High-Level Datei-Operationen!",
                        "goals": [
                                "shutil.copy(): Dateien kopieren",
                                "shutil.copytree(): Ordner kopieren",
                                "shutil.move(): Verschieben",
                                "shutil.make_archive(): Archive erstellen",
                                "shutil.unpack_archive(): Archive entpacken",
                                "ignore Parameter: Selektives Kopieren",
                                "shutil.ignore_patterns(): Pattern-Filter",
                                "Inkrementelle Backups: Nur Ã„nderungen",
                                "Konfiguration: JSON fÃ¼r Einstellungen"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Shutil Grundlagen",
                                "goal": "Verstehen was Shutil kann",
                                "why": "Shutil macht komplexe Operationen einfach - kopieren, verschieben, archivieren!",
                                "instruction": "",
                                "code": "import shutil\nfrom pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"ğŸ“¦ SHUTIL - HIGH-LEVEL DATEI-OPERATIONEN\")\nprint(\"=\" * 60)\n\n# Test-Umgebung\nquelle = Path(\"test_shutil_quelle\")\nquelle.mkdir(exist_ok=True)\n\n# Test-Dateien\ntest_datei = quelle / \"dokument.txt\"\ntest_datei.write_text(\"Wichtiger Inhalt!\")\n\nprint(f\"âœ… Test-Datei erstellt: {test_datei.name}\\n\")\n\n# DATEIEN KOPIEREN\n\n# 1. copy() - Kopiert Datei (ohne Metadaten)\nziel1 = Path(\"kopie1.txt\")\nshutil.copy(test_datei, ziel1)\nprint(f\"ğŸ“‹ copy(): {test_datei.name} â†’ {ziel1.name}\")\n\n# 2. copy2() - Kopiert Datei (MIT Metadaten - Datum, Rechte)\nziel2 = Path(\"kopie2.txt\")\nshutil.copy2(test_datei, ziel2)\nprint(f\"ğŸ“‹ copy2(): {test_datei.name} â†’ {ziel2.name}\")\n\n# 3. copyfile() - Nur Inhalt (schneller, aber keine Metadaten)\nziel3 = Path(\"kopie3.txt\")\nshutil.copyfile(test_datei, ziel3)\nprint(f\"ğŸ“‹ copyfile(): {test_datei.name} â†’ {ziel3.name}\")\n\n# ORDNER KOPIEREN\n\n# Unterordner mit Dateien erstellen\nsub = quelle / \"unterordner\"\nsub.mkdir(exist_ok=True)\n(sub / \"datei1.txt\").write_text(\"Datei 1\")\n(sub / \"datei2.txt\").write_text(\"Datei 2\")\n\n# copytree() - Kopiert ganzen Ordner rekursiv\nziel_ordner = Path(\"kopierter_ordner\")\nshutil.copytree(quelle, ziel_ordner)\nprint(f\"\\nğŸ“ copytree(): {quelle.name}/ â†’ {ziel_ordner.name}/\")\n\n# VERSCHIEBEN\n\n# move() - Verschiebt Datei oder Ordner\nzu_verschieben = Path(\"zu_verschieben.txt\")\nzu_verschieben.write_text(\"Ich werde verschoben\")\n\nverschoben = Path(\"verschoben\") / \"neue_position.txt\"\nverschoben.parent.mkdir(exist_ok=True)\n\nshutil.move(zu_verschieben, verschoben)\nprint(f\"\\nğŸšš move(): {zu_verschieben.name} â†’ {verschoben}\")\n\n# DISK USAGE - Speicherplatz prÃ¼fen\nusage = shutil.disk_usage(Path.cwd())\nprint(f\"\\nğŸ’¾ Disk Usage (aktuelles Laufwerk):\")\nprint(f\"Total: {usage.total / 1024**3:.2f} GB\")\nprint(f\"Benutzt: {usage.used / 1024**3:.2f} GB\")\nprint(f\"Frei: {usage.free / 1024**3:.2f} GB\")\n\n# LÃ–SCHEN\n\n# rmtree() - LÃ¶scht Ordner rekursiv (GEFÃ„HRLICH!)\nif ziel_ordner.exists():\n    shutil.rmtree(ziel_ordner)\n    print(f\"\\nğŸ—‘ï¸ rmtree(): {ziel_ordner.name}/ gelÃ¶scht (rekursiv)\")",
                                "checkpoint": " - `shutil.copy()` kopiert Datei - `shutil.copy2()` kopiert mit Metadaten - `shutil.copytree()` kopiert ganzen Ordner - `shutil.move()` verschiebt - `shutil.rmtree()` lÃ¶scht rekursiv - `shutil.disk_usage()` zeigt Speicherplatz"
                        },
                        {
                                "number": 2,
                                "title": "Archive erstellen",
                                "goal": "ZIP, TAR und andere Archive erstellen",
                                "why": "Backups komprimieren spart Platz!",
                                "instruction": "",
                                "code": "import shutil\nfrom pathlib import Path\nfrom datetime import datetime\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ—œï¸ ARCHIVE ERSTELLEN\")\nprint(\"=\" * 60)\n\n# Zu archivierende Daten\nquelle = Path(\"test_archiv\")\nquelle.mkdir(exist_ok=True)\n\n# Mehrere Dateien erstellen\nfor i in range(5):\n    (quelle / f\"datei{i}.txt\").write_text(f\"Inhalt von Datei {i}\" * 100)\n\nsub = quelle / \"unterordner\"\nsub.mkdir(exist_ok=True)\n(sub / \"wichtig.txt\").write_text(\"Wichtige Daten!\" * 50)\n\nprint(f\"âœ… Test-Daten erstellt in '{quelle.name}/'\\n\")\n\n# VerfÃ¼gbare Archive-Formate\nformate = shutil.get_archive_formats()\nprint(f\"ğŸ“¦ VerfÃ¼gbare Archive-Formate:\")\nfor name, beschreibung in formate:\n    print(f\"  {name}: {beschreibung}\")\n\n# ZIP erstellen\nprint(f\"\\nğŸ—œï¸ Erstelle ZIP-Archiv...\")\nzip_name = \"backup_zip\"\nshutil.make_archive(\n    zip_name,           # Name (ohne .zip)\n    'zip',              # Format\n    quelle              # Quelle-Ordner\n)\nprint(f\"âœ… Erstellt: {zip_name}.zip\")\n\n# GrÃ¶ÃŸe prÃ¼fen\noriginal_grÃ¶ÃŸe = sum(f.stat().st_size for f in quelle.rglob(\"*\") if f.is_file())\narchiv_grÃ¶ÃŸe = Path(f\"{zip_name}.zip\").stat().st_size\n\nprint(f\"\\nğŸ“Š Kompression:\")\nprint(f\"Original: {original_grÃ¶ÃŸe / 1024:.2f} KB\")\nprint(f\"Archiv: {archiv_grÃ¶ÃŸe / 1024:.2f} KB\")\nprint(f\"Kompression: {(1 - archiv_grÃ¶ÃŸe/original_grÃ¶ÃŸe) * 100:.1f}%\")\n\n# TAR.GZ erstellen (stÃ¤rkere Kompression)\nprint(f\"\\nğŸ—œï¸ Erstelle TAR.GZ-Archiv...\")\ntar_name = \"backup_tar\"\nshutil.make_archive(tar_name, 'gztar', quelle)\nprint(f\"âœ… Erstellt: {tar_name}.tar.gz\")\n\ntar_grÃ¶ÃŸe = Path(f\"{tar_name}.tar.gz\").stat().st_size\nprint(f\"TAR.GZ GrÃ¶ÃŸe: {tar_grÃ¶ÃŸe / 1024:.2f} KB\")\n\n# ARCHIV ENTPACKEN\nprint(f\"\\nğŸ“‚ Entpacke Archive...\")\n\n# ZIP entpacken\nzip_ziel = Path(\"entpackt_zip\")\nshutil.unpack_archive(f\"{zip_name}.zip\", zip_ziel)\nprint(f\"âœ… ZIP entpackt nach: {zip_ziel}/\")\n\n# TAR.GZ entpacken\ntar_ziel = Path(\"entpackt_tar\")\nshutil.unpack_archive(f\"{tar_name}.tar.gz\", tar_ziel)\nprint(f\"âœ… TAR.GZ entpackt nach: {tar_ziel}/\")\n\n# Mit Zeitstempel\nprint(f\"\\nâ° Archiv mit Timestamp:\")\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\ntimestamped = f\"backup_{timestamp}\"\nshutil.make_archive(timestamped, 'zip', quelle)\nprint(f\"âœ… Erstellt: {timestamped}.zip\")",
                                "checkpoint": " - `shutil.make_archive()` erstellt Archive - Formate: zip, tar, gztar, bztar, xztar - `shutil.unpack_archive()` entpackt - Automatische Kompression - Zeitstempel in Dateinamen"
                        },
                        {
                                "number": 3,
                                "title": "Intelligentes Kopieren mit Filtern",
                                "goal": "Nur bestimmte Dateien kopieren",
                                "why": "Oft wollen wir nicht ALLES kopieren - z.B. keine .pyc Dateien!",
                                "instruction": "",
                                "code": "import shutil\nfrom pathlib import Path\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ” SELEKTIVES KOPIEREN MIT FILTERN\")\nprint(\"=\" * 60)\n\n# Test-Struktur\nquelle = Path(\"test_filter_quelle\")\nquelle.mkdir(exist_ok=True)\n\n# Verschiedene Dateitypen\ndateien = {\n    \"code.py\": \"print('hello')\",\n    \"compiled.pyc\": \"binary data\",\n    \"__pycache__\": None,  # Ordner\n    \"dokument.txt\": \"text\",\n    \"bild.jpg\": \"fake image data\",\n    \"backup.bak\": \"old backup\",\n    \"wichtig.pdf\": \"pdf content\",\n}\n\nfor name, inhalt in dateien.items():\n    pfad = quelle / name\n    if inhalt is None:  # Ordner\n        pfad.mkdir(exist_ok=True)\n    else:\n        pfad.write_text(inhalt)\n\nprint(f\"âœ… Test-Struktur mit {len(dateien)} Items erstellt\\n\")\n\n# FILTER-FUNKTIONEN\n\ndef ignoriere_pyc(verzeichnis, inhalt):\n    \"\"\"\n    Filter fÃ¼r copytree()\n    \n    Args:\n        verzeichnis: Aktuelles Verzeichnis (String)\n        inhalt: Liste aller Dateien/Ordner im Verzeichnis\n        \n    Returns:\n        Liste von Namen die IGNORIERT werden sollen\n    \"\"\"\n    ignorieren = []\n    \n    for item in inhalt:\n        # Ignoriere .pyc und __pycache__\n        if item.endswith('.pyc') or item == '__pycache__':\n            ignorieren.append(item)\n    \n    return ignorieren\n\ndef ignoriere_backups(verzeichnis, inhalt):\n    \"\"\"Ignoriert Backup-Dateien (.bak, .backup, .old)\"\"\"\n    return [item for item in inhalt \n            if item.endswith(('.bak', '.backup', '.old'))]\n\ndef nur_dokumente(verzeichnis, inhalt):\n    \"\"\"Kopiert nur Dokumente (.txt, .pdf, .doc)\"\"\"\n    doc_extensions = {'.txt', '.pdf', '.doc', '.docx'}\n    \n    ignorieren = []\n    for item in inhalt:\n        pfad = Path(verzeichnis) / item\n        if pfad.is_file():\n            if pfad.suffix not in doc_extensions:\n                ignorieren.append(item)\n    \n    return ignorieren\n\n# KOPIEREN MIT FILTERN\n\n# 1. Ohne Python-Compile-Dateien\nziel1 = Path(\"kopie_ohne_pyc\")\nshutil.copytree(quelle, ziel1, ignore=ignoriere_pyc)\nprint(f\"ğŸ“ Kopiert (ohne .pyc): {ziel1.name}/\")\n\n# 2. Ohne Backups\nziel2 = Path(\"kopie_ohne_backups\")\nshutil.copytree(quelle, ziel2, ignore=ignoriere_backups)\nprint(f\"ğŸ“ Kopiert (ohne .bak): {ziel2.name}/\")\n\n# 3. Nur Dokumente\nziel3 = Path(\"kopie_nur_dokumente\")\nshutil.copytree(quelle, ziel3, ignore=nur_dokumente)\nprint(f\"ğŸ“ Kopiert (nur Docs): {ziel3.name}/\")\n\n# 4. Kombinierte Filter\ndef kombinierter_filter(verzeichnis, inhalt):\n    \"\"\"Kombiniert mehrere Filter\"\"\"\n    ignorieren = set()\n    \n    # Sammle alle zu ignorierenden Items\n    ignorieren.update(ignoriere_pyc(verzeichnis, inhalt))\n    ignorieren.update(ignoriere_backups(verzeichnis, inhalt))\n    \n    return list(ignorieren)\n\nziel4 = Path(\"kopie_gefiltert\")\nshutil.copytree(quelle, ziel4, ignore=kombinierter_filter)\nprint(f\"ğŸ“ Kopiert (kombiniert): {ziel4.name}/\")\n\n# Inhalt vergleichen\nprint(f\"\\nğŸ“Š Vergleich:\")\nprint(f\"Original: {len(list(quelle.iterdir()))} Items\")\nprint(f\"Ohne .pyc: {len(list(ziel1.iterdir()))} Items\")\nprint(f\"Ohne .bak: {len(list(ziel2.iterdir()))} Items\")\nprint(f\"Nur Docs: {len(list(ziel3.iterdir()))} Items\")\nprint(f\"Kombiniert: {len(list(ziel4.iterdir()))} Items\")\n\n# PATTERN-BASIERTE FILTER (einfacher!)\nprint(f\"\\nğŸ¯ Pattern-basierte Filter:\")\n\n# ignore_patterns() - Eingebaute Funktion!\nziel5 = Path(\"kopie_pattern\")\nshutil.copytree(\n    quelle,\n    ziel5,\n    ignore=shutil.ignore_patterns('*.pyc', '__pycache__', '*.bak')\n)\nprint(f\"ğŸ“ Kopiert (mit ignore_patterns): {ziel5.name}/\")",
                                "checkpoint": " - `ignore` Parameter in `copytree()` - Custom Filter-Funktionen - `shutil.ignore_patterns()` fÃ¼r einfache Patterns - Mehrere Filter kombinieren"
                        },
                        {
                                "number": 4,
                                "title": "VollstÃ¤ndiges Backup-Tool",
                                "goal": "Production-Ready Backup-System",
                                "why": "Alle Konzepte in einem praktischen Tool!",
                                "instruction": "",
                                "code": "import shutil\nfrom pathlib import Path\nfrom datetime import datetime\nimport json\n\nclass BackupManager:\n    \"\"\"VollstÃ¤ndiges Backup-System\"\"\"\n    \n    def __init__(self, quelle, ziel_basis):\n        self.quelle = Path(quelle)\n        self.ziel_basis = Path(ziel_basis)\n        \n        if not self.quelle.exists():\n            raise FileNotFoundError(f\"Quelle nicht gefunden: {quelle}\")\n        \n        self.ziel_basis.mkdir(parents=True, exist_ok=True)\n        self.config_datei = self.ziel_basis / \"backup_config.json\"\n        self.config = self._lade_config()\n    \n    def _lade_config(self):\n        \"\"\"LÃ¤dt oder erstellt Konfiguration\"\"\"\n        if self.config_datei.exists():\n            return json.loads(self.config_datei.read_text())\n        else:\n            config = {\n                'backups': [],\n                'ignorierte_patterns': ['*.pyc', '__pycache__', '*.tmp', '.git'],\n                'max_backups': 5\n            }\n            self._speichere_config(config)\n            return config\n    \n    def _speichere_config(self, config):\n        \"\"\"Speichert Konfiguration\"\"\"\n        self.config_datei.write_text(json.dumps(config, indent=2))\n    \n    def erstelle_backup(self, typ='vollstÃ¤ndig', kommentar=''):\n        \"\"\"\n        Erstellt ein Backup\n        \n        Args:\n            typ: 'vollstÃ¤ndig' oder 'inkrementell'\n            kommentar: Optionaler Kommentar\n        \"\"\"\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_name = f\"backup_{timestamp}\"\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"ğŸ’¾ ERSTELLE BACKUP\")\n        print(f\"{'='*60}\")\n        print(f\"Typ: {typ}\")\n        print(f\"Quelle: {self.quelle}\")\n        print(f\"Ziel: {backup_name}\")\n        \n        if typ == 'vollstÃ¤ndig':\n            backup_pfad = self._vollstÃ¤ndiges_backup(backup_name)\n        else:\n            backup_pfad = self._inkrementelles_backup(backup_name)\n        \n        # Metadaten speichern\n        meta = {\n            'timestamp': timestamp,\n            'typ': typ,\n            'kommentar': kommentar,\n            'pfad': str(backup_pfad),\n            'grÃ¶ÃŸe': self._ordner_grÃ¶ÃŸe(backup_pfad),\n            'dateien': sum(1 for _ in backup_pfad.rglob(\"*\") if _.is_file())\n        }\n        \n        self.config['backups'].append(meta)\n        self._speichere_config(self.config)\n        \n        # Alte Backups lÃ¶schen\n        self._aufrÃ¤umen()\n        \n        print(f\"\\nâœ… Backup erstellt:\")\n        print(f\"   Dateien: {meta['dateien']}\")\n        print(f\"   GrÃ¶ÃŸe: {meta['grÃ¶ÃŸe'] / 1024 / 1024:.2f} MB\")\n        \n        return backup_pfad\n    \n    def _vollstÃ¤ndiges_backup(self, name):\n        \"\"\"Erstellt vollstÃ¤ndiges Backup\"\"\"\n        ziel = self.ziel_basis / name\n        \n        print(f\"\\nğŸ“¦ Kopiere alle Dateien...\")\n        shutil.copytree(\n            self.quelle,\n            ziel,\n            ignore=shutil.ignore_patterns(*self.config['ignorierte_patterns'])\n        )\n        \n        return ziel\n    \n    def _inkrementelles_backup(self, name):\n        \"\"\"Erstellt inkrementelles Backup (nur geÃ¤nderte Dateien)\"\"\"\n        ziel = self.ziel_basis / name\n        ziel.mkdir()\n        \n        # Letztes Backup als Referenz\n        letztes = self._letztes_backup()\n        if not letztes:\n            print(\"âš ï¸ Kein vorheriges Backup - erstelle vollstÃ¤ndiges Backup\")\n            return self._vollstÃ¤ndiges_backup(name)\n        \n        letztes_pfad = Path(letztes['pfad'])\n        \n        print(f\"\\nğŸ“¦ Kopiere nur geÃ¤nderte Dateien...\")\n        print(f\"   Referenz: {letztes_pfad.name}\")\n        \n        geÃ¤ndert = 0\n        neu = 0\n        \n        for datei in self.quelle.rglob(\"*\"):\n            if datei.is_file():\n                rel_pfad = datei.relative_to(self.quelle)\n                \n                # PrÃ¼fe ob Datei ignoriert werden soll\n                if any(datei.match(p) for p in self.config['ignorierte_patterns']):\n                    continue\n                \n                alte_datei = letztes_pfad / rel_pfad\n                \n                # Neu oder geÃ¤ndert?\n                if not alte_datei.exists():\n                    neu += 1\n                    ziel_datei = ziel / rel_pfad\n                    ziel_datei.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy2(datei, ziel_datei)\n                \n                elif datei.stat().st_mtime > alte_datei.stat().st_mtime:\n                    geÃ¤ndert += 1\n                    ziel_datei = ziel / rel_pfad\n                    ziel_datei.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy2(datei, ziel_datei)\n        \n        print(f\"   Neue Dateien: {neu}\")\n        print(f\"   GeÃ¤nderte Dateien: {geÃ¤ndert}\")\n        \n        return ziel\n    \n    def _letztes_backup(self):\n        \"\"\"Gibt letztes Backup zurÃ¼ck\"\"\"\n        if not self.config['backups']:\n            return None\n        return self.config['backups'][-1]\n    \n    def _ordner_grÃ¶ÃŸe(self, pfad):\n        \"\"\"Berechnet Ordner-GrÃ¶ÃŸe\"\"\"\n        return sum(f.stat().st_size for f in pfad.rglob(\"*\") if f.is_file())\n    \n    def _aufrÃ¤umen(self):\n        \"\"\"LÃ¶scht alte Backups\"\"\"\n        max_backups = self.config['max_backups']\n        \n        if len(self.config['backups']) > max_backups:\n            zu_lÃ¶schen = self.config['backups'][:-max_backups]\n            \n            print(f\"\\nğŸ§¹ LÃ¶sche {len(zu_lÃ¶schen)} alte(s) Backup(s)...\")\n            \n            for backup in zu_lÃ¶schen:\n                pfad = Path(backup['pfad'])\n                if pfad.exists():\n                    shutil.rmtree(pfad)\n                    print(f\"   ğŸ—‘ï¸ {pfad.name}\")\n            \n            self.config['backups'] = self.config['backups'][-max_backups:]\n            self._speichere_config(self.config)\n    \n    def liste_backups(self):\n        \"\"\"Listet alle Backups auf\"\"\"\n        if not self.config['backups']:\n            print(\"ğŸ“­ Keine Backups vorhanden\")\n            return\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"ğŸ“š BACKUP-LISTE\")\n        print(f\"{'='*60}\")\n        \n        for i, backup in enumerate(self.config['backups'], 1):\n            grÃ¶ÃŸe_mb = backup['grÃ¶ÃŸe'] / 1024 / 1024\n            print(f\"\\n{i}. {backup['timestamp']}\")\n            print(f\"   Typ: {backup['typ']}\")\n            print(f\"   Dateien: {backup['dateien']}\")\n            print(f\"   GrÃ¶ÃŸe: {grÃ¶ÃŸe_mb:.2f} MB\")\n            if backup['kommentar']:\n                print(f\"   Kommentar: {backup['kommentar']}\")\n    \n    def wiederherstellen(self, backup_index=-1, ziel=None):\n        \"\"\"\n        Stellt Backup wieder her\n        \n        Args:\n            backup_index: Index des Backups (-1 = letztes)\n            ziel: Ziel-Ordner (None = Original Ã¼berschreiben)\n        \"\"\"\n        if not self.config['backups']:\n            print(\"âŒ Keine Backups vorhanden\")\n            return\n        \n        backup = self.config['backups'][backup_index]\n        quelle = Path(backup['pfad'])\n        \n        if not quelle.exists():\n            print(f\"âŒ Backup nicht gefunden: {quelle}\")\n            return\n        \n        if ziel is None:\n            print(\"âš ï¸ WARNUNG: Original wird Ã¼berschrieben!\")\n            antwort = input(\"Fortfahren? (j/n): \")\n            if antwort.lower() != 'j':\n                print(\"âŒ Abgebrochen\")\n                return\n            ziel = self.quelle\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"â™»ï¸ WIEDERHERSTELLUNG\")\n        print(f\"{'='*60}\")\n        print(f\"Von: {quelle.name}\")\n        print(f\"Nach: {ziel}\")\n        \n        # Backup des aktuellen Zustands erstellen\n        if ziel == self.quelle:\n            print(\"\\nğŸ’¾ Erstelle Sicherheits-Backup...\")\n            self.erstelle_backup(typ='vollstÃ¤ndig', kommentar='Vor Wiederherstellung')\n        \n        # Wiederherstellen\n        if Path(ziel).exists():\n            shutil.rmtree(ziel)\n        \n        shutil.copytree(quelle, ziel)\n        \n        print(f\"\\nâœ… Wiederherstellung abgeschlossen!\")\n\n# === TESTEN ===\nprint(\"=\" * 60)\nprint(\"ğŸ’¾ BACKUP-MANAGER\")\nprint(\"=\" * 60)\n\n# Test-Projekt erstellen\nprojekt = Path(\"mein_projekt\")\nprojekt.mkdir(exist_ok=True)\n\n(projekt / \"main.py\").write_text(\"print('Version 1')\")\n(projekt / \"config.json\").write_text('{\"version\": 1}')\n(projekt / \"README.md\").write_text(\"# Mein Projekt\")\n\n# Ordner mit temporÃ¤ren Dateien\ntemp = projekt / \"__pycache__\"\ntemp.mkdir(exist_ok=True)\n(temp / \"main.pyc\").write_text(\"compiled\")\n\nprint(f\"âœ… Test-Projekt erstellt\\n\")\n\n# Backup-Manager erstellen\nmanager = BackupManager(projekt, \"backups\")\n\n# Erstes vollstÃ¤ndiges Backup\nmanager.erstelle_backup(typ='vollstÃ¤ndig', kommentar='Initial')\n\n# Projekt Ã¤ndern\nprint(f\"\\nğŸ“ Ã„ndere Projekt...\")\n(projekt / \"main.py\").write_text(\"print('Version 2')\")\n(projekt / \"neu.py\").write_text(\"print('neu')\")\n\n# Zweites Backup (inkrementell)\nmanager.erstelle_backup(typ='inkrementell', kommentar='Nach Ã„nderungen')\n\n# Liste anzeigen\nmanager.liste_backups()\n\n# Wiederherstellen (Simulation)\nprint(f\"\\n\" + \"=\"*60)\nprint(\"â™»ï¸ WIEDERHERSTELLUNG (Simulation)\")\nprint(\"=\"*60)\nprint(\"Um wiederherzustellen: manager.wiederherstellen(-1)\")",
                                "checkpoint": " - VollstÃ¤ndiges und inkrementelles Backup - Konfiguration in JSON - Automatisches AufrÃ¤umen alter Backups - Wiedherstellung mit Sicherheits-Backup - Metadaten-Tracking"
                        }
                ]
        },
        {
                "id": 7,
                "weekId": 3,
                "title": "Batch-Renamer (Glob & Massen-Operationen)",
                "duration": "45-60 min",
                "task": {
                        "title": "Batch-Renamer (Glob & Massen-Operationen)",
                        "description": "Erstelle ein Tool zum Umbenennen vieler Dateien auf einmal!",
                        "goals": [
                                "Glob-Patterns: `*`, `?`, `[]`, `**`",
                                "Batch-Operationen: Viele Dateien auf einmal",
                                "Sichere Umbenennung: Kollisionen vermeiden",
                                "Vorschau-Modus: Erst testen, dann ausfÃ¼hren",
                                "Name-Bereinigung: UngÃ¼ltige Zeichen entfernen",
                                "Regex: Komplexe Patterns",
                                "Vordefinierte Operationen: Wiederverwendbare Funktionen",
                                "Trockenlauf: Testen ohne Ã„nderungen"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Glob-Modul im Detail",
                                "goal": "Glob-Patterns meistern",
                                "why": "Glob ist perfekt fÃ¼r \"alle JPGs\" oder \"alle Dateien von gestern\"!",
                                "instruction": "",
                                "code": "import glob\nfrom pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"ğŸ” GLOB - PATTERN-MATCHING\")\nprint(\"=\" * 60)\n\n# Test-Struktur erstellen\nbasis = Path(\"test_glob_patterns\")\nbasis.mkdir(exist_ok=True)\n\n# Viele Test-Dateien\ndateien = [\n    \"foto_001.jpg\", \"foto_002.jpg\", \"foto_003.jpg\",\n    \"bild_2024_01.png\", \"bild_2024_02.png\",\n    \"dokument_01.pdf\", \"dokument_02.pdf\",\n    \"backup_20240115.zip\", \"backup_20240120.zip\",\n    \"script_v1.py\", \"script_v2.py\", \"script_final.py\",\n    \"IMG_001.JPG\", \"IMG_002.JPG\",  # GroÃŸbuchstaben\n]\n\nfor datei in dateien:\n    (basis / datei).write_text(f\"Inhalt: {datei}\")\n\n# Unterordner\n(basis / \"2024\").mkdir(exist_ok=True)\n(basis / \"2024\" / \"januar.txt\").write_text(\"januar\")\n\nprint(f\"âœ… {len(dateien) + 1} Test-Dateien erstellt\\n\")\n\n# GLOB-PATTERNS\n\n# 1. Alle Dateien mit Endung\nprint(\"ğŸ“¸ Alle .jpg Dateien (klein):\")\njpg_dateien = glob.glob(str(basis / \"*.jpg\"))\nfor datei in jpg_dateien:\n    print(f\"  - {Path(datei).name}\")\n\n# 2. Case-insensitive (groÃŸ/klein egal)\nprint(\"\\nğŸ“¸ Alle .jpg/.JPG Dateien (case-insensitive):\")\nalle_jpgs = glob.glob(str(basis / \"*.[jJ][pP][gG]\"))\nfor datei in alle_jpgs:\n    print(f\"  - {Path(datei).name}\")\n\n# Oder mit pathlib (automatisch case-insensitive auf Windows):\nfor datei in basis.glob(\"*.[jJ][pP][gG]\"):\n    print(f\"  - {datei.name}\")\n\n# 3. Dateien die mit bestimmtem Text beginnen\nprint(\"\\nğŸ–¼ï¸ Alle 'foto_*' Dateien:\")\nfoto_dateien = glob.glob(str(basis / \"foto_*\"))\nfor datei in foto_dateien:\n    print(f\"  - {Path(datei).name}\")\n\n# 4. Dateien mit Zahlen im Namen\nprint(\"\\nğŸ”¢ Dateien mit '_001' bis '_003':\")\nnummern = glob.glob(str(basis / \"*_00[123].*\"))\nfor datei in nummern:\n    print(f\"  - {Path(datei).name}\")\n\n# 5. Mehrere Patterns kombinieren\nprint(\"\\nğŸ“ Alle Bilder (.jpg, .png):\")\nbilder = []\nfor pattern in [\"*.jpg\", \"*.JPG\", \"*.png\"]:\n    bilder.extend(glob.glob(str(basis / pattern)))\nfor datei in bilder:\n    print(f\"  - {Path(datei).name}\")\n\n# 6. Rekursiv (mit **)\nprint(\"\\nğŸ” Rekursive Suche (alle .txt):\")\ntxt_rekursiv = glob.glob(str(basis / \"**\" / \"*.txt\"), recursive=True)\nfor datei in txt_rekursiv:\n    rel = Path(datei).relative_to(basis)\n    print(f\"  - {rel}\")\n\n# 7. Wildcards\n# * = beliebig viele Zeichen\n# ? = genau ein Zeichen\n# [abc] = a, b oder c\n# [0-9] = Ziffer\n# [a-z] = Kleinbuchstabe\n\nprint(\"\\nğŸ¯ Pattern mit ?:\")\n# Dateien mit genau 3 Zeichen nach _\ndrei_zeichen = glob.glob(str(basis / \"*_???.???\"))\nfor datei in drei_zeichen:\n    print(f\"  - {Path(datei).name}\")\n\nprint(\"\\nğŸ¯ Pattern mit [0-9]:\")\nmit_zahlen = glob.glob(str(basis / \"*[0-9][0-9].*\"))\nfor datei in mit_zahlen:\n    print(f\"  - {Path(datei).name}\")\n\n# GLOB MIT PATHLIB (empfohlen!)\nprint(\"\\nğŸ“‚ Mit Pathlib.glob():\")\nfor py_datei in basis.glob(\"script*.py\"):\n    print(f\"  ğŸ {py_datei.name}\")\n\n# Sortiert nach Datum\nprint(\"\\nâ° Nach Ã„nderungsdatum sortiert:\")\nalle = list(basis.glob(\"*.*\"))\nsortiert = sorted(alle, key=lambda p: p.stat().st_mtime)\nfor datei in sortiert[:5]:\n    print(f\"  - {datei.name}\")",
                                "checkpoint": " - `*` = beliebig viele Zeichen - `?` = genau ein Zeichen - `[abc]` = Eines der Zeichen - `**` = rekursiv - `glob.glob()` oder `Path.glob()`"
                        },
                        {
                                "number": 2,
                                "title": "Batch-Umbenennen Grundlagen",
                                "goal": "Viele Dateien auf einmal umbenennen",
                                "why": "Manuell 100 Fotos umbenennen? Nein danke!",
                                "instruction": "",
                                "code": "from pathlib import Path\nimport re\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"âœï¸ BATCH-UMBENENNEN\")\nprint(\"=\" * 60)\n\n# Test-Dateien\ntest = Path(\"test_rename\")\ntest.mkdir(exist_ok=True)\n\n# Unordentliche Dateinamen\ndateien = [\n    \"IMG_20240115_134521.jpg\",\n    \"IMG_20240115_134522.jpg\",\n    \"IMG_20240115_134523.jpg\",\n    \"DSC_001.jpg\",\n    \"DSC_002.jpg\",\n    \"photo (1).jpg\",\n    \"photo (2).jpg\",\n    \"Urlaubsfoto 2024.png\",\n]\n\nfor datei in dateien:\n    (test / datei).write_text(\"bild\")\n\nprint(f\"âœ… {len(dateien)} Dateien mit chaotischen Namen erstellt\\n\")\n\n# UMBENENNEN-STRATEGIEN\n\n# 1. PrÃ¤fix hinzufÃ¼gen\nprint(\"ğŸ“¸ Strategie 1: PrÃ¤fix hinzufÃ¼gen\")\nprÃ¤fix = \"Urlaub_\"\n\nfor datei in test.glob(\"IMG_*.jpg\"):\n    neuer_name = prÃ¤fix + datei.name\n    neu = datei.parent / neuer_name\n    print(f\"  {datei.name} â†’ {neuer_name}\")\n    # datei.rename(neu)  # Auskommentiert fÃ¼r Demo\n\n# 2. Durchnummerieren\nprint(\"\\nğŸ”¢ Strategie 2: Durchnummerieren\")\n\njpg_dateien = sorted(test.glob(\"*.jpg\"))\nfor i, datei in enumerate(jpg_dateien, start=1):\n    neuer_name = f\"foto_{i:03d}{datei.suffix}\"  # :03d = 3 Stellen mit fÃ¼hrenden Nullen\n    neu = datei.parent / neuer_name\n    print(f\"  {datei.name} â†’ {neuer_name}\")\n    # datei.rename(neu)\n\n# 3. Text ersetzen\nprint(\"\\nâœ‚ï¸ Strategie 3: Text ersetzen\")\n\nfor datei in test.glob(\"*\"):\n    if datei.is_file():\n        neuer_name = datei.name.replace(\"IMG_\", \"Foto_\")\n        neuer_name = neuer_name.replace(\"DSC_\", \"Bild_\")\n        \n        if neuer_name != datei.name:\n            neu = datei.parent / neuer_name\n            print(f\"  {datei.name} â†’ {neuer_name}\")\n            # datei.rename(neu)\n\n# 4. Leerzeichen entfernen\nprint(\"\\nğŸš€ Strategie 4: Leerzeichen entfernen\")\n\nfor datei in test.glob(\"*\"):\n    if datei.is_file() and \" \" in datei.name:\n        neuer_name = datei.name.replace(\" \", \"_\")\n        neu = datei.parent / neuer_name\n        print(f\"  {datei.name} â†’ {neuer_name}\")\n        # datei.rename(neu)\n\n# 5. Kleinbuchstaben\nprint(\"\\nğŸ”¤ Strategie 5: Alles Kleinbuchstaben\")\n\nfor datei in test.glob(\"*\"):\n    if datei.is_file():\n        neuer_name = datei.name.lower()\n        \n        if neuer_name != datei.name:\n            neu = datei.parent / neuer_name\n            print(f\"  {datei.name} â†’ {neuer_name}\")\n            # datei.rename(neu)\n\n# 6. Regex-basiert\nprint(\"\\nğŸ¯ Strategie 6: Datum extrahieren (Regex)\")\n\nfor datei in test.glob(\"IMG_*.jpg\"):\n    # Suche Datum im Format YYYYMMDD\n    match = re.search(r'(\\d{8})', datei.name)\n    if match:\n        datum = match.group(1)\n        jahr = datum[:4]\n        monat = datum[4:6]\n        tag = datum[6:8]\n        \n        neuer_name = f\"{jahr}-{monat}-{tag}_{datei.stem[9:]}{datei.suffix}\"\n        print(f\"  {datei.name} â†’ {neuer_name}\")\n        # datei.rename(datei.parent / neuer_name)\n\n# 7. Endung Ã¤ndern\nprint(\"\\nğŸ”„ Strategie 7: Endung Ã¤ndern (.jpg â†’ .jpeg)\")\n\nfor datei in test.glob(\"*.jpg\"):\n    neuer_name = datei.stem + \".jpeg\"\n    neu = datei.parent / neuer_name\n    print(f\"  {datei.name} â†’ {neuer_name}\")\n    # datei.rename(neu)",
                                "checkpoint": " - PrÃ¤fix/Suffix hinzufÃ¼gen - Durchnummerieren - Text ersetzen - Leerzeichen/Sonderzeichen entfernen - Regex fÃ¼r komplexe Patterns - Endungen Ã¤ndern"
                        },
                        {
                                "number": 3,
                                "title": "Sicheres Umbenennen",
                                "goal": "Kollisionen und Fehler vermeiden",
                                "why": "Was wenn neue Namen schon existieren? Oder ungÃ¼ltige Zeichen?",
                                "instruction": "",
                                "code": "from pathlib import Path\nimport re\nfrom datetime import datetime\n\nclass SichererRenamer:\n    \"\"\"Sicheres Umbenennen mit Kollisionserkennung\"\"\"\n    \n    # Zeichen die in Dateinamen problematisch sind\n    UNGUELTIGE_ZEICHEN = r'[<>:\"/\\\\|?*]'\n    \n    def __init__(self, trockenlauf=True):\n        self.trockenlauf = trockenlauf\n        self.Ã¤nderungen = []\n    \n    def bereinige_name(self, name):\n        \"\"\"Entfernt ungÃ¼ltige Zeichen\"\"\"\n        # Ersetze ungÃ¼ltige Zeichen mit _\n        bereinigt = re.sub(self.UNGUELTIGE_ZEICHEN, '_', name)\n        \n        # Entferne mehrfache Unterstriche\n        bereinigt = re.sub(r'_+', '_', bereinigt)\n        \n        # Entferne _ am Anfang/Ende\n        bereinigt = bereinigt.strip('_')\n        \n        return bereinigt\n    \n    def prÃ¼fe_kollision(self, pfad):\n        \"\"\"PrÃ¼ft ob Datei existiert und findet freien Namen\"\"\"\n        if not pfad.exists():\n            return pfad\n        \n        # Datei existiert - finde freien Namen\n        stamm = pfad.stem\n        suffix = pfad.suffix\n        parent = pfad.parent\n        \n        counter = 1\n        while True:\n            neuer_name = f\"{stamm}_{counter}{suffix}\"\n            neu = parent / neuer_name\n            \n            if not neu.exists():\n                return neu\n            \n            counter += 1\n            \n            if counter > 1000:  # Sicherheit\n                raise RuntimeError(\"Zu viele Kollisionen!\")\n    \n    def umbenennen(self, alt_pfad, neuer_name):\n        \"\"\"\n        Benennt Datei sicher um\n        \n        Returns:\n            Neuer Pfad oder None bei Fehler\n        \"\"\"\n        alt = Path(alt_pfad)\n        \n        if not alt.exists():\n            print(f\"âŒ Datei existiert nicht: {alt}\")\n            return None\n        \n        # Namen bereinigen\n        bereinigter_name = self.bereinige_name(neuer_name)\n        \n        if bereinigter_name != neuer_name:\n            print(f\"âš ï¸ Name bereinigt: '{neuer_name}' â†’ '{bereinigter_name}'\")\n        \n        # Ziel-Pfad\n        neu = alt.parent / bereinigter_name\n        \n        # Kollision prÃ¼fen\n        if neu.exists() and neu != alt:\n            print(f\"âš ï¸ Kollision: {bereinigter_name} existiert bereits\")\n            neu = self.prÃ¼fe_kollision(neu)\n            print(f\"   Verwende stattdessen: {neu.name}\")\n        \n        # Umbenennen oder simulieren\n        if self.trockenlauf:\n            print(f\"ğŸ§ª [Trockenlauf] {alt.name} â†’ {neu.name}\")\n        else:\n            try:\n                alt.rename(neu)\n                print(f\"âœ… {alt.name} â†’ {neu.name}\")\n            except Exception as e:\n                print(f\"âŒ Fehler: {e}\")\n                return None\n        \n        self.Ã¤nderungen.append((str(alt), str(neu)))\n        return neu\n    \n    def batch_umbenennen(self, dateien, name_funktion):\n        \"\"\"\n        Benennt mehrere Dateien um\n        \n        Args:\n            dateien: Liste von Pfaden\n            name_funktion: Funktion die (pfad, index) â†’ neuer_name\n        \"\"\"\n        erfolge = 0\n        fehler = 0\n        \n        for i, datei in enumerate(dateien):\n            neuer_name = name_funktion(datei, i)\n            \n            if self.umbenennen(datei, neuer_name):\n                erfolge += 1\n            else:\n                fehler += 1\n        \n        return erfolge, fehler\n    \n    def rÃ¼ckgÃ¤ngig(self):\n        \"\"\"Macht alle Ã„nderungen rÃ¼ckgÃ¤ngig\"\"\"\n        if self.trockenlauf:\n            print(\"âš ï¸ War nur Trockenlauf - nichts rÃ¼ckgÃ¤ngig zu machen\")\n            return\n        \n        print(f\"\\nâ™»ï¸ Mache {len(self.Ã¤nderungen)} Ã„nderungen rÃ¼ckgÃ¤ngig...\")\n        \n        for neu, alt in reversed(self.Ã¤nderungen):\n            neu_pfad = Path(neu)\n            alt_pfad = Path(alt)\n            \n            if neu_pfad.exists():\n                try:\n                    neu_pfad.rename(alt_pfad)\n                    print(f\"âœ… {neu_pfad.name} â†’ {alt_pfad.name}\")\n                except Exception as e:\n                    print(f\"âŒ Fehler: {e}\")\n        \n        self.Ã¤nderungen = []\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ›¡ï¸ SICHERES UMBENENNEN\")\nprint(\"=\" * 60)\n\n# Test-Dateien mit problematischen Namen\ntest = Path(\"test_sicher\")\ntest.mkdir(exist_ok=True)\n\nproblematische_namen = [\n    \"datei:mit:doppelpunkten.txt\",\n    \"datei<mit>klammern.txt\",\n    \"datei/mit/slashes.txt\",\n    \"normale_datei.txt\",\n    \"leerzeichen   mehrfach.txt\",\n]\n\nfor name in problematische_namen:\n    # Bereinige fÃ¼r Erstellung\n    sicherer_name = re.sub(r'[<>:\"/\\\\|?*]', '_', name)\n    (test / sicherer_name).write_text(\"test\")\n\n# Erstelle auch einige normale Dateien\nfor i in range(5):\n    (test / f\"foto{i}.jpg\").write_text(\"bild\")\n\nprint(f\"âœ… Test-Dateien erstellt\\n\")\n\n# Renamer erstellen (Trockenlauf!)\nrenamer = SichererRenamer(trockenlauf=True)\n\n# Test 1: Einzelne Datei\nprint(\"TEST 1: Einzelne Datei\")\nerste = list(test.glob(\"*.txt\"))[0]\nrenamer.umbenennen(erste, \"umbenannte_datei.txt\")\n\n# Test 2: Batch mit Nummerierung\nprint(\"\\nTEST 2: Batch-Nummerierung\")\nalle_jpg = sorted(test.glob(\"*.jpg\"))\n\ndef nummern_name(pfad, index):\n    return f\"bild_{index+1:03d}{pfad.suffix}\"\n\nerfolge, fehler = renamer.batch_umbenennen(alle_jpg, nummern_name)\nprint(f\"\\nğŸ“Š Erfolge: {erfolge}, Fehler: {fehler}\")\n\n# Test 3: Mit Kollision\nprint(\"\\nTEST 3: Kollisionserkennung\")\n(test / \"existiert.txt\").write_text(\"original\")\n(test / \"neu.txt\").write_text(\"alt\")\n\nrenamer.umbenennen(test / \"neu.txt\", \"existiert.txt\")\n\nprint(\"\\nğŸ’¡ Das war ein Trockenlauf!\")\nprint(\"Setze trockenlauf=False um wirklich umzubenennen\")",
                                "checkpoint": " - UngÃ¼ltige Zeichen entfernen - Kollisionen erkennen - Automatisch _1, _2, etc. anhÃ¤ngen - Trockenlauf-Modus - RÃ¼ckgÃ¤ngig-Funktion"
                        },
                        {
                                "number": 4,
                                "title": "VollstÃ¤ndiges Batch-Renamer Tool",
                                "goal": "Production-Ready Tool mit GUI-Ã¤hnlichen Features",
                                "why": "Alle Konzepte in einem nutzbaren Tool!",
                                "instruction": "",
                                "code": "from pathlib import Path\nimport re\nfrom datetime import datetime\nfrom collections import defaultdict\n\nclass BatchRenamer:\n    \"\"\"VollstÃ¤ndiges Batch-Umbenennen-Tool\"\"\"\n    \n    PRESETS = {\n        'nummerieren': lambda p, i: f\"{i+1:03d}_{p.stem}{p.suffix}\",\n        'datum': lambda p, i: f\"{datetime.now().strftime('%Y%m%d')}_{p.name}\",\n        'kleinbuchstaben': lambda p, i: p.name.lower(),\n        'keine_leerzeichen': lambda p, i: p.name.replace(' ', '_'),\n        'prefix': lambda p, i, prefix='': f\"{prefix}{p.name}\",\n        'suffix_vor_ext': lambda p, i, suffix='': f\"{p.stem}{suffix}{p.suffix}\",\n    }\n    \n    def __init__(self, ordner):\n        self.ordner = Path(ordner)\n        self.dateien = []\n        self.vorschau = []\n    \n    def dateien_laden(self, pattern=\"*\", rekursiv=False):\n        \"\"\"LÃ¤dt Dateien nach Pattern\"\"\"\n        if rekursiv:\n            self.dateien = list(self.ordner.rglob(pattern))\n        else:\n            self.dateien = list(self.ordner.glob(pattern))\n        \n        # Nur Dateien, keine Ordner\n        self.dateien = [f for f in self.dateien if f.is_file()]\n        \n        print(f\"ğŸ“ {len(self.dateien)} Dateien geladen\")\n        return len(self.dateien)\n    \n    def vorschau_erstellen(self, name_funktion, **kwargs):\n        \"\"\"Erstellt Vorschau ohne umzubenennen\"\"\"\n        self.vorschau = []\n        \n        for i, datei in enumerate(self.dateien):\n            try:\n                if kwargs:\n                    neuer_name = name_funktion(datei, i, **kwargs)\n                else:\n                    neuer_name = name_funktion(datei, i)\n                \n                # Bereinige Namen\n                neuer_name = self._bereinige(neuer_name)\n                \n                neu_pfad = datei.parent / neuer_name\n                \n                self.vorschau.append({\n                    'alt': datei,\n                    'neu': neu_pfad,\n                    'alt_name': datei.name,\n                    'neu_name': neuer_name,\n                    'status': 'OK' if neu_pfad != datei else 'UNVERÃ„NDERT'\n                })\n            except Exception as e:\n                self.vorschau.append({\n                    'alt': datei,\n                    'neu': None,\n                    'alt_name': datei.name,\n                    'neu_name': None,\n                    'status': f'FEHLER: {e}'\n                })\n        \n        return self.vorschau\n    \n    def vorschau_anzeigen(self, max_zeilen=20):\n        \"\"\"Zeigt Vorschau\"\"\"\n        if not self.vorschau:\n            print(\"âš ï¸ Keine Vorschau vorhanden. Rufe vorschau_erstellen() auf\")\n            return\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"ğŸ‘ï¸ VORSCHAU ({len(self.vorschau)} Dateien)\")\n        print(f\"{'='*70}\")\n        \n        # Statistiken\n        status_count = defaultdict(int)\n        for item in self.vorschau:\n            status_count[item['status']] += 1\n        \n        print(f\"\\nStatus-Ãœbersicht:\")\n        for status, anzahl in status_count.items():\n            print(f\"  {status}: {anzahl}\")\n        \n        # Beispiele zeigen\n        print(f\"\\n{'Alt':<30} â†’ {'Neu':<30} Status\")\n        print(\"-\" * 70)\n        \n        for i, item in enumerate(self.vorschau[:max_zeilen]):\n            alt = item['alt_name']\n            neu = item['neu_name'] or '???'\n            status = item['status']\n            \n            # KÃ¼rzen wenn zu lang\n            if len(alt) > 28:\n                alt = alt[:25] + \"...\"\n            if len(neu) > 28:\n                neu = neu[:25] + \"...\"\n            \n            status_symbol = \"âœ…\" if status == \"OK\" else \"âš ï¸\"\n            print(f\"{alt:<30} â†’ {neu:<30} {status_symbol}\")\n        \n        if len(self.vorschau) > max_zeilen:\n            print(f\"... und {len(self.vorschau) - max_zeilen} weitere\")\n    \n    def umbenennen(self, sicherheits_frage=True):\n        \"\"\"FÃ¼hrt Umbenennen durch\"\"\"\n        if not self.vorschau:\n            print(\"âŒ Keine Vorschau vorhanden!\")\n            return 0, 0\n        \n        # Nur OK-Status umbenennen\n        zum_umbenennen = [item for item in self.vorschau if item['status'] == 'OK']\n        \n        if not zum_umbenennen:\n            print(\"âŒ Keine Dateien zum Umbenennen!\")\n            return 0, 0\n        \n        if sicherheits_frage:\n            print(f\"\\nâš ï¸ {len(zum_umbenennen)} Dateien werden umbenannt!\")\n            antwort = input(\"Fortfahren? (j/n): \")\n            if antwort.lower() != 'j':\n                print(\"âŒ Abgebrochen\")\n                return 0, 0\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"âœï¸ UMBENENNEN\")\n        print(f\"{'='*70}\")\n        \n        erfolge = 0\n        fehler = 0\n        \n        for item in zum_umbenennen:\n            try:\n                # PrÃ¼fe Kollision\n                neu = item['neu']\n                if neu.exists() and neu != item['alt']:\n                    # Finde freien Namen\n                    counter = 1\n                    while True:\n                        test = item['neu'].parent / f\"{item['neu'].stem}_{counter}{item['neu'].suffix}\"\n                        if not test.exists():\n                            neu = test\n                            break\n                        counter += 1\n                \n                item['alt'].rename(neu)\n                print(f\"âœ… {item['alt_name']} â†’ {neu.name}\")\n                erfolge += 1\n                \n            except Exception as e:\n                print(f\"âŒ {item['alt_name']}: {e}\")\n                fehler += 1\n        \n        print(f\"\\nğŸ“Š Erfolge: {erfolge}, Fehler: {fehler}\")\n        return erfolge, fehler\n    \n    def _bereinige(self, name):\n        \"\"\"Bereinigt Dateinamen\"\"\"\n        # UngÃ¼ltige Zeichen\n        name = re.sub(r'[<>:\"/\\\\|?*]', '_', name)\n        # Mehrfache Unterstriche\n        name = re.sub(r'_+', '_', name)\n        # Am Anfang/Ende\n        name = name.strip('_')\n        return name\n    \n    # === VORDEFINIERTE OPERATIONEN ===\n    \n    def nummerieren(self, start=1, stellen=3, prÃ¤fix='', suffix=''):\n        \"\"\"Nummeriert durch: prÃ¤fix_001_suffix.ext\"\"\"\n        def name_func(pfad, index):\n            nummer = f\"{start + index:0{stellen}d}\"\n            if prÃ¤fix and suffix:\n                return f\"{prÃ¤fix}_{nummer}_{suffix}{pfad.suffix}\"\n            elif prÃ¤fix:\n                return f\"{prÃ¤fix}_{nummer}{pfad.suffix}\"\n            elif suffix:\n                return f\"{nummer}_{suffix}{pfad.suffix}\"\n            else:\n                return f\"{nummer}{pfad.suffix}\"\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def text_ersetzen(self, suche, ersetze, regex=False):\n        \"\"\"Ersetzt Text in Dateinamen\"\"\"\n        def name_func(pfad, index):\n            if regex:\n                return re.sub(suche, ersetze, pfad.name)\n            else:\n                return pfad.name.replace(suche, ersetze)\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def prÃ¤fix_hinzufÃ¼gen(self, prÃ¤fix):\n        \"\"\"FÃ¼gt PrÃ¤fix hinzu\"\"\"\n        def name_func(pfad, index):\n            return f\"{prÃ¤fix}{pfad.name}\"\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def suffix_hinzufÃ¼gen(self, suffix):\n        \"\"\"FÃ¼gt Suffix vor Dateiendung hinzu\"\"\"\n        def name_func(pfad, index):\n            return f\"{pfad.stem}{suffix}{pfad.suffix}\"\n        \n        return self.vorschau_erstellen(name_func)\n    \n    def kleinbuchstaben(self):\n        \"\"\"Alles Kleinbuchstaben\"\"\"\n        return self.vorschau_erstellen(lambda p, i: p.name.lower())\n    \n    def groÃŸbuchstaben(self):\n        \"\"\"Alles GroÃŸbuchstaben\"\"\"\n        return self.vorschau_erstellen(lambda p, i: p.name.upper())\n    \n    def leerzeichen_entfernen(self, ersetze_mit='_'):\n        \"\"\"Entfernt Leerzeichen\"\"\"\n        def name_func(pfad, index):\n            return pfad.name.replace(' ', ersetze_mit)\n        \n        return self.vorschau_erstellen(name_func)\n\n# === TESTEN ===\nprint(\"=\" * 70)\nprint(\"ğŸ¯ BATCH-RENAMER\")\nprint(\"=\" * 70)\n\n# Test-Dateien\ntest = Path(\"test_batch_renamer\")\ntest.mkdir(exist_ok=True)\n\ndateien = [\n    \"Urlaubsfoto 001.jpg\",\n    \"Urlaubsfoto 002.jpg\",\n    \"Urlaubsfoto 003.jpg\",\n    \"DSC_1234.jpg\",\n    \"DSC_1235.jpg\",\n    \"Dokument MIT LEERZEICHEN.pdf\",\n    \"alte_version.txt\",\n]\n\nfor datei in dateien:\n    (test / datei).write_text(\"test\")\n\nprint(f\"âœ… Test-Dateien erstellt\\n\")\n\n# Renamer erstellen\nrenamer = BatchRenamer(test)\n\n# Dateien laden\nrenamer.dateien_laden(\"*.jpg\")\n\n# Operation 1: Nummerieren\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 1: Nummerieren\")\nrenamer.nummerieren(start=1, stellen=3, prÃ¤fix=\"Urlaub\", suffix=\"2024\")\nrenamer.vorschau_anzeigen()\n\n# Operation 2: PrÃ¤fix\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 2: PrÃ¤fix hinzufÃ¼gen\")\nrenamer.dateien_laden(\"*.jpg\")\nrenamer.prÃ¤fix_hinzufÃ¼gen(\"2024_Sommer_\")\nrenamer.vorschau_anzeigen()\n\n# Operation 3: Text ersetzen\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 3: Text ersetzen\")\nrenamer.dateien_laden(\"DSC_*.jpg\")\nrenamer.text_ersetzen(\"DSC_\", \"Foto_\")\nrenamer.vorschau_anzeigen()\n\n# Operation 4: Leerzeichen entfernen\nprint(\"\\n\" + \"=\"*70)\nprint(\"OPERATION 4: Leerzeichen entfernen\")\nrenamer.dateien_laden(\"*\")\nrenamer.leerzeichen_entfernen(ersetze_mit='_')\nrenamer.vorschau_anzeigen()\n\nprint(\"\\nğŸ’¡ Alle Operationen waren Vorschauen!\")\nprint(\"Rufe renamer.umbenennen() auf um tatsÃ¤chlich umzubenennen\")",
                                "checkpoint": " - VollstÃ¤ndiges Batch-Renamer Tool - Viele vordefinierte Operationen - Vorschau-System - Sichere Umbenennung mit KollisionsprÃ¼fung - Statistiken und Feedback"
                        }
                ]
        },
      ]
    },
    {
      id: 4,
      title: "Woche 4: Real-World Apps",
      subtitle: "Praktische Anwendungen",
      description: "APIs, Web Scraping, Datenbanken und vollstÃ¤ndige Projekte.",
      color: "green",
      days: [
        {
                "id": 1,
                "weekId": 4,
                "title": "Konfigurations-Manager (JSON)",
                "duration": "45-60 min",
                "task": {
                        "title": "Konfigurations-Manager (JSON)",
                        "description": "Lerne JSON kennen - das Standard-Format fÃ¼r Daten im Web!",
                        "goals": [
                                "json.dumps(): Python â†’ JSON String",
                                "json.loads(): JSON String â†’ Python",
                                "json.dump(): Python â†’ JSON Datei",
                                "json.load(): JSON Datei â†’ Python",
                                "Formatierung: indent, ensure_ascii, sort_keys",
                                "Config-Manager: Professionelle Einstellungsverwaltung",
                                "Custom Encoder: Eigene Classes serialisieren",
                                "Fehlerbehandlung: JSONDecodeError"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "JSON Grundlagen",
                                "goal": "Verstehen was JSON ist und wie man es nutzt",
                                "why": "",
                                "instruction": "",
                                "code": "import json\n\nprint(\"=\" * 60)\nprint(\"ğŸ“„ JSON GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# PYTHON DATENSTRUKTUREN\nperson = {\n    \"name\": \"Anna Schmidt\",\n    \"alter\": 28,\n    \"stadt\": \"Berlin\",\n    \"hobbies\": [\"Lesen\", \"Wandern\", \"Programmieren\"],\n    \"aktiv\": True,\n    \"verheiratet\": False,\n    \"kinder\": None  # wird zu null in JSON\n}\n\n# PYTHON â†’ JSON (Serialisierung)\njson_string = json.dumps(person)  # dumps = dump string\nprint(\"\\nğŸ“¤ Python Dict â†’ JSON String:\")\nprint(json_string)\nprint(f\"Typ: {type(json_string)}\")  # str\n\n# Mit Formatierung (lesbar)\njson_formatiert = json.dumps(person, indent=2, ensure_ascii=False)\nprint(\"\\nğŸ“¤ Formatiertes JSON:\")\nprint(json_formatiert)\n\n# JSON â†’ PYTHON (Deserialisierung)\njson_text = '{\"name\": \"Max\", \"alter\": 35, \"hobbies\": [\"Sport\", \"Kochen\"]}'\nperson2 = json.loads(json_text)  # loads = load string\nprint(\"\\nğŸ“¥ JSON String â†’ Python Dict:\")\nprint(person2)\nprint(f\"Typ: {type(person2)}\")  # dict\nprint(f\"Name: {person2['name']}\")\n\n# DATENTYP-MAPPING\nprint(\"\\nğŸ”„ Python â†” JSON Datentypen:\")\nmapping = {\n    \"dict\": \"object\",\n    \"list\": \"array\",\n    \"str\": \"string\",\n    \"int/float\": \"number\",\n    \"True\": \"true\",\n    \"False\": \"false\",\n    \"None\": \"null\"\n}\n\nfor py, js in mapping.items():\n    print(f\"  {py:<15} â†” {js}\")\n\n# VERSCHACHTELTE STRUKTUREN\nfirma = {\n    \"name\": \"TechCorp\",\n    \"mitarbeiter\": [\n        {\n            \"name\": \"Anna\",\n            \"position\": \"Developer\",\n            \"gehalt\": 60000\n        },\n        {\n            \"name\": \"Ben\",\n            \"position\": \"Designer\",\n            \"gehalt\": 55000\n        }\n    ],\n    \"standorte\": [\"Berlin\", \"MÃ¼nchen\", \"Hamburg\"]\n}\n\nprint(\"\\nğŸ“Š Verschachtelte Struktur:\")\nprint(json.dumps(firma, indent=2, ensure_ascii=False))",
                                "checkpoint": " - `json.dumps()` â†’ Python zu JSON String - `json.loads()` â†’ JSON String zu Python - `indent=` fÃ¼r Formatierung - `ensure_ascii=False` fÃ¼r Umlaute"
                        },
                        {
                                "number": 2,
                                "title": "JSON Dateien lesen/schreiben",
                                "goal": "JSON in Dateien speichern und laden",
                                "why": "Perfekt fÃ¼r Konfigurationen und Daten-Austausch!",
                                "instruction": "",
                                "code": "import json\nfrom pathlib import Path\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ’¾ JSON DATEIEN\")\nprint(\"=\" * 60)\n\n# Daten vorbereiten\neinstellungen = {\n    \"app_name\": \"Meine App\",\n    \"version\": \"1.0.0\",\n    \"sprache\": \"de\",\n    \"theme\": \"dunkel\",\n    \"benachrichtigungen\": {\n        \"email\": True,\n        \"push\": False,\n        \"sound\": True\n    },\n    \"letzte_Ã¤nderung\": \"2024-01-15\",\n    \"favoriten\": [\"Python\", \"JavaScript\", \"SQL\"]\n}\n\n# IN DATEI SCHREIBEN\nconfig_datei = Path(\"config.json\")\n\n# Methode 1: dump() - Direkt in Datei\nwith open(config_datei, \"w\", encoding=\"utf-8\") as f:\n    json.dump(einstellungen, f, indent=2, ensure_ascii=False)\n\nprint(f\"âœ… Gespeichert in: {config_datei}\")\n\n# AUS DATEI LESEN\n# Methode 1: load() - Direkt aus Datei\nwith open(config_datei, \"r\", encoding=\"utf-8\") as f:\n    geladene_config = json.load(f)\n\nprint(f\"\\nğŸ“– Geladen:\")\nprint(f\"App: {geladene_config['app_name']}\")\nprint(f\"Version: {geladene_config['version']}\")\nprint(f\"Email-Benachrichtigungen: {geladene_config['benachrichtigungen']['email']}\")\n\n# SCHÃ–NER MIT PATHLIB\nconfig_pfad = Path(\"settings.json\")\n\n# Schreiben\nconfig_pfad.write_text(\n    json.dumps(einstellungen, indent=2, ensure_ascii=False),\n    encoding=\"utf-8\"\n)\nprint(f\"\\nâœ… Auch gespeichert in: {config_pfad}\")\n\n# Lesen\nconfig_text = config_pfad.read_text(encoding=\"utf-8\")\nconfig_dict = json.loads(config_text)\nprint(f\"ğŸ“– Auch geladen: {config_dict['app_name']}\")\n\n# FEHLERBEHANDLUNG\nprint(\"\\nâš ï¸ Fehlerbehandlung:\")\n\nungueltig = '{\"name\": \"Test\", \"alter\": 30,}'  # Komma zu viel!\n\ntry:\n    daten = json.loads(ungueltig)\nexcept json.JSONDecodeError as e:\n    print(f\"âŒ UngÃ¼ltiges JSON: {e}\")\n    print(f\"   Zeile {e.lineno}, Spalte {e.colno}\")\n\n# VERSCHIEDENE EINSTELLUNGEN\nbeispiel = {\n    \"text\": \"Hallo Welt\",\n    \"zahl\": 42,\n    \"liste\": [1, 2, 3]\n}\n\n# Kompakt (keine Leerzeichen)\nkompakt = json.dumps(beispiel, separators=(',', ':'))\nprint(f\"\\nğŸ“¦ Kompakt: {kompakt}\")\n\n# Sortierte Keys\nsortiert = json.dumps(beispiel, indent=2, sort_keys=True)\nprint(f\"\\nğŸ”¤ Sortiert:\\n{sortiert}\")",
                                "checkpoint": " - `json.dump()` schreibt in Datei - `json.load()` liest aus Datei - `indent=2` fÃ¼r Lesbarkeit - `JSONDecodeError` fÃ¼r Fehlerbehandlung"
                        },
                        {
                                "number": 3,
                                "title": "Konfigurations-Manager",
                                "goal": "Klasse zum Verwalten von App-Einstellungen",
                                "why": "Professionelle Apps speichern Einstellungen in JSON!",
                                "instruction": "",
                                "code": "import json\nfrom pathlib import Path\nfrom typing import Any, Dict\n\nclass ConfigManager:\n    \"\"\"Verwaltet App-Konfigurationen in JSON\"\"\"\n    \n    def __init__(self, config_datei=\"config.json\"):\n        self.config_datei = Path(config_datei)\n        self.config = {}\n        self.defaults = {}\n        \n        # Lade oder erstelle Config\n        if self.config_datei.exists():\n            self.laden()\n        else:\n            self.erstelle_standard_config()\n    \n    def erstelle_standard_config(self):\n        \"\"\"Erstellt Standard-Konfiguration\"\"\"\n        self.defaults = {\n            \"app\": {\n                \"name\": \"Meine App\",\n                \"version\": \"1.0.0\",\n                \"debug\": False\n            },\n            \"benutzer\": {\n                \"name\": \"\",\n                \"sprache\": \"de\",\n                \"theme\": \"hell\"\n            },\n            \"einstellungen\": {\n                \"auto_save\": True,\n                \"backup\": True,\n                \"max_dateien\": 100\n            }\n        }\n        \n        self.config = self.defaults.copy()\n        self.speichern()\n        print(f\"âœ… Standard-Config erstellt: {self.config_datei}\")\n    \n    def laden(self):\n        \"\"\"LÃ¤dt Konfiguration aus Datei\"\"\"\n        try:\n            text = self.config_datei.read_text(encoding=\"utf-8\")\n            self.config = json.loads(text)\n            print(f\"âœ… Config geladen: {self.config_datei}\")\n            return True\n        except json.JSONDecodeError as e:\n            print(f\"âŒ Fehler beim Laden: {e}\")\n            return False\n        except Exception as e:\n            print(f\"âŒ Unerwarteter Fehler: {e}\")\n            return False\n    \n    def speichern(self):\n        \"\"\"Speichert Konfiguration in Datei\"\"\"\n        try:\n            text = json.dumps(\n                self.config,\n                indent=2,\n                ensure_ascii=False,\n                sort_keys=True\n            )\n            self.config_datei.write_text(text, encoding=\"utf-8\")\n            print(f\"âœ… Config gespeichert\")\n            return True\n        except Exception as e:\n            print(f\"âŒ Fehler beim Speichern: {e}\")\n            return False\n    \n    def get(self, pfad: str, standard=None) -> Any:\n        \"\"\"\n        Holt Wert mit Punkt-Notation\n        \n        Beispiel: get(\"benutzer.name\")\n        \"\"\"\n        teile = pfad.split(\".\")\n        wert = self.config\n        \n        for teil in teile:\n            if isinstance(wert, dict) and teil in wert:\n                wert = wert[teil]\n            else:\n                return standard\n        \n        return wert\n    \n    def set(self, pfad: str, wert: Any, auto_save=True):\n        \"\"\"\n        Setzt Wert mit Punkt-Notation\n        \n        Beispiel: set(\"benutzer.name\", \"Anna\")\n        \"\"\"\n        teile = pfad.split(\".\")\n        ziel = self.config\n        \n        # Navigiere bis zum vorletzten Teil\n        for teil in teile[:-1]:\n            if teil not in ziel:\n                ziel[teil] = {}\n            ziel = ziel[teil]\n        \n        # Setze Wert\n        ziel[teile[-1]] = wert\n        \n        if auto_save:\n            self.speichern()\n    \n    def reset(self, pfad: str = None):\n        \"\"\"Setzt auf Standard zurÃ¼ck\"\"\"\n        if pfad is None:\n            # Alles zurÃ¼cksetzen\n            self.config = self.defaults.copy()\n            self.speichern()\n            print(\"ğŸ”„ Alle Einstellungen zurÃ¼ckgesetzt\")\n        else:\n            # Einzelnen Wert zurÃ¼cksetzen\n            standard_wert = self._get_aus_dict(self.defaults, pfad)\n            if standard_wert is not None:\n                self.set(pfad, standard_wert)\n                print(f\"ğŸ”„ '{pfad}' zurÃ¼ckgesetzt\")\n    \n    def _get_aus_dict(self, dictionary, pfad):\n        \"\"\"Hilfsfunktion zum Navigieren in verschachtelten Dicts\"\"\"\n        teile = pfad.split(\".\")\n        wert = dictionary\n        \n        for teil in teile:\n            if isinstance(wert, dict) and teil in wert:\n                wert = wert[teil]\n            else:\n                return None\n        \n        return wert\n    \n    def zeige(self):\n        \"\"\"Zeigt gesamte Konfiguration\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"âš™ï¸ AKTUELLE KONFIGURATION\")\n        print(\"=\" * 60)\n        print(json.dumps(self.config, indent=2, ensure_ascii=False))\n    \n    def export(self, datei):\n        \"\"\"Exportiert Config in andere Datei\"\"\"\n        pfad = Path(datei)\n        pfad.write_text(\n            json.dumps(self.config, indent=2, ensure_ascii=False),\n            encoding=\"utf-8\"\n        )\n        print(f\"ğŸ“¤ Exportiert nach: {datei}\")\n    \n    def import_from(self, datei):\n        \"\"\"Importiert Config aus anderer Datei\"\"\"\n        pfad = Path(datei)\n        if pfad.exists():\n            text = pfad.read_text(encoding=\"utf-8\")\n            self.config = json.loads(text)\n            self.speichern()\n            print(f\"ğŸ“¥ Importiert von: {datei}\")\n            return True\n        else:\n            print(f\"âŒ Datei nicht gefunden: {datei}\")\n            return False\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 60)\nprint(\"âš™ï¸ KONFIGURATIONS-MANAGER\")\nprint(\"=\" * 60)\n\n# Manager erstellen\nconfig = ConfigManager(\"app_config.json\")\n\n# Werte auslesen\nprint(\"\\nğŸ“– Werte lesen:\")\nprint(f\"App-Name: {config.get('app.name')}\")\nprint(f\"Sprache: {config.get('benutzer.sprache')}\")\nprint(f\"Theme: {config.get('benutzer.theme')}\")\n\n# Werte setzen\nprint(\"\\nâœï¸ Werte Ã¤ndern:\")\nconfig.set(\"benutzer.name\", \"Anna Schmidt\")\nconfig.set(\"benutzer.theme\", \"dunkel\")\nconfig.set(\"einstellungen.max_dateien\", 200)\n\n# Anzeigen\nconfig.zeige()\n\n# Neuen Wert hinzufÃ¼gen\nprint(\"\\nâ• Neuen Wert hinzufÃ¼gen:\")\nconfig.set(\"app.letzte_nutzung\", \"2024-01-15\")\n\n# Export\nprint(\"\\nğŸ“¤ Export/Import:\")\nconfig.export(\"backup_config.json\")\n\n# Reset einzelner Wert\nprint(\"\\nğŸ”„ Reset:\")\nconfig.reset(\"benutzer.theme\")\nprint(f\"Theme nach Reset: {config.get('benutzer.theme')}\")",
                                "checkpoint": " - Config-Manager Klasse - Punkt-Notation fÃ¼r verschachtelte Werte - Auto-Save Funktion - Import/Export - Reset zu Defaults"
                        },
                        {
                                "number": 4,
                                "title": "JSON mit Custom Objects",
                                "goal": "Eigene Classes zu/von JSON konvertieren",
                                "why": "Oft wollen wir komplexe Objekte speichern!",
                                "instruction": "",
                                "code": "import json\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass Benutzer:\n    \"\"\"Benutzer-Klasse\"\"\"\n    \n    def __init__(self, name, email, erstellt=None):\n        self.name = name\n        self.email = email\n        self.erstellt = erstellt or datetime.now()\n    \n    def to_dict(self):\n        \"\"\"Konvertiert zu Dictionary\"\"\"\n        return {\n            \"name\": self.name,\n            \"email\": self.email,\n            \"erstellt\": self.erstellt.isoformat()  # Datum als String\n        }\n    \n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Erstellt aus Dictionary\"\"\"\n        return cls(\n            name=data[\"name\"],\n            email=data[\"email\"],\n            erstellt=datetime.fromisoformat(data[\"erstellt\"])\n        )\n    \n    def __str__(self):\n        return f\"Benutzer({self.name}, {self.email})\"\n\n# CUSTOM JSON ENCODER\nclass BenutzerEncoder(json.JSONEncoder):\n    \"\"\"Custom Encoder fÃ¼r Benutzer-Objekte\"\"\"\n    \n    def default(self, obj):\n        if isinstance(obj, Benutzer):\n            return obj.to_dict()\n        elif isinstance(obj, datetime):\n            return obj.isoformat()\n        \n        # FÃ¼r andere Typen: Standard-Verhalten\n        return super().default(obj)\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ¯ CUSTOM OBJECTS IN JSON\")\nprint(\"=\" * 60)\n\n# Benutzer erstellen\nuser1 = Benutzer(\"Anna\", \"anna@example.com\")\nuser2 = Benutzer(\"Max\", \"max@example.com\")\n\n# Zu JSON mit Custom Encoder\nbenutzer_liste = [user1, user2]\n\njson_string = json.dumps(\n    benutzer_liste,\n    cls=BenutzerEncoder,  # Unser Custom Encoder\n    indent=2\n)\n\nprint(\"\\nğŸ“¤ Benutzer â†’ JSON:\")\nprint(json_string)\n\n# Speichern\nPath(\"benutzer.json\").write_text(json_string, encoding=\"utf-8\")\nprint(\"\\nâœ… In benutzer.json gespeichert\")\n\n# Laden\njson_text = Path(\"benutzer.json\").read_text(encoding=\"utf-8\")\nbenutzer_daten = json.loads(json_text)\n\n# ZurÃ¼ck zu Objekten\ngeladene_benutzer = [Benutzer.from_dict(data) for data in benutzer_daten]\n\nprint(\"\\nğŸ“¥ JSON â†’ Benutzer:\")\nfor user in geladene_benutzer:\n    print(f\"  {user}\")\n    print(f\"    Erstellt: {user.erstellt}\")\n\n# EINFACHERE VARIANTE: dataclasses\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Produkt:\n    \"\"\"Produkt mit dataclass\"\"\"\n    name: str\n    preis: float\n    lagerbestand: int\n\n# Dataclass zu Dict (eingebaut!)\nprodukt = Produkt(\"Laptop\", 999.99, 5)\nprodukt_dict = asdict(produkt)\n\nprint(f\"\\nğŸ“¦ Dataclass â†’ Dict:\")\nprint(produkt_dict)\n\n# Zu JSON\nprodukt_json = json.dumps(produkt_dict, indent=2)\nprint(f\"\\nğŸ“¦ Als JSON:\")\nprint(produkt_json)",
                                "checkpoint": " - Custom JSON Encoder - `.to_dict()` und `.from_dict()` Pattern - Dataclasses fÃ¼r einfache Konvertierung - Datum/Zeit als ISO-String"
                        }
                ]
        },
        {
                "id": 2,
                "weekId": 4,
                "title": "Ausgaben-Tracker (CSV)",
                "duration": "45-60 min",
                "task": {
                        "title": "Ausgaben-Tracker (CSV)",
                        "description": "Lerne CSV-Dateien zu verarbeiten - perfekt fÃ¼r Tabellen-Daten!",
                        "goals": [
                                "csv.writer(): Einfaches CSV schreiben",
                                "csv.reader(): CSV lesen",
                                "csv.DictWriter(): Dicts zu CSV",
                                "csv.DictReader(): CSV zu Dicts",
                                "delimiter: Andere Trennzeichen",
                                "quoting: AnfÃ¼hrungszeichen-Regeln",
                                "Append-Modus: Daten anhÃ¤ngen",
                                "Praktische Anwendung: Ausgaben tracken"
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "CSV Grundlagen",
                                "goal": "CSV lesen und schreiben verstehen",
                                "why": "",
                                "instruction": "",
                                "code": "import csv\nfrom pathlib import Path\n\nprint(\"=\" * 60)\nprint(\"ğŸ“Š CSV GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# CSV SCHREIBEN\ndaten = [\n    [\"Name\", \"Alter\", \"Stadt\"],  # Header\n    [\"Anna\", 28, \"Berlin\"],\n    [\"Max\", 35, \"MÃ¼nchen\"],\n    [\"Lisa\", 42, \"Hamburg\"]\n]\n\ncsv_datei = Path(\"personen.csv\")\n\n# Methode 1: Mit csv.writer\nwith open(csv_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f)\n    writer.writerows(daten)  # Alle Zeilen auf einmal\n\nprint(f\"âœ… CSV erstellt: {csv_datei}\")\n\n# Datei anzeigen\nprint(f\"\\nğŸ“„ Inhalt:\")\nprint(csv_datei.read_text(encoding=\"utf-8\"))\n\n# CSV LESEN\n# Methode 1: Mit csv.reader\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.reader(f)\n    \n    print(\"ğŸ“– Gelesen mit reader:\")\n    for zeile in reader:\n        print(f\"  {zeile}\")\n\n# Methode 2: Mit DictReader (besser!)\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    \n    print(\"\\nğŸ“– Gelesen mit DictReader:\")\n    for zeile in reader:\n        # Jede Zeile ist ein Dict!\n        print(f\"  Name: {zeile['Name']}, Alter: {zeile['Alter']}, Stadt: {zeile['Stadt']}\")\n\n# VERSCHIEDENE TRENNZEICHEN\n# StandardmÃ¤ÃŸig: Komma\n# Aber kann auch sein: Semikolon, Tab, Pipe\n\n# Semicolon-separated\ndaten_semi = [\n    [\"Produkt\", \"Preis\", \"Menge\"],\n    [\"Laptop\", \"999.99\", \"5\"],\n    [\"Maus\", \"19.99\", \"50\"]\n]\n\nsemi_datei = Path(\"produkte.csv\")\n\nwith open(semi_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f, delimiter=\";\")  # Semikolon!\n    writer.writerows(daten_semi)\n\nprint(f\"\\nâœ… CSV mit Semikolon: {semi_datei}\")\nprint(semi_datei.read_text())\n\n# Lesen mit Semikolon\nwith open(semi_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f, delimiter=\";\")\n    \n    for zeile in reader:\n        print(f\"  {zeile['Produkt']}: {zeile['Preis']}â‚¬\")\n\n# QUOTING (AnfÃ¼hrungszeichen)\n# Wichtig wenn Werte Kommas enthalten!\n\ndaten_mit_kommas = [\n    [\"Name\", \"Adresse\", \"Notiz\"],\n    [\"Anna\", \"HauptstraÃŸe 1, 10115 Berlin\", \"Mag Pizza, Pasta\"],\n    [\"Max\", \"Bahnhofstr. 2, MÃ¼nchen\", \"Keine\"]\n]\n\nquoted_datei = Path(\"mit_kommas.csv\")\n\nwith open(quoted_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f, quoting=csv.QUOTE_MINIMAL)  # Nur wenn nÃ¶tig\n    writer.writerows(daten_mit_kommas)\n\nprint(f\"\\nâœ… CSV mit Kommas in Werten:\")\nprint(quoted_datei.read_text())",
                                "checkpoint": " - `csv.writer()` schreibt CSV - `csv.reader()` liest CSV - `csv.DictReader()` liest als Dicts - `delimiter=` fÃ¼r andere Trennzeichen - `quoting=` fÃ¼r AnfÃ¼hrungszeichen"
                        },
                        {
                                "number": 2,
                                "title": "CSV mit DictWriter",
                                "goal": "CSV mit Dictionary-Daten schreiben",
                                "why": "Dicts sind lesbarer und flexibler!",
                                "instruction": "",
                                "code": "import csv\nfrom pathlib import Path\nfrom datetime import datetime\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ“ CSV MIT DICTWRITER\")\nprint(\"=\" * 60)\n\n# Daten als Liste von Dicts\nmitarbeiter = [\n    {\"name\": \"Anna\", \"position\": \"Developer\", \"gehalt\": 60000, \"start\": \"2020-01-15\"},\n    {\"name\": \"Max\", \"position\": \"Designer\", \"gehalt\": 55000, \"start\": \"2019-06-01\"},\n    {\"name\": \"Lisa\", \"position\": \"Manager\", \"gehalt\": 70000, \"start\": \"2018-03-20\"}\n]\n\ncsv_datei = Path(\"mitarbeiter.csv\")\n\n# Mit DictWriter\nwith open(csv_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    # Spalten-Namen aus dem ersten Dict\n    fieldnames = [\"name\", \"position\", \"gehalt\", \"start\"]\n    \n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    \n    # Header schreiben\n    writer.writeheader()\n    \n    # Daten schreiben\n    writer.writerows(mitarbeiter)\n\nprint(f\"âœ… Mitarbeiter-CSV erstellt\")\nprint(csv_datei.read_text())\n\n# Lesen mit DictReader\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    \n    print(\"\\nğŸ‘¥ Mitarbeiter:\")\n    for person in reader:\n        print(f\"  {person['name']}: {person['position']} ({person['gehalt']}â‚¬)\")\n\n# EINZELNE ZEILEN HINZUFÃœGEN (Append)\nneuer_mitarbeiter = {\n    \"name\": \"Tom\",\n    \"position\": \"Analyst\",\n    \"gehalt\": 52000,\n    \"start\": \"2024-01-01\"\n}\n\nwith open(csv_datei, \"a\", newline=\"\", encoding=\"utf-8\") as f:  # 'a' = append\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writerow(neuer_mitarbeiter)  # Einzelne Zeile\n\nprint(f\"\\nâœ… Neuer Mitarbeiter hinzugefÃ¼gt\")\n\n# Alle lesen\nwith open(csv_datei, \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    alle = list(reader)\n    print(f\"Jetzt {len(alle)} Mitarbeiter\")\n\n# FILTERN UND NEUE CSV ERSTELLEN\n# Nur Mitarbeiter mit Gehalt > 55000\nhohe_gehÃ¤lter = [m for m in alle if int(m[\"gehalt\"]) > 55000]\n\ngefiltert_datei = Path(\"hohe_gehaelter.csv\")\n\nwith open(gefiltert_datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writeheader()\n    writer.writerows(hohe_gehÃ¤lter)\n\nprint(f\"\\nğŸ’° Hohe GehÃ¤lter ({len(hohe_gehÃ¤lter)} Mitarbeiter):\")\nprint(gefiltert_datei.read_text())",
                                "checkpoint": " - `csv.DictWriter()` schreibt Dicts - `.writeheader()` fÃ¼r Spalten-Namen - `.writerow()` fÃ¼r eine Zeile - `.writerows()` fÃ¼r mehrere Zeilen - Append-Modus mit `'a'`"
                        },
                        {
                                "number": 3,
                                "title": "Ausgaben-Tracker",
                                "goal": "Praktisches Tool zum Tracken von Ausgaben",
                                "why": "Real-World Anwendung von CSV!",
                                "instruction": "",
                                "code": "import csv\nfrom pathlib import Path\nfrom datetime import datetime\nfrom collections import defaultdict\n\nclass AusgabenTracker:\n    \"\"\"Trackt Ausgaben in CSV\"\"\"\n    \n    KATEGORIEN = [\n        \"Lebensmittel\", \"Transport\", \"Wohnung\",\n        \"Unterhaltung\", \"Gesundheit\", \"Sonstiges\"\n    ]\n    \n    FIELDNAMES = [\"datum\", \"betrag\", \"kategorie\", \"beschreibung\", \"zahlungsart\"]\n    \n    def __init__(self, datei=\"ausgaben.csv\"):\n        self.datei = Path(datei)\n        \n        # Erstelle Datei wenn nicht vorhanden\n        if not self.datei.exists():\n            self._erstelle_datei()\n    \n    def _erstelle_datei(self):\n        \"\"\"Erstellt leere CSV mit Header\"\"\"\n        with open(self.datei, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.DictWriter(f, fieldnames=self.FIELDNAMES)\n            writer.writeheader()\n        print(f\"âœ… Neue Ausgaben-Datei erstellt: {self.datei}\")\n    \n    def ausgabe_hinzufÃ¼gen(self, betrag, kategorie, beschreibung, zahlungsart=\"Bar\"):\n        \"\"\"FÃ¼gt neue Ausgabe hinzu\"\"\"\n        if kategorie not in self.KATEGORIEN:\n            print(f\"âš ï¸ Unbekannte Kategorie: {kategorie}\")\n            print(f\"VerfÃ¼gbar: {', '.join(self.KATEGORIEN)}\")\n            return False\n        \n        ausgabe = {\n            \"datum\": datetime.now().strftime(\"%Y-%m-%d\"),\n            \"betrag\": f\"{betrag:.2f}\",\n            \"kategorie\": kategorie,\n            \"beschreibung\": beschreibung,\n            \"zahlungsart\": zahlungsart\n        }\n        \n        with open(self.datei, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.DictWriter(f, fieldnames=self.FIELDNAMES)\n            writer.writerow(ausgabe)\n        \n        print(f\"âœ… Ausgabe hinzugefÃ¼gt: {betrag:.2f}â‚¬ - {beschreibung}\")\n        return True\n    \n    def alle_ausgaben(self):\n        \"\"\"Liest alle Ausgaben\"\"\"\n        with open(self.datei, \"r\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            return list(reader)\n    \n    def ausgaben_nach_kategorie(self, kategorie):\n        \"\"\"Filtert nach Kategorie\"\"\"\n        alle = self.alle_ausgaben()\n        return [a for a in alle if a[\"kategorie\"] == kategorie]\n    \n    def ausgaben_nach_monat(self, jahr, monat):\n        \"\"\"Filtert nach Monat\"\"\"\n        alle = self.alle_ausgaben()\n        monat_str = f\"{jahr}-{monat:02d}\"\n        return [a for a in alle if a[\"datum\"].startswith(monat_str)]\n    \n    def summe_gesamt(self):\n        \"\"\"Berechnet Gesamtsumme\"\"\"\n        alle = self.alle_ausgaben()\n        return sum(float(a[\"betrag\"]) for a in alle)\n    \n    def summe_nach_kategorie(self):\n        \"\"\"Summen pro Kategorie\"\"\"\n        alle = self.alle_ausgaben()\n        summen = defaultdict(float)\n        \n        for ausgabe in alle:\n            summen[ausgabe[\"kategorie\"]] += float(ausgabe[\"betrag\"])\n        \n        return dict(summen)\n    \n    def summe_nach_monat(self):\n        \"\"\"Summen pro Monat\"\"\"\n        alle = self.alle_ausgaben()\n        summen = defaultdict(float)\n        \n        for ausgabe in alle:\n            monat = ausgabe[\"datum\"][:7]  # YYYY-MM\n            summen[monat] += float(ausgabe[\"betrag\"])\n        \n        return dict(summen)\n    \n    def bericht(self):\n        \"\"\"Zeigt umfassenden Bericht\"\"\"\n        alle = self.alle_ausgaben()\n        \n        if not alle:\n            print(\"\\nğŸ“­ Keine Ausgaben vorhanden\")\n            return\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(\"ğŸ’° AUSGABEN-BERICHT\")\n        print(\"=\" * 70)\n        \n        # Gesamt\n        gesamt = self.summe_gesamt()\n        print(f\"\\nGesamtausgaben: {gesamt:.2f}â‚¬\")\n        print(f\"Anzahl Transaktionen: {len(alle)}\")\n        print(f\"Durchschnitt: {gesamt / len(alle):.2f}â‚¬\")\n        \n        # Nach Kategorie\n        print(f\"\\nğŸ“Š Nach Kategorie:\")\n        kat_summen = self.summe_nach_kategorie()\n        for kat in sorted(kat_summen, key=kat_summen.get, reverse=True):\n            betrag = kat_summen[kat]\n            prozent = (betrag / gesamt) * 100\n            print(f\"  {kat:<15} {betrag:>8.2f}â‚¬  ({prozent:>5.1f}%)\")\n        \n        # Nach Monat\n        print(f\"\\nğŸ“… Nach Monat:\")\n        monat_summen = self.summe_nach_monat()\n        for monat in sorted(monat_summen.keys()):\n            print(f\"  {monat}: {monat_summen[monat]:.2f}â‚¬\")\n        \n        # Letzte 5 Ausgaben\n        print(f\"\\nğŸ• Letzte 5 Ausgaben:\")\n        for ausgabe in reversed(alle[-5:]):\n            print(f\"  {ausgabe['datum']} | {float(ausgabe['betrag']):>7.2f}â‚¬ | {ausgabe['kategorie']:<15} | {ausgabe['beschreibung']}\")\n    \n    def export_monat(self, jahr, monat, ziel_datei):\n        \"\"\"Exportiert einen Monat\"\"\"\n        ausgaben = self.ausgaben_nach_monat(jahr, monat)\n        \n        pfad = Path(ziel_datei)\n        with open(pfad, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.DictWriter(f, fieldnames=self.FIELDNAMES)\n            writer.writeheader()\n            writer.writerows(ausgaben)\n        \n        summe = sum(float(a[\"betrag\"]) for a in ausgaben)\n        print(f\"ğŸ“¤ {len(ausgaben)} Ausgaben exportiert ({summe:.2f}â‚¬)\")\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 70)\nprint(\"ğŸ’° AUSGABEN-TRACKER\")\nprint(\"=\" * 70)\n\ntracker = AusgabenTracker(\"meine_ausgaben.csv\")\n\n# Ausgaben hinzufÃ¼gen\nprint(\"\\nâ• FÃ¼ge Ausgaben hinzu:\")\ntracker.ausgabe_hinzufÃ¼gen(45.50, \"Lebensmittel\", \"Wocheneinkauf Supermarkt\")\ntracker.ausgabe_hinzufÃ¼gen(12.00, \"Transport\", \"U-Bahn Monatskarte\", \"Karte\")\ntracker.ausgabe_hinzufÃ¼gen(8.50, \"Unterhaltung\", \"Kino\", \"Bar\")\ntracker.ausgabe_hinzufÃ¼gen(85.00, \"Lebensmittel\", \"Restaurant\", \"Karte\")\ntracker.ausgabe_hinzufÃ¼gen(30.00, \"Gesundheit\", \"Apotheke\", \"Bar\")\n\n# Bericht\ntracker.bericht()\n\n# Nach Kategorie filtern\nprint(\"\\nğŸ” Nur Lebensmittel:\")\nlebensmittel = tracker.ausgaben_nach_kategorie(\"Lebensmittel\")\nfor ausgabe in lebensmittel:\n    print(f\"  {ausgabe['datum']}: {ausgabe['beschreibung']} - {ausgabe['betrag']}â‚¬\")",
                                "checkpoint": " - VollstÃ¤ndiger Ausgaben-Tracker - CRUD-Operationen (Create, Read) - Berichte und Statistiken - Export-Funktion - Kategorisierung"
                        }
                ]
        },
        {
                "id": 3,
                "weekId": 4,
                "title": "Geburtstags-Reminder (Datetime)",
                "duration": "45-60 min",
                "task": {
                        "title": "Geburtstags-Reminder (Datetime)",
                        "description": "Meistere das Datetime-Modul fÃ¼r Datum- und Zeit-Operationen!",
                        "goals": [
                                "datetime.now(): Aktuelles Datum/Zeit",
                                "date.today(): Nur Datum",
                                "strptime(): String â†’ Datetime",
                                "strftime(): Datetime â†’ String",
                                "timedelta: Zeitspannen",
                                "Rechnen: Addition/Subtraktion",
                                "Differenzen: Tage zwischen Daten",
                                "Komponenten: year, month, day, etc."
                        ]
                },
                "steps": [
                        {
                                "number": 1,
                                "title": "Datetime Grundlagen",
                                "goal": "Mit Datum und Zeit arbeiten",
                                "why": "Zeit-Daten sind in fast jeder App wichtig!",
                                "instruction": "",
                                "code": "from datetime import datetime, date, time, timedelta\nimport time as time_module\n\nprint(\"=\" * 60)\nprint(\"â° DATETIME GRUNDLAGEN\")\nprint(\"=\" * 60)\n\n# AKTUELLES DATUM/ZEIT\njetzt = datetime.now()\nprint(f\"\\nğŸ• Jetzt: {jetzt}\")\nprint(f\"Typ: {type(jetzt)}\")\n\n# Komponenten\nprint(f\"\\nJahr: {jetzt.year}\")\nprint(f\"Monat: {jetzt.month}\")\nprint(f\"Tag: {jetzt.day}\")\nprint(f\"Stunde: {jetzt.hour}\")\nprint(f\"Minute: {jetzt.minute}\")\nprint(f\"Sekunde: {jetzt.second}\")\n\n# NUR DATUM\nheute = date.today()\nprint(f\"\\nğŸ“… Heute: {heute}\")\nprint(f\"Wochentag: {heute.weekday()}\")  # 0=Montag, 6=Sonntag\nprint(f\"Wochentag (ISO): {heute.isoweekday()}\")  # 1=Montag, 7=Sonntag\n\nwochentage = [\"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \n              \"Freitag\", \"Samstag\", \"Sonntag\"]\nprint(f\"Heute ist {wochentage[heute.weekday()]}\")\n\n# NUR ZEIT\njetzt_zeit = datetime.now().time()\nprint(f\"\\nğŸ• Aktuelle Uhrzeit: {jetzt_zeit}\")\n\n# DATUM ERSTELLEN\ngeburtstag = date(1990, 5, 15)\nprint(f\"\\nğŸ‚ Geburtstag: {geburtstag}\")\n\n# DATETIME ERSTELLEN\ntermin = datetime(2024, 12, 24, 18, 30, 0)\nprint(f\"ğŸ“… Termin: {termin}\")\n\n# STRING â†’ DATETIME (Parsen)\ndatum_str = \"2024-01-15\"\ndatum = datetime.strptime(datum_str, \"%Y-%m-%d\")\nprint(f\"\\nğŸ“ Geparsed: '{datum_str}' â†’ {datum}\")\n\ndatum_str2 = \"15.01.2024 14:30\"\ndatum2 = datetime.strptime(datum_str2, \"%d.%m.%Y %H:%M\")\nprint(f\"ğŸ“ Geparsed: '{datum_str2}' â†’ {datum2}\")\n\n# DATETIME â†’ STRING (Formatieren)\nformatiert = jetzt.strftime(\"%d.%m.%Y %H:%M:%S\")\nprint(f\"\\nğŸ“ Formatiert: {formatiert}\")\n\n# Verschiedene Formate\nprint(\"\\nğŸ“‹ Verschiedene Formate:\")\nprint(f\"Standard: {jetzt.strftime('%Y-%m-%d')}\")\nprint(f\"Deutsch: {jetzt.strftime('%d.%m.%Y')}\")\nprint(f\"US: {jetzt.strftime('%m/%d/%Y')}\")\nprint(f\"Voll: {jetzt.strftime('%A, %d. %B %Y %H:%M:%S')}\")\nprint(f\"ISO: {jetzt.isoformat()}\")\n\n# FORMAT-CODES ÃœBERSICHT\nprint(\"\\nğŸ“– Format-Codes:\")\ncodes = {\n    \"%Y\": \"Jahr (4-stellig)\",\n    \"%m\": \"Monat (01-12)\",\n    \"%d\": \"Tag (01-31)\",\n    \"%H\": \"Stunde (00-23)\",\n    \"%M\": \"Minute (00-59)\",\n    \"%S\": \"Sekunde (00-59)\",\n    \"%A\": \"Wochentag (ausgeschrieben)\",\n    \"%B\": \"Monat (ausgeschrieben)\",\n    \"%a\": \"Wochentag (kurz)\",\n    \"%b\": \"Monat (kurz)\"\n}\n\nfor code, beschreibung in codes.items():\n    print(f\"  {code}: {beschreibung}\")",
                                "checkpoint": " - `datetime.now()` fÃ¼r aktuelles Datum/Zeit - `date.today()` nur fÃ¼r Datum - `.strptime()` parst Strings - `.strftime()` formatiert zu String - Format-Codes wie `%Y`, `%m`, `%d`"
                        },
                        {
                                "number": 2,
                                "title": "Zeitdifferenzen (Timedelta)",
                                "goal": "Mit Zeitspannen rechnen",
                                "why": "\"In 7 Tagen\", \"Vor 3 Stunden\" - das braucht timedelta!",
                                "instruction": "",
                                "code": "from datetime import datetime, timedelta\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"â±ï¸ TIMEDELTA - ZEITDIFFERENZEN\")\nprint(\"=\" * 60)\n\n# TIMEDELTA ERSTELLEN\nein_tag = timedelta(days=1)\neine_woche = timedelta(weeks=1)\nzwei_stunden = timedelta(hours=2)\ndreiÃŸig_minuten = timedelta(minutes=30)\n\nprint(\"\\nğŸ“ Timedelta-Objekte:\")\nprint(f\"1 Tag: {ein_tag}\")\nprint(f\"1 Woche: {eine_woche}\")\nprint(f\"2 Stunden: {zwei_stunden}\")\n\n# RECHNEN MIT DATEN\nheute = datetime.now()\nmorgen = heute + ein_tag\ngestern = heute - ein_tag\nnÃ¤chste_woche = heute + eine_woche\n\nprint(f\"\\nâ•â– Rechnen:\")\nprint(f\"Heute: {heute.strftime('%d.%m.%Y')}\")\nprint(f\"Morgen: {morgen.strftime('%d.%m.%Y')}\")\nprint(f\"Gestern: {gestern.strftime('%d.%m.%Y')}\")\nprint(f\"NÃ¤chste Woche: {nÃ¤chste_woche.strftime('%d.%m.%Y')}\")\n\n# DIFFERENZ ZWISCHEN DATEN\ngeburtstag = datetime(1990, 5, 15)\nalter_timedelta = heute - geburtstag\n\nprint(f\"\\nğŸ‚ Alter-Berechnung:\")\nprint(f\"Geburtstag: {geburtstag.strftime('%d.%m.%Y')}\")\nprint(f\"Differenz: {alter_timedelta.days} Tage\")\nprint(f\"Das sind {alter_timedelta.days // 365} Jahre\")\n\n# BIS ZUM NÃ„CHSTEN EREIGNIS\nweihnachten = datetime(2024, 12, 24)\nbis_weihnachten = weihnachten - heute\n\nif bis_weihnachten.days > 0:\n    print(f\"\\nğŸ„ Bis Weihnachten:\")\n    print(f\"Noch {bis_weihnachten.days} Tage\")\n    wochen = bis_weihnachten.days // 7\n    print(f\"Das sind {wochen} Wochen\")\n\n# ARBEITSTAGE BERECHNEN\ndef arbeitstage_zwischen(start, ende):\n    \"\"\"ZÃ¤hlt Arbeitstage (Mo-Fr) zwischen zwei Daten\"\"\"\n    tage = 0\n    aktuell = start\n    \n    while aktuell <= ende:\n        # 0-4 = Mo-Fr\n        if aktuell.weekday() < 5:\n            tage += 1\n        aktuell += timedelta(days=1)\n    \n    return tage\n\nstart = datetime(2024, 1, 1)\nende = datetime(2024, 1, 31)\narbeitstage = arbeitstage_zwischen(start, ende)\n\nprint(f\"\\nğŸ’¼ Arbeitstage:\")\nprint(f\"Januar 2024: {arbeitstage} Arbeitstage\")\n\n# KOMPONENTEN VON TIMEDELTA\ndelta = timedelta(days=10, hours=5, minutes=30, seconds=15)\n\nprint(f\"\\nğŸ“Š Timedelta-Komponenten:\")\nprint(f\"Timedelta: {delta}\")\nprint(f\"Total Sekunden: {delta.total_seconds()}\")\nprint(f\"Tage: {delta.days}\")\nprint(f\"Sekunden (Rest): {delta.seconds}\")",
                                "checkpoint": " - `timedelta()` fÃ¼r Zeitspannen - Addition/Subtraktion mit Daten - `.days`, `.seconds`, `.total_seconds()` - Differenzen berechnen - Countdown und Alter"
                        },
                        {
                                "number": 3,
                                "title": "Geburtstags-Reminder System",
                                "goal": "Praktisches Tool fÃ¼r Geburtstage",
                                "why": "Kombiniert alle Datetime-Konzepte!",
                                "instruction": "",
                                "code": "from datetime import datetime, timedelta\nimport json\nfrom pathlib import Path\n\nclass GeburtstagReminder:\n    \"\"\"Verwaltet Geburtstage und erinnert\"\"\"\n    \n    def __init__(self, datei=\"geburtstage.json\"):\n        self.datei = Path(datei)\n        self.geburtstage = {}\n        self.laden()\n    \n    def laden(self):\n        \"\"\"LÃ¤dt Geburtstage aus JSON\"\"\"\n        if self.datei.exists():\n            text = self.datei.read_text(encoding=\"utf-8\")\n            self.geburtstage = json.loads(text)\n            print(f\"âœ… {len(self.geburtstage)} Geburtstage geladen\")\n        else:\n            print(\"â„¹ï¸ Keine Geburtstage vorhanden\")\n    \n    def speichern(self):\n        \"\"\"Speichert Geburtstage\"\"\"\n        text = json.dumps(self.geburtstage, indent=2, ensure_ascii=False)\n        self.datei.write_text(text, encoding=\"utf-8\")\n    \n    def hinzufÃ¼gen(self, name, datum_str):\n        \"\"\"\n        FÃ¼gt Geburtstag hinzu\n        \n        datum_str Format: \"YYYY-MM-DD\" oder \"DD.MM.YYYY\"\n        \"\"\"\n        try:\n            # Versuche verschiedene Formate\n            for fmt in [\"%Y-%m-%d\", \"%d.%m.%Y\"]:\n                try:\n                    datum = datetime.strptime(datum_str, fmt)\n                    break\n                except ValueError:\n                    continue\n            else:\n                print(f\"âŒ UngÃ¼ltiges Datumsformat: {datum_str}\")\n                return False\n            \n            self.geburtstage[name] = datum.strftime(\"%Y-%m-%d\")\n            self.speichern()\n            print(f\"âœ… Geburtstag hinzugefÃ¼gt: {name} ({datum.strftime('%d.%m.%Y')})\")\n            return True\n            \n        except Exception as e:\n            print(f\"âŒ Fehler: {e}\")\n            return False\n    \n    def entfernen(self, name):\n        \"\"\"Entfernt Geburtstag\"\"\"\n        if name in self.geburtstage:\n            del self.geburtstage[name]\n            self.speichern()\n            print(f\"ğŸ—‘ï¸ Geburtstag entfernt: {name}\")\n            return True\n        else:\n            print(f\"âŒ Nicht gefunden: {name}\")\n            return False\n    \n    def nÃ¤chster_geburtstag(self, name):\n        \"\"\"Berechnet nÃ¤chsten Geburtstag einer Person\"\"\"\n        if name not in self.geburtstage:\n            return None\n        \n        geburtsdatum = datetime.strptime(self.geburtstage[name], \"%Y-%m-%d\")\n        heute = datetime.now()\n        \n        # NÃ¤chster Geburtstag in diesem Jahr\n        nÃ¤chster = geburtsdatum.replace(year=heute.year)\n        \n        # Wenn schon vorbei, nÃ¤chstes Jahr\n        if nÃ¤chster < heute:\n            nÃ¤chster = geburtsdatum.replace(year=heute.year + 1)\n        \n        return nÃ¤chster\n    \n    def alter(self, name):\n        \"\"\"Berechnet aktuelles Alter\"\"\"\n        if name not in self.geburtstage:\n            return None\n        \n        geburtsdatum = datetime.strptime(self.geburtstage[name], \"%Y-%m-%d\")\n        heute = datetime.now()\n        \n        alter = heute.year - geburtsdatum.year\n        \n        # Noch nicht Geburtstag gehabt dieses Jahr?\n        if (heute.month, heute.day) < (geburtsdatum.month, geburtsdatum.day):\n            alter -= 1\n        \n        return alter\n    \n    def bald_geburtstage(self, tage=30):\n        \"\"\"Findet Geburtstage in den nÃ¤chsten N Tagen\"\"\"\n        heute = datetime.now()\n        grenze = heute + timedelta(days=tage)\n        \n        bald = []\n        \n        for name, datum_str in self.geburtstage.items():\n            nÃ¤chster = self.nÃ¤chster_geburtstag(name)\n            \n            if heute <= nÃ¤chster <= grenze:\n                tage_bis = (nÃ¤chster - heute).days\n                alter = self.alter(name) + 1  # Alter am Geburtstag\n                \n                bald.append({\n                    'name': name,\n                    'datum': nÃ¤chster,\n                    'tage_bis': tage_bis,\n                    'alter': alter\n                })\n        \n        # Sortieren nach Datum\n        bald.sort(key=lambda x: x['datum'])\n        \n        return bald\n    \n    def heute_geburtstag(self):\n        \"\"\"Findet wer heute Geburtstag hat\"\"\"\n        heute = datetime.now()\n        \n        heute_liste = []\n        \n        for name, datum_str in self.geburtstage.items():\n            geburtsdatum = datetime.strptime(datum_str, \"%Y-%m-%d\")\n            \n            if (geburtsdatum.month, geburtsdatum.day) == (heute.month, heute.day):\n                alter = self.alter(name) + 1\n                heute_liste.append({\n                    'name': name,\n                    'alter': alter\n                })\n        \n        return heute_liste\n    \n    def Ã¼bersicht(self):\n        \"\"\"Zeigt alle Geburtstage\"\"\"\n        if not self.geburtstage:\n            print(\"\\nğŸ“­ Keine Geburtstage gespeichert\")\n            return\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(\"ğŸ‚ GEBURTSTAGS-ÃœBERSICHT\")\n        print(\"=\" * 70)\n        \n        # Sortiert nach nÃ¤chstem Geburtstag\n        personen = []\n        for name in self.geburtstage:\n            nÃ¤chster = self.nÃ¤chster_geburtstag(name)\n            tage_bis = (nÃ¤chster - datetime.now()).days\n            alter = self.alter(name)\n            \n            personen.append({\n                'name': name,\n                'nÃ¤chster': nÃ¤chster,\n                'tage_bis': tage_bis,\n                'alter': alter\n            })\n        \n        personen.sort(key=lambda x: x['tage_bis'])\n        \n        print(f\"\\n{'Name':<20} {'Datum':<12} {'Alter':<6} {'In':<15}\")\n        print(\"-\" * 70)\n        \n        for p in personen:\n            datum_str = p['nÃ¤chster'].strftime(\"%d.%m.%Y\")\n            \n            if p['tage_bis'] == 0:\n                bis_str = \"HEUTE! ğŸ‰\"\n            elif p['tage_bis'] == 1:\n                bis_str = \"Morgen!\"\n            else:\n                bis_str = f\"{p['tage_bis']} Tagen\"\n            \n            print(f\"{p['name']:<20} {datum_str:<12} {p['alter']:<6} {bis_str:<15}\")\n    \n    def erinnerungen(self):\n        \"\"\"Zeigt aktuelle Erinnerungen\"\"\"\n        # Heute\n        heute = self.heute_geburtstag()\n        if heute:\n            print(\"\\nğŸ‰ HEUTE GEBURTSTAG:\")\n            for person in heute:\n                print(f\"  ğŸ‚ {person['name']} wird {person['alter']} Jahre alt!\")\n        \n        # Bald (nÃ¤chste 7 Tage)\n        bald = self.bald_geburtstage(7)\n        if bald:\n            print(\"\\nâ° DEMNÃ„CHST (nÃ¤chste 7 Tage):\")\n            for person in bald:\n                if person['tage_bis'] > 0:  # Nicht heute (schon oben gezeigt)\n                    datum = person['datum'].strftime(\"%d.%m.\")\n                    print(f\"  ğŸ“… {person['name']}: {datum} (in {person['tage_bis']} Tagen, wird {person['alter']})\")\n        \n        if not heute and not bald:\n            print(\"\\nâœ… Keine Geburtstage in den nÃ¤chsten 7 Tagen\")\n\n# === TESTEN ===\nprint(\"\\n\" + \"=\" * 70)\nprint(\"ğŸ‚ GEBURTSTAGS-REMINDER\")\nprint(\"=\" * 70)\n\nreminder = GeburtstagReminder()\n\n# Geburtstage hinzufÃ¼gen\nprint(\"\\nâ• FÃ¼ge Geburtstage hinzu:\")\nreminder.hinzufÃ¼gen(\"Anna\", \"1990-03-15\")\nreminder.hinzufÃ¼gen(\"Max\", \"1985-07-22\")\nreminder.hinzufÃ¼gen(\"Lisa\", \"1992-12-01\")\n\n# Einen nahen Geburtstag (fÃ¼r Demo)\nheute = datetime.now()\nmorgen = heute + timedelta(days=1)\nreminder.hinzufÃ¼gen(\"Tom\", morgen.strftime(\"%Y-%m-%d\"))\n\n# Ãœbersicht\nreminder.Ã¼bersicht()\n\n# Erinnerungen\nreminder.erinnerungen()\n\n# Alter berechnen\nprint(f\"\\nğŸ‚ Anna ist {reminder.alter('Anna')} Jahre alt\")\n\n# NÃ¤chster Geburtstag\nnÃ¤chster = reminder.nÃ¤chster_geburtstag(\"Anna\")\nprint(f\"NÃ¤chster Geburtstag: {nÃ¤chster.strftime('%d.%m.%Y')}\")",
                                "checkpoint": " - VollstÃ¤ndiger Geburtstags-Reminder - Alter-Berechnung - NÃ¤chste Geburtstage finden - Erinnerungen fÃ¼r heute/bald - JSON-Persistenz"
                        }
                ]
        },
      ]
    },
  ]
};

// Helper functions
const getData = {
  getWeek(weekId) {
    return courseData.weeks.find(w => w.id === weekId);
  },
  
  getDay(weekId, dayId) {
    const week = this.getWeek(weekId);
    if (!week) return null;
    return week.days.find(d => d.id === dayId);
  },
  
  getTotalDays() {
    return courseData.weeks.reduce((total, week) => total + week.days.length, 0);
  },
  
  getAllDays() {
    const allDays = [];
    courseData.weeks.forEach(week => {
      week.days.forEach(day => {
        allDays.push({ weekId: week.id, dayId: day.id, ...day });
      });
    });
    return allDays;
  }
};