# ğŸ 30-Tage Python Kurs - Woche 1: Grundlagen

## ğŸ“– Ãœber Woche 1

**Was du diese Woche lernst:**
Die absoluten Grundlagen von Python - das Fundament fÃ¼r alles Weitere!

**Themen:**
- âœ… Tag 1: Variablen, Datentypen, Operatoren
- âœ… Tag 2: Strings und String-Methoden
- âœ… Tag 3: If/Else Bedingungen
- âœ… Tag 4: Listen
- âœ… Tag 5: For-Schleifen
- âœ… Tag 6: While-Schleifen
- âœ… Tag 7: Funktionen

**Zeitaufwand:** 7 Tage Ã— 5-15 Minuten = ca. 1-2 Stunden gesamt

---

## ğŸ“‹ Ãœberarbeiteter 30-Tage Kursplan

### ğŸŒ± Woche 1: Grundlagen (Tag 1-7)
- Tag 1: Variablen & Operatoren - Taschenrechner
- Tag 2: Strings - Namensgenerator
- Tag 3: If/Else - Chatbot
- Tag 4: Listen - To-Do Liste
- Tag 5: For-Schleifen - Multiplikationstabelle
- Tag 6: While-Schleifen - Zahlenratespiel
- Tag 7: Funktionen - BMI-Rechner

### ğŸŒ¿ Woche 2: Fortgeschrittene Basics (Tag 8-14)
- Tag 8: Dictionaries - Kontaktverwaltung
- Tag 9: List Comprehensions - Datenfilter
- Tag 10: Tuples & Sets - Duplikat-Entferner
- Tag 11: File I/O (lesen) - Textdatei-Analyzer
- Tag 12: File I/O (schreiben) & Error Handling - Notiz-App
- Tag 13: String-Formatierung & Regex Basics - E-Mail Validator
- Tag 14: Datetime - Geburtstags-Countdown

### ğŸŒ³ Woche 3: OOP & Praktische Tools (Tag 15-21)
- Tag 15: Klassen Grundlagen - Bankkonto-Klasse
- Tag 16: Klassen Methoden & Attribute - Kontaktbuch mit Klassen
- Tag 17: Vererbung (Inheritance) - Fahrzeug-Hierarchie
- Tag 18: os & pathlib - Ordner-Organizer
- Tag 19: shutil & glob - Datei-Backup-Tool
- Tag 20: json - Konfigurations-Manager
- Tag 21: csv - Ausgaben-Tracker

### ğŸš€ Woche 4: Fortgeschrittene Anwendungen (Tag 22-30)
- Tag 22: requests - Wetter-App (API)
- Tag 23: Web Scraping Basics - Preis-Monitor
- Tag 24: PIL/Pillow - Batch Bildbearbeitung
- Tag 25: zipfile & Archive - Automatischer Archiver
- Tag 26: sqlite3 Grundlagen - Einfache Datenbank
- Tag 27: sqlite3 mit OOP - Aufgaben-Manager
- Tag 28: argparse - CLI-Tool
- Tag 29: Mini-Projekt: Datei-Manager mit GUI (tkinter)
- Tag 30: Abschlussprojekt: Personal Library Manager (kombiniert alles)

---

# ğŸ“‹ Ãœberarbeiteter 30-Tage Kursplan

## ğŸŒ± Woche 1: Grundlagen (Tag 1-7)
- **Tag 1:** Variablen & Operatoren - Taschenrechner
- **Tag 2:** Strings - Namensgenerator
- **Tag 3:** If/Else - Chatbot
- **Tag 4:** Listen - To-Do Liste
- **Tag 5:** For-Schleifen - Multiplikationstabelle
- **Tag 6:** While-Schleifen - Zahlenratespiel
- **Tag 7:** Funktionen - BMI-Rechner

## ğŸŒ¿ Woche 2: Datenstrukturen & Dateien (Tag 8-14)
- **Tag 8:** Dictionaries - Kontaktverwaltung
- **Tag 9:** Tupel & Sets - Daten-Deduplizierung
- **Tag 10:** File I/O (lesen) - Textdatei-Analyzer
- **Tag 11:** File I/O (schreiben) - Notiz-App mit Speicherfunktion
- **Tag 12:** Error Handling (try/except) - Robuster Input-Handler
- **Tag 13:** List Comprehensions - Datenfilterung
- **Tag 14:** String-Formatierung & Datetime - Event-Reminder

## ğŸŒ³ Woche 3: OOP & Module (Tag 15-21)
- **Tag 15:** Classes Grundlagen - Bankkonto-System
- **Tag 16:** OOP (Methoden & Attribute) - Bibliotheksverwaltung
- **Tag 17:** OOP (Vererbung) - Fahrzeug-Hierarchie
- **Tag 18:** Module erstellen - Eigenes Utility-Modul
- **Tag 19:** os & pathlib - Datei-Organizer
- **Tag 20:** json & pickle - Daten speichern/laden
- **Tag 21:** random & statistics - WÃ¼rfel-Simulator mit Statistik

## ğŸš€ Woche 4: Praktische Anwendungen (Tag 22-30)
- **Tag 22:** csv-Modul - Ausgaben-Tracker
- **Tag 23:** datetime & calendar - Kalender-App
- **Tag 24:** shutil & zipfile - Backup-Tool
- **Tag 25:** glob & regex (Basis) - Datei-Umbenenner
- **Tag 26:** argparse - CLI-Tool (Kommandozeilen-Args)
- **Tag 27:** requests - Wetter-API Client
- **Tag 28:** Projekt: Kontakt-Manager (alles kombiniert)
- **Tag 29:** Projekt: Datei-Sync-Tool
- **Tag 30:** Projekt: Quiz-App mit Highscores

---

**Verbesserungen am Plan:**
âœ… Classes/OOP jetzt in Woche 3 (nicht am Ende)
âœ… GleichmÃ¤ÃŸigere Schwierigkeitskurve
âœ… Mehr Fokus auf Grundlagen vor externen Libraries
âœ… Praktische Projekte am Ende, die alles kombinieren
âœ… Keine Web Scraping (zu komplex fÃ¼r Basis-Kurs)
âœ… Keine GUI (kann in Aufbau-Kurs)

---

## ğŸ“… ÃœBERARBEITETER 30-TAGE KURSPLAN

### ğŸŒ± Woche 1: Grundlagen (Tag 1-7)
- Tag 1: Variablen & Operatoren - Taschenrechner
- Tag 2: Strings - Namensgenerator
- Tag 3: If/Else - Chatbot
- Tag 4: Listen - To-Do Liste
- Tag 5: For-Schleifen - Multiplikationstabelle
- Tag 6: While-Schleifen - Zahlenratespiel
- Tag 7: Funktionen - BMI-Rechner

### ğŸŒ¿ Woche 2: Datenstrukturen & Fehlerbehandlung (Tag 8-14)
- Tag 8: Dictionaries - Kontaktverwaltung
- Tag 9: List Comprehensions - Datenfilter
- Tag 10: Tupel & Sets - Lottozahlen-Generator
- Tag 11: File I/O (lesen) - Textanalyse
- Tag 12: File I/O (schreiben) - Tagebuch-App
- Tag 13: Error Handling - Robuster File-Reader
- Tag 14: **Classes (OOP Basics)** - Bankkonto-Klasse

### ğŸŒ³ Woche 3: OOP & Praktische Tools (Tag 15-21)
- Tag 15: **OOP Vertiefung** - Bibliotheks-System (Inheritance)
- Tag 16: **OOP Advanced** - RPG Charakter-System
- Tag 17: os & pathlib - Datei-Organizer
- Tag 18: shutil & glob - Massen-Umbenennung
- Tag 19: json - Konfigurations-Manager
- Tag 20: csv - Ausgaben-Tracker
- Tag 21: datetime - Event-Planer

### ğŸš€ Woche 4: Fortgeschrittene Anwendungen (Tag 22-30)
- Tag 22: random & collections - Passwort-Generator
- Tag 23: sqlite3 - Einfache Datenbank
- Tag 24: requests - Wetter-App (API)
- Tag 25: PIL/Pillow - Batch Bildbearbeitung
- Tag 26: zipfile - Backup-Tool
- Tag 27: argparse - CLI-Tool
- Tag 28: **Mini-Projekt:** Aufgaben-Manager (OOP + Files + JSON)
- Tag 29: **Mini-Projekt:** Web Scraper mit Daten-Export
- Tag 30: **Abschlussprojekt:** VollstÃ¤ndige Anwendung deiner Wahl

**Ã„nderungen zum ursprÃ¼nglichen Plan:**
- âœ… Classes (OOP) jetzt schon in Woche 2 (Tag 14)
- âœ… OOP Vertiefung in Woche 3 (Tag 15-16)
- âœ… Bessere Progression: Basics â†’ OOP â†’ Libraries â†’ Projekte
- âœ… Mehr Praxisprojekte am Ende
- âœ… Tupel & Sets hinzugefÃ¼gt (wichtige Datenstrukturen)

---

---

## ğŸ“‹ Kompletter 30-Tage Kursplan (Ãœberblick)

### ğŸŒ± Woche 1: Grundlagen (Tag 1-7)
- Tag 1: Variablen & Operatoren - Taschenrechner
- Tag 2: Strings - Namensgenerator
- Tag 3: If/Else - Chatbot
- Tag 4: Listen - To-Do Liste
- Tag 5: For-Schleifen - Multiplikationstabelle
- Tag 6: While-Schleifen - Zahlenratespiel
- Tag 7: Funktionen - BMI-Rechner

### ğŸŒ¿ Woche 2: Datenstrukturen & Dateioperationen (Tag 8-14)
- Tag 8: Dictionaries - Kontaktverwaltung
- Tag 9: Tupel & Sets - Daten-Vergleicher
- Tag 10: List Comprehensions - Datenfilter
- Tag 11: File I/O (lesen) - Textdatei-Analyzer
- Tag 12: File I/O (schreiben) & Error Handling - Notiz-App
- Tag 13: JSON-Dateien - Konfigurations-Manager
- Tag 14: CSV-Dateien - Ausgaben-Tracker

### ğŸŒ³ Woche 3: OOP & Module (Tag 15-21)
- Tag 15: Classes Basics - Bankkonto-Simulator
- Tag 16: Classes (Vererbung) - Tier-Hierarchie
- Tag 17: Classes (Methoden & Properties) - Bibliotheks-System
- Tag 18: Module erstellen - Eigene Library
- Tag 19: Datetime & Time - Geburtstags-Manager
- Tag 20: OS & Pathlib - Datei-Explorer
- Tag 21: Random & Statistics - WÃ¼rfel-Simulator

### ğŸš€ Woche 4: Praktische Anwendungen (Tag 22-30)
- Tag 22: Glob & Shutil - Datei-Organizer
- Tag 23: RegEx Basics - E-Mail Validator
- Tag 24: ZIP-Archive - Backup-Tool
- Tag 25: Requests - Wetter-App (API)
- Tag 26: BeautifulSoup - Web Scraper
- Tag 27: PIL/Pillow - Bildbearbeitung
- Tag 28: SQLite Basics - Einfache Datenbank
- Tag 29: Tkinter GUI Basics - Notiz-App mit Fenster
- Tag 30: Abschlussprojekt - VollstÃ¤ndiger Datei-Manager

---

## ğŸ“‹ ÃœBERARBEITETER GESAMTPLAN (30 Tage)

### ğŸŒ± Woche 1: Grundlagen (Tag 1-7)
- Tag 1: Variablen & Operatoren - Taschenrechner
- Tag 2: Strings - Namensgenerator
- Tag 3: If/Else - Chatbot
- Tag 4: Listen - To-Do Liste
- Tag 5: For-Schleifen - Multiplikationstabelle
- Tag 6: While-Schleifen - Zahlenratespiel
- Tag 7: Funktionen - BMI Rechner

### ğŸŒ¿ Woche 2: Datenstrukturen & Dateien (Tag 8-14)
- Tag 8: Dictionaries - Kontaktverwaltung
- Tag 9: List Comprehensions - Datenfilter
- Tag 10: Tupel & Sets - Duplikate entfernen
- Tag 11: File I/O (Text) - Notiz-App
- Tag 12: Error Handling - Robuster Datei-Reader
- Tag 13: JSON - Konfigurations-Manager
- Tag 14: CSV - Ausgaben-Tracker

### ğŸŒ³ Woche 3: OOP & Dateimanagement (Tag 15-21)
- Tag 15: **Classes Grundlagen** - Bankkonto-System
- Tag 16: **OOP Vererbung** - Tier-Hierarchie
- Tag 17: os & pathlib - Ordner-Organizer
- Tag 18: shutil - Backup-Tool
- Tag 19: glob - Massen-Dateiumbennung
- Tag 20: datetime - Event-Manager
- Tag 21: **Mini-Projekt: Bibliotheks-System** (OOP)

### ğŸš€ Woche 4: Fortgeschrittene Themen (Tag 22-30)
- Tag 22: requests - Wetter-API
- Tag 23: Web Scraping - Preisvergleich
- Tag 24: Pillow - Batch-Bildbearbeitung
- Tag 25: zipfile - Automatischer Archiver
- Tag 26: sqlite3 - Kontakt-Datenbank
- Tag 27: argparse - CLI-Tool
- Tag 28: Regular Expressions - Text-Parser
- Tag 29: **Projekt: Datei-Manager mit GUI** (tkinter)
- Tag 30: **Abschlussprojekt: Eigene Wahl**

---

## Tag 1: Variablen & Operatoren - Taschenrechner

### ğŸ“ Aufgabe
Erstelle einen interaktiven Taschenrechner und verstehe dabei, wie Variablen und Datentypen funktionieren.

---

### ğŸ“ Schritt 1: Das mentale Modell (IPO-Prinzip)

**ğŸ¯ Ziel:** Verstehen, wie JEDES Computerprogramm fundamental funktioniert.

**ğŸ’¡ Warum:** Bevor wir tippen, mÃ¼ssen wir wissen, was wir bauen. Stell dir dein Programm wie eine Fabrik vor.

**ğŸ“ Anleitung:**
1.  Schau dir das Diagramm unten an.
2.  Verinnerliche das **IPO-Prinzip**: Input â†’ Process â†’ Output.
3.  Jedes Programm holt Daten (Input), macht etwas damit (Process) und zeigt das Ergebnis (Output).

**ğŸ§  Visueller Ablauf:**
```mermaid
graph LR
    A[âŒ¨ï¸ Input] -->|Rohdaten| B(âš™ï¸ Verarbeitung)
    B -->|Ergebnisse| C[ğŸ–¥ï¸ Output]
    style A fill:#e1f5fe,stroke:#01579b
    style B fill:#fff3e0,stroke:#ff6f00
    style C fill:#e8f5e9,stroke:#2e7d32
```

**âœ… Checkpoint:**
Jedes mal wenn du codest, frage dich: Was ist mein Input? Was ist mein Output?

---

### ğŸ“ Schritt 2: Die Variable (Das GedÃ¤chtnis)

**ğŸ¯ Ziel:** Lernen, Daten im Computer-GedÃ¤chtnis zu speichern.

**ğŸ’¡ Warum:** Computer sind vergesslich. Ohne Variablen ("Boxen") vergessen sie jede Zahl sofort wieder.

**ğŸ“ Anleitung:**
Eine Variable ist wie eine **Umzugskiste**.
1.  Du nimmst eine leere Kiste.
2.  Du klebst ein Etikett drauf (der **Name**).
3.  Du legst etwas hinein (der **Wert**).

**ğŸ‘ï¸ Visualisierung:**
```mermaid
graph TD
    subgraph RAM [Arbeitsspeicher]
        Box1[ğŸ“¦ Etikett: 'alter'<br>Inhalt: 25]
    end
```

**ğŸ’» Code:**
Ã–ffne Python und tippe:
```python
# Wir erstellen eine Box namens 'alter' und legen die Zahl 25 hinein
alter = 25  

# Wir schauen in die Box (Output)
print(alter)
```

**âœ… Checkpoint:**
Hast du verstanden, dass `=` bedeutet: "Speichere rechts in links"? (Und nicht "ist gleich" wie in Mathe!)

---

### ğŸ“ Schritt 3: Datentypen (Text vs. Zahl)

**ğŸ¯ Ziel:** Den Unterschied zwischen `10` und `"10"` verstehen.

**ğŸ’¡ Warum:** FÃ¼r dich ist es das Gleiche, fÃ¼r den Computer nicht!
*   `10` (Zahl/Integer): Damit kann man rechnen.
*   `"10"` (Text/String): Das ist nur ein Wort aus Ziffern.

**ğŸ“ Anleitung:**
Wir machen ein Experiment "Predict-Observe-Explain".
1.  Schau dir den Code unten an.
2.  RATE was passiert (noch nicht ausfÃ¼hren!).
3.  Dann fÃ¼hre ihn aus.

**ğŸ’» Code:**
```python
# Was passiert hier wohl?
zahl1 = "10" 
zahl2 = "5"

ergebnis = zahl1 + zahl2
print(ergebnis)
```

**âœ… Checkpoint:**
Hast du `105` gesehen? Das passiert, wenn man Texte "addiert" (zusammenklebt). `"Hallo" + "Welt"` = `"HalloWelt"`.

---

### ğŸ“ Schritt 4: Der Transformer (Input & Casting)

**ğŸ¯ Ziel:** Benutzereingaben richtig verarbeiten.

**ğŸ’¡ Warum:** Der Befehl `input()` holt IMMER Text. Auch wenn du eine Zahl eingibst. Wir brauchen einen "Transformer" (`int` oder `float`), um damit rechnen zu kÃ¶nnen.

**ğŸ“ Anleitung:**
Wir bauen jetzt den Taschenrechner-Input.
1.  Hole den Input (Text).
2.  Wandle ihn in eine Zahl um (`float` fÃ¼r Kommazahlen).
3.  Rechne damit.

**ğŸ’» Code:**
```python
# 1. INPUT: Wir holen Text
eingabe1 = input("Gib die erste Zahl ein: ") 

# 2. TRANSFORM: Text zu Kommazahl (float)
zahl1 = float(eingabe1)

# ... oder Profi-Tipp: Beides in einer Zeile!
zahl2 = float(input("Gib die zweite Zahl ein: "))

# 3. PROCESS: Rechnen (jetzt geht es, weil es Zahlen sind!)
summe = zahl1 + zahl2

# 4. OUTPUT: Ergebnis zeigen
print(f"Das Ergebnis ist: {summe}")
```

**âœ… Checkpoint:**
FÃ¼hre den Code aus. Jetzt sollte `10 + 5` wirklich `15.0` ergeben!

---

### ğŸ“ Schritt 5: Integration (Dein Projekt)

**ğŸ¯ Ziel:** Den vollstÃ¤ndigen Super-Rechner bauen.

**ğŸ’¡ Warum:** Jetzt setzen wir alle Teile (Input, Variables, Casting, Math, Output) zusammen.

**ğŸ“ Anleitung:**
Tippe den folgenden Code ab (nicht kopieren!). Versuche dir bei jeder Zeile zu erklÃ¤ren, was gerade passiert ("Hier hole ich Input...", "Hier rechne ich...").

**ğŸ’» Code:**
```python
print("ğŸ§® SUPER-RECHNER 3000")
print("---------------------")

# 1. Input holen & direkt umwandeln
x = float(input("Erste Zahl: "))
y = float(input("Zweite Zahl: "))

# 2. Verarbeiten
plus = x + y
minus = x - y
mal = x * y
geteilt = x / y

# 3. Output (mit f-Strings fÃ¼r schÃ¶ne Formatierung)
# f"..." erlaubt uns, Variablen direkt in den Text einzubauen
print(f"\nErgebnisse fÃ¼r {x} und {y}:")
print(f"â• Summe:      {plus}")
print(f"â– Differenz:  {minus}")
print(f"âœ–ï¸ Produkt:    {mal}")
print(f"â— Quotient:   {geteilt}")
```

**âœ… Checkpoint:**
Funktioniert dein Rechner? Teste ihn mit Kommazahlen (z.B. 5.5 und 2)!

---

### ğŸ“ Schritt 6: Challenge Time!

**ğŸ¯ Ziel:** Das Gelernte auf neue Probleme anwenden.

**ğŸ’¡ Warum:** Nur durch Selbermachen lernst du wirklich.

**ğŸ“ Anleitung:**
WÃ¤hle eine der Challenges und setze sie um:

**Level 1: Trinkgeld-Rechner**
Frage nach Rechnungsbetrag, rechne 10% drauf, gib Summe aus.

**Level 2: Alters-Rechner**
Frage nach Geburtsjahr, berechne Alter (Aktuelles Jahr - Geburtsjahr). Denk an `int()`!

**Level 3: WÃ¤hrungs-Rechner**
Rechne Euro in Dollar um (Kurs: 1.10).

**ğŸ’» Code (Vorlage):**
```python
# Hier dein Challenge-Code:
betrag = float(input("Rechnungsbetrag: "))
# ... dein Code ...
```

**âœ… Checkpoint:**
Hast du eine Challenge geschafft? Herzlichen GlÃ¼ckwunsch!

---

### ğŸ“š Was du gelernt hast:

- âœ… **IPO-Prinzip:** Input â†’ Process â†’ Output
- âœ… **Variablen:** Speicherboxen fÃ¼r Daten (`box = wert`)
- âœ… **Datentypen:** Unterschied zwischen String (`"1"`) und Zahl (`1`)
- âœ… **Casting:** Umwandeln von Typen (`float("1.5")`, `int("5")`)
- âœ… **Input:** Daten vom User holen (ist immer Text!)
- âœ… **f-Strings:** Variablen schÃ¶n ausgeben (`f"Ergebnis: {wert}"`)

---

## Tag 2: Strings & der Namensgenerator

### ğŸ“ Aufgabe
Erstelle ein Programm, das Text verarbeitet und vÃ¶llig neue Namen erfindet.

---

### ğŸ“ Schritt 1: Das mentale Modell (Die Perlenkette)

**ğŸ¯ Ziel:** Verstehen, wie Computer Text eigentlich sehen.

**ğŸ’¡ Warum:** FÃ¼r dich ist "Hallo" ein Wort. FÃ¼r den Computer ist es eine **Kette von einzelnen Buchstaben**, die fest miteinander verbunden sind. Und jeder Buchstabe hat eine **feste Adresse** (Index).

**ğŸ“ Anleitung:**
Stell dir den Namen "PYTHON" vor. Jeder Buchstabe hat eine Nummer, beginnend bei **0**:

**ğŸ§  Visueller Ablauf:**
```mermaid
graph LR
    P((P<br>0)) --- Y((Y<br>1)) --- T((T<br>2)) --- H((H<br>3)) --- O((O<br>4)) --- N((N<br>5))
    style P fill:#e1f5fe
    style Y fill:#e1f5fe
    style T fill:#e1f5fe
    style H fill:#e1f5fe
    style O fill:#e1f5fe
    style N fill:#e1f5fe
```

**âœ… Checkpoint:**
Merk dir diesen Satz: "In der Informatik fangen wir IMMER bei 0 an zu zÃ¤hlen!" (Der erste Buchstabe ist Nummer 0).

---

### ğŸ“ Schritt 2: Strings erstellen & kleben

**ğŸ¯ Ziel:** Texte definieren und verbinden (`Concatenation`).

**ğŸ’¡ Warum:** Oft mÃ¼ssen wir Texte zusammenbauen (z.B. Vorname + Nachname). DafÃ¼r nutzen wir das `+` Zeichen. Bei Zahlen rechnet es, bei Text "klebt" es.

**ğŸ“ Anleitung:**
1.  Hole zwei Eingaben.
2.  Klebe sie mit einem Leerzeichen dazwischen zusammen.

**ğŸ’» Code:**
```python
# Strings brauchen AnfÃ¼hrungszeichen!
vorname = input("Vorname: ")
nachname = input("Nachname: ")

# Wir kleben: Vorname + Leerzeichen + Nachname
# ACHTUNG: Vergiss das " " in der Mitte nicht, sonst klebt es direkt zusammen!
voller_name = vorname + " " + nachname 

print(f"Hallo, {voller_name}!")
```

**âœ… Checkpoint:**
Wenn du "Max" und "MÃ¼ller" eingibst, muss "Max MÃ¼ller" rauskommen. Ohne das `" "` wÃ¤re es "MaxMÃ¼ller".

---

### ğŸ“ Schritt 3: Die Werkzeugkiste (Methoden)

**ğŸ¯ Ziel:** Text verÃ¤ndern (GroÃŸ/Klein), ohne ihn neu zu tippen.

**ğŸ’¡ Warum:** Benutzer geben Chaos ein ("mAx", "MAX", "max"). Mit Methoden (`.functions`) rÃ¤umen wir auf.
**WICHTIG:** Methoden wie `.upper()` verÃ¤ndern nicht das Original, sie geben eine **Kopie** zurÃ¼ck!

**ğŸ“ Anleitung:**
Nutze `.upper()` (alles groÃŸ), `.lower()` (alles klein) und `.title()` (Erster Buchstabe groÃŸ).

**ğŸ’» Code:**
```python
text = "Das ist Ein TeSt"

# Wir wenden Methoden an
gross = text.upper()   # DAS IST EIN TEST
klein = text.lower()   # das ist ein test
titel = text.title()   # Das Ist Ein Test

print(gross)
print(klein)
print(titel)

# Original ist unverÃ¤ndert!
print(f"Original war: {text}")
```

**âœ… Checkpoint:**
Warum geben wir `text` nicht direkt aus? Weil `text.upper()` alleine nichts speichert! Wir mÃ¼ssen das Ergebnis in einer Variable (`gross`) auffangen.

---

### ğŸ“ Schritt 4: Das Adress-System (Indexing)

**ğŸ¯ Ziel:** Einzelne Buchstaben aus der Kette herauspicken.

**ğŸ’¡ Warum:** Manchmal brauchen wir nur den ersten Buchstaben (Initialen) oder den letzten. DafÃ¼r nutzen wir eckige Klammern `[]` mit der Adresse.

**ğŸ“ Anleitung:**
Erinnere dich an das Modell: Der ERSTE Buchstabe hat die Adresse **0**.
Python hat auch einen Trick: `-1` ist immer der **letzte** Buchstabe.

**ğŸ‘ï¸ Visualisierung:**
`PYTHON`
`012345` (von vorne)
`-6-5-4-3-2-1` (von hinten)

**ğŸ’» Code:**
```python
name = "Python"

erste = name[0]   # P (Adresse 0)
zweite = name[1]  # y (Adresse 1)
letzte = name[-1] # n (Trick fÃ¼r Letzte!)

print(f"Anfang: {erste}")
print(f"Ende: {letzte}")
```

**ğŸ› Debug-Challenge:**
Was passiert bei `name[100]`? Rate erst, dann probiere es. (Spoiler: `IndexError` - die Adresse gibt es nicht!)

---

### ğŸ“ Schritt 5: Der Schneider (Slicing)

**ğŸ¯ Ziel:** Teile ausschneiden (nicht nur einen Buchstaben).

**ğŸ’¡ Warum:** Wir wollen oft einen Teil-String haben (z.B. die ersten 3 Zeichen).
Syntax: `text[START : ENDE]`.
**Regel:** Start ist INKLUSIVE, Ende ist EXKLUSIVE (wir schneiden VOR dem Ende ab).

**ğŸ“ Anleitung:**
Wir schneiden "Pyt" aus "Python".
Start: 0 ('P')
Ende: 3 ('h'). Python stoppt VOR 3. Also bekommen wir 0, 1, 2 ('P', 'y', 't').

**ğŸ’» Code:**
```python
wort = "Programmieren"

# Die ersten 4 Zeichen (0 bis 4)
# Stoppt VOR Index 4!
anfang = wort[0:4]  # "Prog"

# Ab Index 4 bis zum Ende
rest = wort[4:]     # "rammieren" (Leer lassen = bis Ende)

# Alles rÃ¼ckwÃ¤rts (Spezial-Trick)
rueckwaerts = wort[::-1]

print(anfang)
print(rest)
print(rueckwaerts)
```

**âœ… Checkpoint:**
`wort[0:3]` gibt die ersten 3 Buchstaben. Merkregel: Die zweite Zahl sagt, WIE VIELE Buchstaben es sind (wenn man bei 0 startet).

---

### ğŸ“ Schritt 6: Integration (Namensgenerator)

**ğŸ¯ Ziel:** Ein Programm, das aus zwei Namen einen neuen "Super-Namen" baut.

**ğŸ“ Anleitung:**
Wir nehmen die erste HÃ¤lfte vom Vornamen und die zweite HÃ¤lfte vom Nachnamen.
DafÃ¼r brauchen wir `len()` (LÃ¤nge), Indexing, Slicing und Math (`// 2`).

**ğŸ’» Code:**
```python
print("--- SUPER-NAMEN GENERATOR ---")
v = input("Vorname: ")
n = input("Nachname: ")

# LÃ¤ngen berechnen
len_v = len(v)
len_n = len(n)

# Die Mitte finden (wir nutzen // fÃ¼r Ganzzahlen, Indizes mÃ¼ssen ganz sein!)
mitte_v = len_v // 2
mitte_n = len_n // 2

# Slicing: Anfang bis Mitte
teil1 = v[0:mitte_v]

# Slicing: Mitte bis Ende
teil2 = n[mitte_n:]

# Zusammenkleben
supername = teil1 + teil2

print(f"Dein Supername ist: {supername}")
```

**âœ… Checkpoint:**
Teste es mit "Max" und "Mustermann".

---

### ğŸ“ Schritt 7: Challenge Time!

**ğŸ¯ Ziel:** ProblemlÃ¶sen Ã¼ben!

**ğŸ“ Anleitung:**
WÃ¤hle eine Aufgabe:

**Level 1: Passwort-Check**
Frage nach einem Passwort. Wenn es weniger als 8 Zeichen hat (`len()`), gib eine Warnung aus.

**Level 2: Zensur-Maschine**
Ersetze alle 'e' durch 'X'. Tipp: Google mal `python string replace`.

**Level 3: Palindrom-PrÃ¼fer**
Ist dein Wort rÃ¼ckwÃ¤rts gleich vorwÃ¤rts? (`if wort == wort[::-1]:`)

**ğŸ’» Code (Vorlage):**
```python
# Dein Challenge Code hier
passwort = input("Passwort: ")
```

**âœ… Checkpoint:**
Geschafft?

---

### ğŸ“š Was du gelernt hast:

- âœ… **Perlenketten-Modell:** Strings sind Buchstaben-Ketten mit Index.
- âœ… **0-Indexing:** Computer zÃ¤hlen ab 0 (Erster Buchstabe = 0).
- âœ… **Methoden:** `.upper()`, `.lower()` (verÃ¤ndern nicht Original, geben neu zurÃ¼ck).
- âœ… **Slicing:** `[Start:Ende]` schneidet Teile aus (Ende exklusive).
- âœ… **Concatenation:** `+` klebt Strings zusammen.

---

## Tag 3: Entscheidungen (If/Else) & Der Chatbot

### ğŸ“ Aufgabe
Baue einen Chatbot, der versteht, wie du dich fÃ¼hlst, und darauf intelligent reagiert.

---

### ğŸ“ Schritt 1: Das mentale Modell (Die Weiche)

**ğŸ¯ Ziel:** Verstehen, wie ein Programm "Entscheidungen" trifft.

**ğŸ’¡ Warum:** Bisher lief dein Code stur von oben nach unten durch. Wie ein Wasserfall.
Mit `if` (wenn) bauen wir **Weichen** ein. Das Programm kann jetzt abbiegen!

**ğŸ§  Visueller Ablauf:**
Stell dir eine Bahngleis-Weiche vor:

```mermaid
graph TD
    Start((Start)) --> Frage{Hunger?}
    Frage -->|Ja| Essen[Pizza essen]
    Frage -->|Nein| Weiter[Arbeiten]
    Essen --> Weiter
    style Frage fill:#fff9c4,stroke:#fbc02d
```

**âœ… Checkpoint:**
Der Code im "Ja"-Pfad wird NUR ausgefÃ¼hrt, wenn die Bedingung wahr ist. Sonst wird er komplett Ã¼bersprungen.

---

### ğŸ“ Schritt 2: Der TÃ¼rsteher (If & EinrÃ¼ckung)

**ğŸ¯ Ziel:** Einen Code-Block nur unter einer Bedingung ausfÃ¼hren.

**ğŸ’¡ Warum:** Wichtigste Regel in Python: **Die EinrÃ¼ckung (Indentation)**.
Alles, was eingerÃ¼ckt ist, gehÃ¶rt zum `if`. Wie ein VIP-Bereich hinter einem TÃ¼rsteher.

**ğŸ“ Anleitung:**
1.  Starte mit `if bedingung:`. Vergiss den Doppelpunkt `:` nicht!
2.  DrÃ¼cke Enter. Die nÃ¤chste Zeile MUSS eingerÃ¼ckt sein (Tab oder 4 Leerzeichen).

**ğŸ’» Code:**
```python
alter = int(input("Wie alt bist du? "))

if alter >= 18:
    # Dieser Block ist der VIP-Bereich
    print("âœ… Eintritt erlaubt!")
    print("Hier ist dein Bier ğŸº")

print("Das hier wird IMMER ausgefÃ¼hrt (nicht mehr eingerÃ¼ckt).")
```

**âœ… Checkpoint:**
Teste es mit `15` (nichts passiert) und `25` (Eintritt erlaubt).
Siehst du, wie der eingerÃ¼ckte Teil Ã¼bersprungen wird?

---

### ğŸ“ Schritt 3: Die Alternative (Else)

**ğŸ¯ Ziel:** Ein "Entweder - Oder" Szenario bauen.

**ğŸ’¡ Warum:** Oft wollen wir: "Wenn Ja, mach A. Wenn Nein, mach B."
DafÃ¼r gibt es `else` (sonst).

**ğŸ‘ï¸ Visualisierung:**
```mermaid
graph TD
    Frage{VollejÃ¤hrig?} -->|Ja| A[Bier]
    Frage -->|Nein| B[Saft]
```

**ğŸ’» Code:**
```python
if alter >= 18:
    print("ğŸº Hier ist dein Bier.")
else:
    # Das hier passiert NUR, wenn alter < 18 ist
    print("ğŸ§ƒ Hier ist dein Apfelsaft.")
    
print("Prost!")
```

**âœ… Checkpoint:**
Es wird NIEMALS beides ausgegeben. Es ist immer genau einer der beiden Wege.

---

### ğŸ“ Schritt 4: Der Verteiler (Elif)

**ğŸ¯ Ziel:** Mehr als zwei Optionen prÃ¼fen (Kaskade).

**ğŸ’¡ Warum:** Das Leben ist nicht nur Schwarz/WeiÃŸ. Wenn wir mehrere MÃ¶glichkeiten haben (Kind, Teenager, Erwachsener), nutzen wir `elif` (else if - sonst wenn).

**âš ï¸ WICHTIG:** Python prÃ¼ft von oben nach unten. Der **erste** Treffer gewinnt! Alle danach werden ignoriert.

**ğŸ’» Code:**
```python
note = int(input("Welche Note hast du (1-6)? "))

if note == 1:
    print("ğŸ¥‡ Streber!")
elif note == 2:
    print("ğŸ¥ˆ Gut gemacht!")
elif note == 3:
    print("ğŸ¥‰ Passt schon.")
elif note == 4:
    print("ğŸ˜¬ Gewinn ist Gewinn.")
else:
    print("ğŸ’€ RIP.")
```

**ğŸ› Debug-Challenge:**
Warum funktioniert dieser Code nicht richtig?
```python
# Falsche Reihenfolge!
punkte = 95

if punkte > 50:
    print("Bestanden")
elif punkte > 90:
    print("Bestnote!") 
```
*Tipp: Was gibt er bei 95 aus? Nur "Bestanden", weil er beim ersten `if` schon aufhÃ¶rt! Spezifische Bedingungen mÃ¼ssen immer zuerst kommen.*

---

### ğŸ“ Schritt 5: Logik-Gatter (And / Or)

**ğŸ¯ Ziel:** Mehrere Bedingungen gleichzeitig prÃ¼fen.

**ğŸ’¡ Warum:** Manchmal reicht eine Frage nicht.
*   `and` (UND): Beide Seiten mÃ¼ssen wahr sein.
*   `or` (ODER): Mindestens eine Seite muss wahr sein.

**ğŸ’» Code:**
```python
stimmung = input("Wie gehts? ").lower()
wetter = input("Wie ist das Wetter? ").lower()

# AND: Beides muss stimmen
if stimmung == "gut" and wetter == "sonne":
    print("Perfekter Tag fÃ¼r den Park! ğŸŒ³")

# OR: Eins reicht
elif stimmung == "schlecht" or wetter == "regen":
    print("Netflix & Chill Zeit ğŸ“º")

else:
    print("Ganz normaler Tag.")
```

**âœ… Checkpoint:**
Was passiert bei `gut` und `regen`? (Zweiter Block, weil `rain` das `or` wahr macht? Nein, warte... prÃ¼f es nach!)
LÃ¶sung: Bei `gut` + `regen`:
1. `if gut and sonne` -> False (wegen sonne).
2. `elif schlecht or regen` -> True (wegen regen).
-> Netflix Zeit!

---

### ğŸ“ Schritt 6: Integration (Der Mood-Chatbot)

**ğŸ¯ Ziel:** Ein empathischer Roboter.

**ğŸ“ Anleitung:**
Kombiniere Input, If/Elif/Else und String-Methoden.

**ğŸ’» Code:**
```python
print("ğŸ¤– EMO-BOT 2000")
name = input("Wer bist du? ")

if name == "Maurice" or name == "Admin":
    print("ğŸ«¡ Hallo Chef!")
else:
    print(f"Hallo {name}.")

mood = input("Wie fÃ¼hlst du dich? (gut/mies/mÃ¼de) ").lower()

if "gut" in mood or "super" in mood:
    print("Das freut mich! ğŸ‰")
elif "mies" in mood or "schlecht" in mood:
    print("Oh nein. Hier ist ein Keks ğŸª")
elif "mÃ¼de" in mood:
    print("â˜• Kaffee wird zubereitet...")
    if "spÃ¤t" in input("Ist es spÃ¤t? "): # Verschachteltes IF!
        print("Dann geh besser schlafen!")
    else:
        print("Koffein kommt sofort!")
else:
    print("Interessant. ErzÃ¤hl mir mehr.")
```

**âœ… Checkpoint:**
Versuche den Bot auszutricksen. Was passiert, wenn du "Mir geht es super gut" schreibst? (Der `in` Operator hilft hier!)

---

### ğŸ“ Schritt 7: Challenge Time!

**ğŸ¯ Ziel:** Logik-Muskel trainieren.

**ğŸ“ Anleitung:**
WÃ¤hle eine Aufgabe:

**Level 1: TÃ¼rsteher 2.0**
Frage nach Alter.
< 18: "Kein Eintritt"
18-21: "Eintritt mit BÃ¤ndchen"
21+: "Freier Eintritt"

**Level 2: Schaltjahr-Rechner**
Ein Jahr ist ein Schaltjahr, wenn:
- Es durch 4 teilbar ist (`jahr % 4 == 0`)
- AUSSER es ist durch 100 teilbar
- DOCH WIEDER, wenn es durch 400 teilbar ist.
(Nutze verschachtelte Ifs oder `and`/`or`!).

**Level 3: Text-Adventure**
Schreibe eine kleine Geschichte.
"Du stehst vor einer HÃ¶hle. Gehst du rein oder weg?"
Je nach Antwort passiert etwas anderes. Bau mindestens 3 Ebenen tief!

---

### ğŸ“š Was du gelernt hast:

- âœ… **If-Elif-Else:** Die Weichenstellung im Code.
- âœ… **Indentation:** EinrÃ¼ckung definiert BlÃ¶cke (VIP-Bereich).
- âœ… **Booleans:** Wahr (`True`) oder Falsch (`False`).
- âœ… **Operatoren:** `==` (gleich), `!=` (ungleich), `>`, `<`.
- âœ… **Logik:** `and` (beide), `or` (einer), `not` (Gegenteil).
- âœ… **Verschachtelung:** If in If (Kaffee-Beispiel).

---

## Tag 4: To-Do Liste (Konsole)

### ğŸ“ Aufgabe
Erstelle eine interaktive To-Do Liste, die Aufgaben speichern, anzeigen und lÃ¶schen kann.

---

### ğŸ“ Schritt 1: Das mentale Modell (Das Regal)

**ğŸ¯ Ziel:** Verstehen, wie Computer viele Daten auf einmal speichern.

**ğŸ’¡ Warum:** Eine Variable ist wie ein Schuhkarton (passt nur eine Sache rein).
Eine **Liste** ist wie ein **Regal** mit ganz vielen FÃ¤chern.
Jedes Fach hat eine **Nummer** (Adresse), genau wie bei Strings!

**ğŸ§  Visueller Ablauf:**
`einkauf = ["Apfel", "Brot", "Milch"]`

```mermaid
graph LR
    A((0<br>Apfel)) --- B((1<br>Brot)) --- C((2<br>Milch))
    style A fill:#fff9c4
    style B fill:#fff9c4
    style C fill:#fff9c4
```

**âœ… Checkpoint:**
Auch hier gilt: Das erste Fach hat die Nummer **0**!

---

### ğŸ“ Schritt 2: Das Regal bauen & lesen

**ğŸ¯ Ziel:** Eine Liste erstellen und Dinge herausholen.

**ğŸ“ Anleitung:**
1.  Listen brauchen eckige Klammern `[]`.
2.  Elemente werden mit Komma `,` getrennt.
3.  Zugriff erfolgt Ã¼ber den Index `[0]`.

**ğŸ’» Code:**
```python
# Eine Liste mit 3 Strings
helden = ["Spider-Man", "Batman", "Wonder Woman"]

# Die ganze Liste drucken
print(helden)

# Nur den ersten Helden holen (Index 0)
liebling = helden[0]
print(f"Mein Favorit: {liebling}")

# Wie viele sind es?
anzahl = len(helden)
print(f"Anzahl Helden: {anzahl}")
```

**âœ… Checkpoint:**
Was passiert bei `helden[3]`? (Nicht 0,1,2... 3 gibt es nicht -> IndexError!)

---

### ğŸ“ Schritt 3: Das Regal fÃ¼llen (Append)

**ğŸ¯ Ziel:** Neue Dinge hinzufÃ¼gen.

**ğŸ’¡ Warum:** Unsere To-Do Liste soll wachsen.
Die Methode `.append(neues_ding)` packt etwas **immer ans Ende** der Liste.

**ğŸ’» Code:**
```python
todos = []  # Leeres Regal

# Wir packen Sachen rein
todos.append("Python lernen")
todos.append("Einkaufen")
todos.append("Schlafen")

print("Meine Aufgaben:")
print(todos)
```

**ğŸ‘ï¸ Visualisierung:**
Vorher: `[]`
Nach Append 1: `["Python lernen"]`
Nach Append 2: `["Python lernen", "Einkaufen"]`

---

### ğŸ“ Schritt 4: AufrÃ¤umen (Remove & Pop)

**ğŸ¯ Ziel:** Dinge lÃ¶schen.

**ğŸ’¡ Warum:** Erledigte Aufgaben mÃ¼ssen weg. Es gibt zwei Wege:
1.  **LÃ¶schen nach Name** (`.remove("Einkaufen")`): "Wirf das Brot weg."
2.  **LÃ¶schen nach Platz** (`.pop(0)`): "Leere Fach Nr. 0."

**ğŸ’» Code:**
```python
# Wir haben: ["Python lernen", "Einkaufen", "Schlafen"]

# 1. Methode: Remove (Sucht den Text und lÃ¶scht ihn)
todos.remove("Schlafen") # Wer schlÃ¤ft schon?
print(todos)

# 2. Methode: Pop (LÃ¶scht an einer Position)
erledigt = todos.pop(0) # Das erste Element rausnehmen
print(f"Erledigt: {erledigt}")
print(f"Noch offen: {todos}")
```

**ğŸ› Debug-Challenge:**
Was passiert, wenn du `.remove("Pizza")` machst, aber "Pizza" gar nicht in der Liste ist?
(Spoiler: `ValueError` - Python beschwert sich, dass es das nicht findet!)

---

### ğŸ“ Schritt 5: Integration (Der Task-Manager)

**ğŸ¯ Ziel:** Eine interaktive App bauen.

**ğŸ“ Anleitung:**
Wir bauen ein Programm, das in einer Endlosschleife lÃ¤uft (Schleifen kommen morgen, heute tricksen wir mit Copy-Paste oder einer einfachen Struktur).

**ğŸ’» Code:**
```python
print("--- TASK MASTER 3000 ---")
tasks = ["MÃ¼ll rausbringen", "Blumen gieÃŸen"]

print(f"Aktuelle Aufgaben: {tasks}")

# 1. Neue Aufgabe
neu = input("Was willst du noch erledigen? ")
tasks.append(neu)
print("HinzugefÃ¼gt! âœ…")

# 2. Status zeigen
print(f"\nDeine Liste hat jetzt {len(tasks)} EintrÃ¤ge.")
print(f"Als nÃ¤chstes zu tun (Index 0): {tasks[0]}")
print(f"Als letztes zu tun (Index -1): {tasks[-1]}")

# 3. Eine Aufgabe erledigen (wir nehmen immer die erste)
input("DrÃ¼cke Enter, um die erste Aufgabe zu erledigen...")
erledigt = tasks.pop(0)
print(f"Super! '{erledigt}' ist erledigt.")

print(f"Verbleibend: {tasks}")
```

**âœ… Checkpoint:**
FÃ¼hre das Programm aus. FÃ¼ge "Coden" hinzu. Erledige "MÃ¼ll rausbringen".

---

### ğŸ“ Schritt 6: Challenge Time!

**Level 1: Der Zutaten-Mixer**
Erstelle eine leere Liste `salat`.
Lass den User 3 Zutaten eingeben (`input`) und fÃ¼ge sie mit `.append` hinzu.
Gib am Ende das Rezept aus.

**Level 2: Der GlÃ¼cks-Bringer**
Erstelle eine Liste mit 3 Preisen ("Auto", "Geld", "Niete").
Lass den User eine Nummer (0-2) wÃ¤hlen (`int(input...)`).
Gib den Preis an diesem Index aus.

**Level 3: Listen-Mathe**
Erstelle `zahlen = [10, 20, 30]`.
Berechne die Summe (manuell: `zahlen[0] + zahlen[1]...`).
FÃ¼ge das Ergebnis mit `.append` an die Liste an!

---

### ğŸ“š Was du gelernt hast:

- âœ… **Listen:** Variable mit vielen FÃ¤chern (`[a, b, c]`).
- âœ… **0-Index:** Auch Listen fangen bei 0 an.
- âœ… **.append():** AnfÃ¼gen ans Ende.
- âœ… **.remove():** LÃ¶schen nach Inhalt (sucht erstes Vorkommen).
- âœ… **.pop():** LÃ¶schen nach Index (und gibt den Wert zurÃ¼ck).
- âœ… **len():** Anzahl der Elemente zÃ¤hlen.

**âœ… Checkpoint:**
- FÃ¼ge 3 Aufgaben hinzu
- WÃ¤hle Aufgabe "2" zum LÃ¶schen
- Die mittlere Aufgabe sollte verschwinden, die anderen rutschen nach

**ğŸ‰ Erfolgserlebnis:** Du hast eine funktionierende To-Do Liste! Sie kann Aufgaben speichern und lÃ¶schen!

---

### ğŸ“š Was du gelernt hast:

- âœ… **Listen:** Mehrere Werte in einer Variable `[]`
- âœ… **List-Methoden:** `.append()`, `.insert()`, `.remove()`, `.pop()`
- âœ… **Indexierung:** Zugriff auf Elemente mit `[0]`, `[1]`, usw.
- âœ… **len():** LÃ¤nge einer Liste ermitteln
- âœ… **in-Operator:** PrÃ¼fen ob Element in Liste ist
- âœ… **range():** Zahlenfolgen erstellen
- âœ… **.isdigit():** PrÃ¼fen ob String eine Zahl ist

---

### ğŸ’ª Challenge:
Erweitere die Liste so, dass der Benutzer selbst entscheidet, wie viele Aufgaben er hinzufÃ¼gen will! (Tipp: Du brauchst eine Schleife - kommt in Tag 5!)

---



## Tag 5: Schleifen (Der Roboter)

### ğŸ“ Aufgabe
Baue einen "Roboter", der Aufgaben fÃ¼r dich wiederholt, und einen 1x1 Trainer.

---

### ğŸ“ Schritt 1: Das mentale Modell (Der Roboter)

**ğŸ¯ Ziel:** Verstehen, warum wir Schleifen brauchen.

**ğŸ’¡ Warum:** Informatiker sind faul. Wenn wir 100 E-Mails senden mÃ¼ssen, klicken wir nicht 100 Mal auf "Senden". Wir schreiben EINE Schleife, die das 100 Mal erledigt.
Stell dir einen **Roboter am FlieÃŸband** vor. Er macht immer exakt denselben Handgriff, solange Teile kommen.

**ğŸ§  Visueller Ablauf:**
```mermaid
graph TD
    Start((Start)) --> Check{Noch Teile da?}
    Check -->|Ja| Action[Roboter stempelt Teil]
    Action --> Next[Nimm nÃ¤chstes Teil]
    Next --> Check
    Check -->|Nein| End((Feierabend))
    style Check fill:#fff9c4,stroke:#fbc02d
```

**âœ… Checkpoint:**
Die Schleife lÃ¤uft solange, wie Elemente da sind. Dann hÃ¶rt sie automatisch auf.

---

### ğŸ“ Schritt 2: Die Liste abarbeiten (For-Each)

**ğŸ¯ Ziel:** Jedes Element einer Liste einmal "anfassen".

**ğŸ’¡ Warum:** Das ist der hÃ¤ufigste Anwendungsfall. "FÃ¼r jede E-Mail in der Liste: Sende sie."

**ğŸ“ Anleitung:**
`for <variable> in <liste>:`
Die `<variable>` ist der Platzhalter fÃ¼r das aktuelle Ding, das der Roboter gerade in der Hand hÃ¤lt.

**ğŸ’» Code:**
```python
# Unsere Teile auf dem FlieÃŸband
namen = ["Tick", "Trick", "Track"]

print("--- Roboter startet ---")

# Der Loop
for ente in namen:
    # 'ente' ist die Variable, die sich JEDES MAL Ã¤ndert
    print(f"Hallo {ente}!")
    print("Code wird ausgefÃ¼hrt...")

print("--- Roboter fertig ---")
```

**âœ… Checkpoint:**
Der Code im Block (eingerÃ¼ckt) wird 3x ausgefÃ¼hrt. Einmal fÃ¼r Tick, einmal fÃ¼r Trick, einmal fÃ¼r Track.

---

### ğŸ“ Schritt 3: Der ZÃ¤hler (Range)

**ğŸ¯ Ziel:** Etwas genau X mal wiederholen (ohne Liste).

**ğŸ’¡ Warum:** Manchmal haben wir keine Liste, sondern wollen einfach "10 mal Hallo" sagen. DafÃ¼r gibt es `range()` (Bereich).

**ğŸ’» Code:**
```python
# range(5) erzeugt die Zahlen: 0, 1, 2, 3, 4
# Startet bei 0, endet VOR 5!

print("Countdown lÃ¤uft:")
for nummer in range(5):
    print(f"Nummer: {nummer}")

# range(Start, Ende-Exklusiv)
print("\nVon 1 bis 10:")
for i in range(1, 11): # 1 bis 10
    print(i)
```

**ğŸ› Debug-Challenge (Predict-Observe-Explain):**
Was gibt `range(0, 10, 2)` aus?
(Tipp: Die dritte Zahl ist die Schrittweite!)
Antwort: 0, 2, 4, 6, 8. (Die 10 ist exklusiv!).

---

### ğŸ“ Schritt 4: Die Summen-Maschine (Der Akku)

**ğŸ¯ Ziel:** Werte Ã¼ber mehrere SchleifendurchlÃ¤ufe hinweg speichern.

**ğŸ’¡ Warum:** Wir wollen oft etwas zusammenrechnen (z.B. Gesamtkosten).
DafÃ¼r brauchen wir eine Variable **auÃŸerhalb** der Schleife, die wir immer weiter fÃ¼llen (wie ein Akku, der lÃ¤dt).

**ğŸ’» Code:**
```python
kosten = [10, 5, 30]
summe = 0  # Startet leer (WICHTIG: Vor der Schleife!)

print(f"Start-Summe: {summe}")

for preis in kosten:
    summe = summe + preis  # Alten Wert nehmen + neuen Preis
    print(f"Habe {preis}â‚¬ addiert. Neue Summe: {summe}")

print(f"End-Ergebnis: {summe}â‚¬")
```

**âš ï¸ Wichtiger Fehler:**
Wenn du `summe = 0` IN die Schleife schreibst, wird sie jedes Mal wieder auf Null gesetzt! Probier es aus und sieh zu, wie das Ergebnis falsch wird.

---

### ğŸ“ Schritt 5: Bremse und Turbo (Break & Continue)

**ğŸ¯ Ziel:** Die Schleife manuell steuern.

**ğŸ’¡ Warum:**
*   `break`: "Not-Aus". Sofort aufhÃ¶ren (z.B. wir haben gefunden, was wir suchen).
*   `continue`: "Ãœberspringen". Dieses Teil ignorieren, weiter mit dem nÃ¤chsten.

**ğŸ’» Code:**
```python
zahlen = [10, 0, 50, 4, 100]

print("--- Analyse startet ---")

for z in zahlen:
    if z == 0:
        print("Fehler: Null gefunden! Ãœberspringe...")
        continue  # Geht sofort zum Start der Schleife zurÃ¼ck (nÃ¤chste Zahl)
        
    if z > 80:
        print("Alarm: Zahl zu groÃŸ! Abbbruch!")
        break  # Stoppt die ganze Schleife sofort

    print(f"Verarbeite: {z}")

print("--- Fertig ---")
```

**âœ… Checkpoint:**
- 10: Verarbeitet
- 0: Ãœbersprungen (continue)
- 50: Verarbeitet
- 4: Verarbeitet
- 100: Abbruch (break) -> Schleife vorbei.

---

### ğŸ“ Schritt 6: Integration (Der 1x1 Trainer)

**ğŸ¯ Ziel:** Ein Programm, das uns das kleine 1x1 abfragt.

**ğŸ“ Anleitung:**
Wir nutzen `range(1, 11)` fÃ¼r die Zahlen 1-10. Wir berechnen das Ergebnis und lassen den User raten.

**ğŸ’» Code:**
```python
basis = int(input("Welche Reihe mÃ¶chtest du Ã¼ben? (z.B. 7): "))
punkte = 0

print(f"\nTraining fÃ¼r die {basis}er-Reihe startet!")

for i in range(1, 11): # 1 bis 10
    richtiges_ergebnis = basis * i
    
    # User fragen
    antwort = int(input(f"Was ist {basis} * {i}? "))
    
    if antwort == richtiges_ergebnis:
        print("âœ… Richtig!")
        punkte += 1 # Kurzform fÃ¼r: punkte = punkte + 1
    else:
        print(f"âŒ Falsch. Es war {richtiges_ergebnis}")

print("\n--- Auswertung ---")
print(f"Du hast {punkte} von 10 Punkten.")

if punkte == 10:
    print("ğŸ¥‡ Perfekt!")
elif punkte >= 5:
    print("ğŸ‘ Ganz okay.")
else:
    print("ğŸ“š ZurÃ¼ck in die Schule!")
```

### ğŸ“ Schritt 7: Challenge Time!

**Level 1: Der Countdown**
Nutze `range()`, um einen Countdown von 10 bis 0 zu schreiben (`range(10, -1, -1)`).
Am Ende soll "Frohes Neues!" stehen.

**Level 2: Die Namens-Liste**
Lass den User Namen eingeben (`input`).
Speichere sie in einer Liste.
Wenn der User "stop" schreibt, brich die Schleife ab (`break`).
Gib am Ende alle Namen mit einer Schleife aus.

**Level 3: Filter-Maschine**
Du hast eine Liste: `preise = [10, 5, 20, 2, 8, 50]`
Filtere alle Preise heraus, die grÃ¶ÃŸer als 10 sind, und speichere sie in einer neuen Liste `teuer`.
Gib `teuer` am Ende aus.

---

### ğŸ“š Was du gelernt hast:

- âœ… **For-Schleife:** Wiederholt Code fÃ¼r jedes Element.
- âœ… **Range:** Erzeugt Zahlenreihen (`range(start, ende)`).
- âœ… **Akku-Pattern:** Variable vor der Schleife, die drinnen aktualisiert wird.
- âœ… **Break:** Schleife sofort beenden.
- âœ… **Continue:** Aktuellen Durchlauf Ã¼berspringen.


## Tag 6: Das Zahlen-Ratespiel (While & Random)

### ğŸ“ Aufgabe
Baue ein Spiel, bei dem der Computer eine Zahl wÃ¤hlt und du sie erraten musst.

---

### ğŸ“ Schritt 1: Das mentale Modell (Der TÃ¼rsteher)

**ğŸ¯ Ziel:** Verstehen, wie `while` funktioniert.

**ğŸ’¡ Warum:** `for`-Schleifen sind fÃ¼r Listen ("FÃ¼r jeden Apfel...").
`while`-Schleifen sind fÃ¼r Situationen, wo wir **nicht wissen**, wie oft wir etwas tun mÃ¼ssen.
Wie ein TÃ¼rsteher: "Solange du keine 18 bist, kommst du hier nicht rein."

**ğŸ§  Visueller Ablauf:**
```mermaid
graph TD
    Start((Start)) --> Check{Bedingung Wahr?}
    Check -->|Ja| Action[Code ausfÃ¼hren]
    Action --> Check
    Check -->|Nein| End((Weiter im Text))
    style Check fill:#fff9c4
```

**ğŸ’» Code (Das sture Kind):**
```python
antwort = ""

# LÃ¤uft solange, bis man "ja" schreibt
while antwort != "ja":
    antwort = input("Sind wir schon da? ")

print("Endlich!")
```

**âœ… Checkpoint:**
Was passiert, wenn du gleich am Anfang "ja" schreibst? (Die Schleife lÃ¤uft gar nicht erst los!)

---

### ğŸ“ Schritt 2: Der Zufalls-Generator

**ğŸ¯ Ziel:** Den Computer unberechenbar machen.

**ğŸ’¡ Warum:** Ein Spiel ist langweilig, wenn wir die Antwort kennen. Python hat dafÃ¼r das Modul `random`.

**ğŸ’» Code:**
```python
import random  # Wir laden das 'random' Werkzeug

# Eine Zufallszahl zwischen 1 und 6 (wie ein WÃ¼rfel)
wÃ¼rfel = random.randint(1, 6)
print(f"Du hast eine {wÃ¼rfel} gewÃ¼rfelt!")

# Eine Zufallszahl zwischen 1 und 100
lotto = random.randint(1, 100)
print(f"Deine GlÃ¼ckszahl: {lotto}")
```

**âš ï¸ Wichtig:** `randint(1, 6)` schlieÃŸt BEIDE Zahlen ein (1 und 6 sind mÃ¶glich). Das ist anders als bei `range()`!

---

### ğŸ“ Schritt 3: Das Spiel-Skelett

**ğŸ¯ Ziel:** Eine Zahl generieren und den User raten lassen.

**ğŸ’» Code:**
```python
import random

geheimzahl = random.randint(1, 10)
tipp = 0  # Irgendein Startwert, der NICHT die Geheimzahl ist

print("ğŸ•µï¸ Ich habe eine Zahl zwischen 1 und 10.")

while tipp != geheimzahl:
    tipp = int(input("Rate mal: "))
    
    if tipp == geheimzahl:
        print("ğŸ‰ Richtig!")
    else:
        print("âŒ Leider falsch.")
```

**ğŸ› Debug-Challenge:**
Warum muss `tipp = 0` vor der Schleife stehen?
(Weil die `while`-Bedingung `tipp != geheimzahl` gleich am Anfang geprÃ¼ft wird. Wenn `tipp` nicht existiert, stÃ¼rzt das Programm ab!)

---

### ğŸ“ Schritt 4: HeiÃŸ & Kalt (Logik)

**ğŸ¯ Ziel:** Dem Spieler Hinweise geben.

**ğŸ’¡ Warum:** Nur "Falsch" ist frustrierend bei groÃŸen Zahlen. Wir nutzen `if/elif`, um zu helfen.

**ğŸ’» Code:**
```python
import random

geheimzahl = random.randint(1, 100)
tipp = 0
versuche = 0

print("ğŸ•µï¸ Ich habe eine Zahl zwischen 1 und 100.")

while tipp != geheimzahl:
    tipp = int(input("Dein Tipp: "))
    versuche = versuche + 1  # MitzÃ¤hlen
    
    if tipp < geheimzahl:
        print("Zu klein! ğŸ“ˆ")
    elif tipp > geheimzahl:
        print("Zu groÃŸ! ğŸ“‰")
    else:
        print(f"ğŸ‰ GEWONNEN! Du hast {versuche} Versuche gebraucht.")
```

---

### ğŸ“ Schritt 5: Integration (Game Loop)

**ğŸ¯ Ziel:** Das Spiel wiederholbar machen ("Nochmal?").

**ğŸ’¡ Warum:** Wir wollen das Programm nicht jedes Mal neu starten. Wir packen alles in eine "Mutter-Schleife".

**ğŸ’» Code:**
```python
import random

spielen = True  # Schalter fÃ¼r die Hauptschleife

while spielen:
    # --- Hier beginnt eine neue Runde ---
    geheimzahl = random.randint(1, 100)
    tipp = 0
    versuche = 0
    
    print("\nğŸ² NEUES SPIEL (1-100) ğŸ²")
    
    # Die Rate-Schleife (Innere Schleife)
    while tipp != geheimzahl:
        tipp = int(input("Rate: "))
        versuche += 1
        
        if tipp < geheimzahl:
            print("Zu klein!")
        elif tipp > geheimzahl:
            print("Zu groÃŸ!")
        else:
            print(f"ğŸ‰ Treffer nach {versuche} Versuchen!")
    
    # --- Ende der Runde, fragen ob nochmal ---
    nochmal = input("Nochmal? (ja/nein): ")
    
    if nochmal == "nein":
        spielen = False  # Schalter umlegen -> Hauptschleife endet
        print("Bis zum nÃ¤chsten Mal! ğŸ‘‹")
```

**âœ… Checkpoint:**
Hier siehst du "Nested Loads" (Schleife in Schleife).
Die Innere lÃ¤uft, bis die Zahl erraten ist.
Die Ã„uÃŸere lÃ¤uft, bis der Spieler "nein" sagt.

---

### ğŸ“š Was du gelernt hast:

- âœ… **While-Schleife:** Wiederholung abhÃ¤ngig von einer Bedingung.
- âœ… **Endlosschleife:** Wenn die Bedingung nie `False` wird (Gefahr!).
- âœ… **import random:** Zufallsgenerator nutzen.
- âœ… **Game Loop:** Das Konzept einer Hauptschleife, die das Spiel am Leben hÃ¤lt.
- âœ… **Verschachtelung:** Schleifen in Schleifen fÃ¼r komplexe AblÃ¤ufe.

---

## Tag 7: Funktionen (Die Pizza-Maschine)

### ğŸ“ Aufgabe
Baue einen intelligenten BMI-Rechner, indem du eigene Werkzeuge (Funktionen) erstellst.

---

### ğŸ“ Schritt 1: Das mentale Modell (Die Maschine)

**ğŸ¯ Ziel:** Verstehen, was eine Funktion eigentlich ist.

**ğŸ’¡ Warum:** Du willst Code nicht 10x kopieren. Du willst ihn *einmal* schreiben und *immer wieder* benutzen.
Stell dir eine **Funktion** wie eine kleine **Maschine** oder einen **Zauberspruch** vor.

**ğŸ§  Visueller Ablauf:**
```mermaid
graph LR
    Input(Input: Zutaten) --> Maschine[Funktion: Pizza-Ofen]
    Maschine --> Output(Output: HeiÃŸe Pizza)
    style Maschine fill:#e1f5fe,stroke:#01579b
```

**ğŸ’» Code:**
```python
# 1. BAUPLAN (Definition)
# Wir bringen Python ein neues Wort bei: "begruesse"
def begruesse():
    print("----------------")
    print("ğŸ‘‹ Hallo Welt!")
    print("----------------")

# 2. BENUTZUNG (Aufruf)
# Erst jetzt passiert etwas!
print("Start...")
begruesse() 
begruesse()
print("Ende.")
```

**âœ… Checkpoint:**
Siehst du, wie der Code drei Zeilen ausfÃ¼hrt, obwohl du nur ein Wort (`begruesse()`) schreibst? Das ist **Abstraktion**!

---

### ğŸ“ Schritt 2: Zutaten geben (Parameter)

**ğŸ¯ Ziel:** Der Funktion Informationen geben.

**ğŸ’¡ Warum:** Eine BegrÃ¼ÃŸung ist netter mit Namen. Eine Pizza-Maschine braucht Teig und Belag.
Das nennen wir **Parameter** (oder Argumente).

**ğŸ’» Code:**
```python
# In die Klammer schreiben wir den Platzhalter (Variable)
def hallo(name):
    print(f"Hallo {name}, schÃ¶n dich zu sehen!")

# Beim Aufrufen werfen wir den echten Wert rein
hallo("Anna")
hallo("Bernd")
hallo("Cleo")
```

**âš ï¸ WICHTIG:** Die Variable `name` existiert NUR innerhalb der Funktion. DrauÃŸen kennt Python sie nicht!

---

### ğŸ“ Schritt 3: Ergebnisse bekommen (Return)

**ğŸ¯ Ziel:** Einen Wert ZURÃœCK erhalten (nicht nur dumpf ausdrucken).

**ğŸ’¡ Warum:**
*   `print()` ist wie Schreien: Man sieht es auf dem Bildschirm, aber man kann damit nicht weiterrechnen.
*   `return` ist wie Liefern: Die Funktion gibt dir einen Wert in die Hand, den du in einer Variable speichern kannst.

**ğŸ’» Code:**
```python
# Schlecht (nur Print):
def addiere_print(a, b):
    print(a + b)

# Gut (Return):
def addiere_return(a, b):
    ergebnis = a + b
    return ergebnis  # Hier! Nimm das!

# Test:
x = addiere_return(5, 5)  # x ist jetzt 10
print(f"Das Ergebnis verdoppelt ist: {x * 2}")

y = addiere_print(5, 5)
# print(f"Das geht nicht: {y * 2}") # FEHLER! y ist 'None' (Nichts)
```

**âœ… Checkpoint:**
`return` beendet die Funktion sofort. Alles danach wird ignoriert.

---

### ğŸ“ Schritt 4: Der BMI-Rechner (Zusammenbau)

**ğŸ¯ Ziel:** Ein echtes Programm aus Funktionen bauen.

**ğŸ“ Anleitung:**
Wir brauchen:
1.  Eine Funktion fÃ¼r Input (sicherstellen, dass es Zahlen sind).
2.  Eine Funktion fÃ¼r die Rechnung.
3.  Eine Funktion fÃ¼r die Bewertung (Untergewicht/Normal...).
4.  Ein Hauptprogramm.

**ğŸ’» Code:**
```python
# 1. Hilfsfunktion fÃ¼r sicheren Input
def kommazahl_holen(frage):
    while True:
        try:
            eingabe = input(frage)
            zahl = float(eingabe)
            return zahl
        except ValueError:
            print("âŒ Das war keine Zahl. Bitte z.B. 1.75 eingeben.")

# 2. Die Rechen-Maschine
def bmi_rechnen(gewicht, groesse):
    bmi = gewicht / (groesse * groesse)
    return bmi

# 3. Der Arzt (Bewertung)
def bewerte_bmi(bmi):
    if bmi < 18.5:
        return "Untergewicht ğŸ"
    elif bmi < 25:
        return "Normalgewicht âœ…"
    elif bmi < 30:
        return "Ãœbergewicht ğŸ”"
    else:
        return "Adipositas âš ï¸"

# 4. Das Hauptprogramm (Main)
print("ğŸ¥ DER GESUNDHEITS-CHECK")
print("-" * 30)

g = kommazahl_holen("Dein Gewicht (kg): ")
h = kommazahl_holen("Deine GrÃ¶ÃŸe (m): ")

mein_bmi = bmi_rechnen(g, h)
urteil = bewerte_bmi(mein_bmi)

print("-" * 30)
print(f"Dein BMI ist: {mein_bmi:.2f}")
print(f"Befund: {urteil}")
```

**âœ… Checkpoint:**
Teste es!
- Gewicht: 80, GrÃ¶ÃŸe: 1.80 -> BMI ~24.69 (Normal)
- Gewicht: 100, GrÃ¶ÃŸe: 1.80 -> BMI ~30.86 (Adipositas)

---

### ğŸ“ Schritt 5: Challenge Time!

**Level 1: Der WÃ¤hrungsrechner**
Schreibe eine Funktion `euro_zu_dollar(euro)`, die den Betrag umrechnet (Faktor 1.1) und zurÃ¼ckgibt.

**Level 2: Temperatur**
Schreibe `celsius_zu_fahrenheit(c)`. Formel: `(c * 9/5) + 32`.

**Level 3: Der Tannenbaum**
Schreibe eine Funktion `baum(hoehe)`, die einen Tannenbaum in der gewÃ¼nschten HÃ¶he printet:
```
  *
 ***
*****
  |
```

---

### ğŸ“š Was du gelernt hast:

- âœ… **def:** Das Zauberwort zum Definieren.
- âœ… **Parameter:** Variablen, die man in die Funktion hineinwirft.
- âœ… **Return:** Die Antwort der Funktion (wichtig zum Weiterrechnen!).
- âœ… **Scope:** Was in der Funktion passiert, bleibt in der Funktion.
- âœ… **ModularitÃ¤t:** GroÃŸe Probleme in kleine Funktionen zerlegen.

**ğŸ‰ Erfolgserlebnis:** Ein professioneller BMI-Rechner mit Fehlerbehandlung und mehreren Funktionen!

---

### ğŸ“š Was du gelernt hast:

- âœ… **Funktionen definieren:** `def funktionsname():`
- âœ… **Parameter:** Eingabe-Werte an Funktionen Ã¼bergeben
- âœ… **Return:** Werte aus Funktionen zurÃ¼ckgeben
- âœ… **Docstrings:** Funktionen dokumentieren mit `"""`
- âœ… **Mehrere RÃ¼ckgabewerte:** Mit Tupel `return a, b`
- âœ… **Try-Except:** Fehlerbehandlung (Basis)
- âœ… **Single Responsibility:** Eine Funktion = eine Aufgabe
- âœ… **main():** Hauptfunktion als Einstiegspunkt

---

### ğŸ’ª Challenge:
Erstelle eine Funktion `ideales_gewicht()` die basierend auf GrÃ¶ÃŸe und Geschlecht das empfohlene Gewicht berechnet!

---

## ğŸ‰ Woche 1 abgeschlossen!

**Herzlichen GlÃ¼ckwunsch!** Du hast die Grundlagen von Python gemeistert:

âœ… Variablen und Datentypen  
âœ… Strings und ihre Methoden  
âœ… If/Else Bedingungen  
âœ… Listen  
âœ… For-Schleifen  
âœ… While-Schleifen  
âœ… Funktionen  

**NÃ¤chste Woche:** Fortgeschrittene Basics (Dictionaries, Dateioperationen, Error Handling)

---

**ğŸ“ Dateien:** Alle Ãœbungen von Tag 1-7 findest du in `woche1_grundlagen.md`
